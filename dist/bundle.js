/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/pica/dist/pica.js":
/*!****************************************!*\
  !*** ./node_modules/pica/dist/pica.js ***!
  \****************************************/
/***/ ((module) => {

eval("/*!\n\npica\nhttps://github.com/nodeca/pica\n\n*/\n\n(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(_dereq_,module,exports){\n// Collection of math functions\n//\n// 1. Combine components together\n// 2. Has async init to load wasm modules\n//\n'use strict';\n\nvar Multimath = _dereq_('multimath');\n\nvar mm_unsharp_mask = _dereq_('./mm_unsharp_mask');\n\nvar mm_resize = _dereq_('./mm_resize');\n\nfunction MathLib(requested_features) {\n  var __requested_features = requested_features || [];\n\n  var features = {\n    js: __requested_features.indexOf('js') >= 0,\n    wasm: __requested_features.indexOf('wasm') >= 0\n  };\n  Multimath.call(this, features);\n  this.features = {\n    js: features.js,\n    wasm: features.wasm && this.has_wasm()\n  };\n  this.use(mm_unsharp_mask);\n  this.use(mm_resize);\n}\n\nMathLib.prototype = Object.create(Multimath.prototype);\nMathLib.prototype.constructor = MathLib;\n\nMathLib.prototype.resizeAndUnsharp = function resizeAndUnsharp(options, cache) {\n  var result = this.resize(options, cache);\n\n  if (options.unsharpAmount) {\n    this.unsharp_mask(result, options.toWidth, options.toHeight, options.unsharpAmount, options.unsharpRadius, options.unsharpThreshold);\n  }\n\n  return result;\n};\n\nmodule.exports = MathLib;\n\n},{\"./mm_resize\":4,\"./mm_unsharp_mask\":9,\"multimath\":19}],2:[function(_dereq_,module,exports){\n// Resize convolvers, pure JS implementation\n//\n'use strict'; // Precision of fixed FP values\n//var FIXED_FRAC_BITS = 14;\n\nfunction clampTo8(i) {\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clampNegative(i) {\n  return i >= 0 ? i : 0;\n} // Convolve image data in horizontal direction. Can be used for:\n//\n// 1. bitmap with premultiplied alpha\n// 2. bitmap without alpha (all values 255)\n//\n// Notes:\n//\n// - output is transposed\n// - output resolution is ~15 bits per channel(for better precision).\n//\n\n\nfunction convolveHor(src, dest, srcW, srcH, destW, filters) {\n  var r, g, b, a;\n  var filterPtr, filterShift, filterSize;\n  var srcPtr, srcY, destX, filterVal;\n  var srcOffset = 0,\n      destOffset = 0; // For each row\n\n  for (srcY = 0; srcY < srcH; srcY++) {\n    filterPtr = 0; // Apply precomputed filters to each destination row point\n\n    for (destX = 0; destX < destW; destX++) {\n      // Get the filter that determines the current output pixel.\n      filterShift = filters[filterPtr++];\n      filterSize = filters[filterPtr++];\n      srcPtr = srcOffset + filterShift * 4 | 0;\n      r = g = b = a = 0; // Apply the filter to the row to get the destination pixel r, g, b, a\n\n      for (; filterSize > 0; filterSize--) {\n        filterVal = filters[filterPtr++]; // Use reverse order to workaround deopts in old v8 (node v.10)\n        // Big thanks to @mraleph (Vyacheslav Egorov) for the tip.\n\n        a = a + filterVal * src[srcPtr + 3] | 0;\n        b = b + filterVal * src[srcPtr + 2] | 0;\n        g = g + filterVal * src[srcPtr + 1] | 0;\n        r = r + filterVal * src[srcPtr] | 0;\n        srcPtr = srcPtr + 4 | 0;\n      } // Store 15 bits between passes for better precision\n      // Instead of shift to 14 (FIXED_FRAC_BITS), shift to 7 only\n      //\n\n\n      dest[destOffset + 3] = clampNegative(a >> 7);\n      dest[destOffset + 2] = clampNegative(b >> 7);\n      dest[destOffset + 1] = clampNegative(g >> 7);\n      dest[destOffset] = clampNegative(r >> 7);\n      destOffset = destOffset + srcH * 4 | 0;\n    }\n\n    destOffset = (srcY + 1) * 4 | 0;\n    srcOffset = (srcY + 1) * srcW * 4 | 0;\n  }\n} // Supplementary method for `convolveHor()`\n//\n\n\nfunction convolveVert(src, dest, srcW, srcH, destW, filters) {\n  var r, g, b, a;\n  var filterPtr, filterShift, filterSize;\n  var srcPtr, srcY, destX, filterVal;\n  var srcOffset = 0,\n      destOffset = 0; // For each row\n\n  for (srcY = 0; srcY < srcH; srcY++) {\n    filterPtr = 0; // Apply precomputed filters to each destination row point\n\n    for (destX = 0; destX < destW; destX++) {\n      // Get the filter that determines the current output pixel.\n      filterShift = filters[filterPtr++];\n      filterSize = filters[filterPtr++];\n      srcPtr = srcOffset + filterShift * 4 | 0;\n      r = g = b = a = 0; // Apply the filter to the row to get the destination pixel r, g, b, a\n\n      for (; filterSize > 0; filterSize--) {\n        filterVal = filters[filterPtr++]; // Use reverse order to workaround deopts in old v8 (node v.10)\n        // Big thanks to @mraleph (Vyacheslav Egorov) for the tip.\n\n        a = a + filterVal * src[srcPtr + 3] | 0;\n        b = b + filterVal * src[srcPtr + 2] | 0;\n        g = g + filterVal * src[srcPtr + 1] | 0;\n        r = r + filterVal * src[srcPtr] | 0;\n        srcPtr = srcPtr + 4 | 0;\n      } // Sync with premultiplied version for exact result match\n\n\n      r >>= 7;\n      g >>= 7;\n      b >>= 7;\n      a >>= 7; // Bring this value back in range + round result.\n      //\n\n      dest[destOffset + 3] = clampTo8(a + (1 << 13) >> 14);\n      dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14);\n      dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14);\n      dest[destOffset] = clampTo8(r + (1 << 13) >> 14);\n      destOffset = destOffset + srcH * 4 | 0;\n    }\n\n    destOffset = (srcY + 1) * 4 | 0;\n    srcOffset = (srcY + 1) * srcW * 4 | 0;\n  }\n} // Premultiply & convolve image data in horizontal direction. Can be used for:\n//\n// - Any bitmap data, extracted with `.getImageData()` method (with\n//   non-premultiplied alpha)\n//\n// For images without alpha channel this method is slower than `convolveHor()`\n//\n\n\nfunction convolveHorWithPre(src, dest, srcW, srcH, destW, filters) {\n  var r, g, b, a, alpha;\n  var filterPtr, filterShift, filterSize;\n  var srcPtr, srcY, destX, filterVal;\n  var srcOffset = 0,\n      destOffset = 0; // For each row\n\n  for (srcY = 0; srcY < srcH; srcY++) {\n    filterPtr = 0; // Apply precomputed filters to each destination row point\n\n    for (destX = 0; destX < destW; destX++) {\n      // Get the filter that determines the current output pixel.\n      filterShift = filters[filterPtr++];\n      filterSize = filters[filterPtr++];\n      srcPtr = srcOffset + filterShift * 4 | 0;\n      r = g = b = a = 0; // Apply the filter to the row to get the destination pixel r, g, b, a\n\n      for (; filterSize > 0; filterSize--) {\n        filterVal = filters[filterPtr++]; // Use reverse order to workaround deopts in old v8 (node v.10)\n        // Big thanks to @mraleph (Vyacheslav Egorov) for the tip.\n\n        alpha = src[srcPtr + 3];\n        a = a + filterVal * alpha | 0;\n        b = b + filterVal * src[srcPtr + 2] * alpha | 0;\n        g = g + filterVal * src[srcPtr + 1] * alpha | 0;\n        r = r + filterVal * src[srcPtr] * alpha | 0;\n        srcPtr = srcPtr + 4 | 0;\n      } // Premultiply is (* alpha / 255).\n      // Postpone division for better performance\n\n\n      b = b / 255 | 0;\n      g = g / 255 | 0;\n      r = r / 255 | 0; // Store 15 bits between passes for better precision\n      // Instead of shift to 14 (FIXED_FRAC_BITS), shift to 7 only\n      //\n\n      dest[destOffset + 3] = clampNegative(a >> 7);\n      dest[destOffset + 2] = clampNegative(b >> 7);\n      dest[destOffset + 1] = clampNegative(g >> 7);\n      dest[destOffset] = clampNegative(r >> 7);\n      destOffset = destOffset + srcH * 4 | 0;\n    }\n\n    destOffset = (srcY + 1) * 4 | 0;\n    srcOffset = (srcY + 1) * srcW * 4 | 0;\n  }\n} // Supplementary method for `convolveHorWithPre()`\n//\n\n\nfunction convolveVertWithPre(src, dest, srcW, srcH, destW, filters) {\n  var r, g, b, a;\n  var filterPtr, filterShift, filterSize;\n  var srcPtr, srcY, destX, filterVal;\n  var srcOffset = 0,\n      destOffset = 0; // For each row\n\n  for (srcY = 0; srcY < srcH; srcY++) {\n    filterPtr = 0; // Apply precomputed filters to each destination row point\n\n    for (destX = 0; destX < destW; destX++) {\n      // Get the filter that determines the current output pixel.\n      filterShift = filters[filterPtr++];\n      filterSize = filters[filterPtr++];\n      srcPtr = srcOffset + filterShift * 4 | 0;\n      r = g = b = a = 0; // Apply the filter to the row to get the destination pixel r, g, b, a\n\n      for (; filterSize > 0; filterSize--) {\n        filterVal = filters[filterPtr++]; // Use reverse order to workaround deopts in old v8 (node v.10)\n        // Big thanks to @mraleph (Vyacheslav Egorov) for the tip.\n\n        a = a + filterVal * src[srcPtr + 3] | 0;\n        b = b + filterVal * src[srcPtr + 2] | 0;\n        g = g + filterVal * src[srcPtr + 1] | 0;\n        r = r + filterVal * src[srcPtr] | 0;\n        srcPtr = srcPtr + 4 | 0;\n      } // Downscale to leave room for un-premultiply\n\n\n      r >>= 7;\n      g >>= 7;\n      b >>= 7;\n      a >>= 7; // Un-premultiply\n\n      a = clampTo8(a + (1 << 13) >> 14);\n\n      if (a > 0) {\n        r = r * 255 / a | 0;\n        g = g * 255 / a | 0;\n        b = b * 255 / a | 0;\n      } // Bring this value back in range + round result.\n      // Shift value = FIXED_FRAC_BITS + 7\n      //\n\n\n      dest[destOffset + 3] = a;\n      dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14);\n      dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14);\n      dest[destOffset] = clampTo8(r + (1 << 13) >> 14);\n      destOffset = destOffset + srcH * 4 | 0;\n    }\n\n    destOffset = (srcY + 1) * 4 | 0;\n    srcOffset = (srcY + 1) * srcW * 4 | 0;\n  }\n}\n\nmodule.exports = {\n  convolveHor: convolveHor,\n  convolveVert: convolveVert,\n  convolveHorWithPre: convolveHorWithPre,\n  convolveVertWithPre: convolveVertWithPre\n};\n\n},{}],3:[function(_dereq_,module,exports){\n// This is autogenerated file from math.wasm, don't edit.\n//\n'use strict';\n/* eslint-disable max-len */\n\nmodule.exports = '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';\n\n},{}],4:[function(_dereq_,module,exports){\n'use strict';\n\nmodule.exports = {\n  name: 'resize',\n  fn: _dereq_('./resize'),\n  wasm_fn: _dereq_('./resize_wasm'),\n  wasm_src: _dereq_('./convolve_wasm_base64')\n};\n\n},{\"./convolve_wasm_base64\":3,\"./resize\":5,\"./resize_wasm\":8}],5:[function(_dereq_,module,exports){\n'use strict';\n\nvar createFilters = _dereq_('./resize_filter_gen');\n\nvar _require = _dereq_('./convolve'),\n    convolveHor = _require.convolveHor,\n    convolveVert = _require.convolveVert,\n    convolveHorWithPre = _require.convolveHorWithPre,\n    convolveVertWithPre = _require.convolveVertWithPre;\n\nfunction hasAlpha(src, width, height) {\n  var ptr = 3,\n      len = width * height * 4 | 0;\n\n  while (ptr < len) {\n    if (src[ptr] !== 255) return true;\n    ptr = ptr + 4 | 0;\n  }\n\n  return false;\n}\n\nfunction resetAlpha(dst, width, height) {\n  var ptr = 3,\n      len = width * height * 4 | 0;\n\n  while (ptr < len) {\n    dst[ptr] = 0xFF;\n    ptr = ptr + 4 | 0;\n  }\n}\n\nmodule.exports = function resize(options) {\n  var src = options.src;\n  var srcW = options.width;\n  var srcH = options.height;\n  var destW = options.toWidth;\n  var destH = options.toHeight;\n  var scaleX = options.scaleX || options.toWidth / options.width;\n  var scaleY = options.scaleY || options.toHeight / options.height;\n  var offsetX = options.offsetX || 0;\n  var offsetY = options.offsetY || 0;\n  var dest = options.dest || new Uint8Array(destW * destH * 4);\n  var filter = typeof options.filter === 'undefined' ? 'mks2013' : options.filter;\n  var filtersX = createFilters(filter, srcW, destW, scaleX, offsetX),\n      filtersY = createFilters(filter, srcH, destH, scaleY, offsetY);\n  var tmp = new Uint16Array(destW * srcH * 4); // Autodetect if alpha channel exists, and use appropriate method\n\n  if (hasAlpha(src, srcW, srcH)) {\n    convolveHorWithPre(src, tmp, srcW, srcH, destW, filtersX);\n    convolveVertWithPre(tmp, dest, srcH, destW, destH, filtersY);\n  } else {\n    convolveHor(src, tmp, srcW, srcH, destW, filtersX);\n    convolveVert(tmp, dest, srcH, destW, destH, filtersY);\n    resetAlpha(dest, destW, destH);\n  }\n\n  return dest;\n};\n\n},{\"./convolve\":2,\"./resize_filter_gen\":6}],6:[function(_dereq_,module,exports){\n// Calculate convolution filters for each destination point,\n// and pack data to Int16Array:\n//\n// [ shift, length, data..., shift2, length2, data..., ... ]\n//\n// - shift - offset in src image\n// - length - filter length (in src points)\n// - data - filter values sequence\n//\n'use strict';\n\nvar FILTER_INFO = _dereq_('./resize_filter_info'); // Precision of fixed FP values\n\n\nvar FIXED_FRAC_BITS = 14;\n\nfunction toFixedPoint(num) {\n  return Math.round(num * ((1 << FIXED_FRAC_BITS) - 1));\n}\n\nmodule.exports = function resizeFilterGen(filter, srcSize, destSize, scale, offset) {\n  var filterFunction = FILTER_INFO.filter[filter].fn;\n  var scaleInverted = 1.0 / scale;\n  var scaleClamped = Math.min(1.0, scale); // For upscale\n  // Filter window (averaging interval), scaled to src image\n\n  var srcWindow = FILTER_INFO.filter[filter].win / scaleClamped;\n  var destPixel, srcPixel, srcFirst, srcLast, filterElementSize, floatFilter, fxpFilter, total, pxl, idx, floatVal, filterTotal, filterVal;\n  var leftNotEmpty, rightNotEmpty, filterShift, filterSize;\n  var maxFilterElementSize = Math.floor((srcWindow + 1) * 2);\n  var packedFilter = new Int16Array((maxFilterElementSize + 2) * destSize);\n  var packedFilterPtr = 0;\n  var slowCopy = !packedFilter.subarray || !packedFilter.set; // For each destination pixel calculate source range and built filter values\n\n  for (destPixel = 0; destPixel < destSize; destPixel++) {\n    // Scaling should be done relative to central pixel point\n    srcPixel = (destPixel + 0.5) * scaleInverted + offset;\n    srcFirst = Math.max(0, Math.floor(srcPixel - srcWindow));\n    srcLast = Math.min(srcSize - 1, Math.ceil(srcPixel + srcWindow));\n    filterElementSize = srcLast - srcFirst + 1;\n    floatFilter = new Float32Array(filterElementSize);\n    fxpFilter = new Int16Array(filterElementSize);\n    total = 0.0; // Fill filter values for calculated range\n\n    for (pxl = srcFirst, idx = 0; pxl <= srcLast; pxl++, idx++) {\n      floatVal = filterFunction((pxl + 0.5 - srcPixel) * scaleClamped);\n      total += floatVal;\n      floatFilter[idx] = floatVal;\n    } // Normalize filter, convert to fixed point and accumulate conversion error\n\n\n    filterTotal = 0;\n\n    for (idx = 0; idx < floatFilter.length; idx++) {\n      filterVal = floatFilter[idx] / total;\n      filterTotal += filterVal;\n      fxpFilter[idx] = toFixedPoint(filterVal);\n    } // Compensate normalization error, to minimize brightness drift\n\n\n    fxpFilter[destSize >> 1] += toFixedPoint(1.0 - filterTotal); //\n    // Now pack filter to useable form\n    //\n    // 1. Trim heading and tailing zero values, and compensate shitf/length\n    // 2. Put all to single array in this format:\n    //\n    //    [ pos shift, data length, value1, value2, value3, ... ]\n    //\n\n    leftNotEmpty = 0;\n\n    while (leftNotEmpty < fxpFilter.length && fxpFilter[leftNotEmpty] === 0) {\n      leftNotEmpty++;\n    }\n\n    if (leftNotEmpty < fxpFilter.length) {\n      rightNotEmpty = fxpFilter.length - 1;\n\n      while (rightNotEmpty > 0 && fxpFilter[rightNotEmpty] === 0) {\n        rightNotEmpty--;\n      }\n\n      filterShift = srcFirst + leftNotEmpty;\n      filterSize = rightNotEmpty - leftNotEmpty + 1;\n      packedFilter[packedFilterPtr++] = filterShift; // shift\n\n      packedFilter[packedFilterPtr++] = filterSize; // size\n\n      if (!slowCopy) {\n        packedFilter.set(fxpFilter.subarray(leftNotEmpty, rightNotEmpty + 1), packedFilterPtr);\n        packedFilterPtr += filterSize;\n      } else {\n        // fallback for old IE < 11, without subarray/set methods\n        for (idx = leftNotEmpty; idx <= rightNotEmpty; idx++) {\n          packedFilter[packedFilterPtr++] = fxpFilter[idx];\n        }\n      }\n    } else {\n      // zero data, write header only\n      packedFilter[packedFilterPtr++] = 0; // shift\n\n      packedFilter[packedFilterPtr++] = 0; // size\n    }\n  }\n\n  return packedFilter;\n};\n\n},{\"./resize_filter_info\":7}],7:[function(_dereq_,module,exports){\n// Filter definitions to build tables for\n// resizing convolvers.\n//\n// Presets for quality 0..3. Filter functions + window size\n//\n'use strict';\n\nvar filter = {\n  // Nearest neibor\n  box: {\n    win: 0.5,\n    fn: function fn(x) {\n      if (x < 0) x = -x;\n      return x < 0.5 ? 1.0 : 0.0;\n    }\n  },\n  // // Hamming\n  hamming: {\n    win: 1.0,\n    fn: function fn(x) {\n      if (x < 0) x = -x;\n\n      if (x >= 1.0) {\n        return 0.0;\n      }\n\n      if (x < 1.19209290E-07) {\n        return 1.0;\n      }\n\n      var xpi = x * Math.PI;\n      return Math.sin(xpi) / xpi * (0.54 + 0.46 * Math.cos(xpi / 1.0));\n    }\n  },\n  // Lanczos, win = 2\n  lanczos2: {\n    win: 2.0,\n    fn: function fn(x) {\n      if (x < 0) x = -x;\n\n      if (x >= 2.0) {\n        return 0.0;\n      }\n\n      if (x < 1.19209290E-07) {\n        return 1.0;\n      }\n\n      var xpi = x * Math.PI;\n      return Math.sin(xpi) / xpi * Math.sin(xpi / 2.0) / (xpi / 2.0);\n    }\n  },\n  // Lanczos, win = 3\n  lanczos3: {\n    win: 3.0,\n    fn: function fn(x) {\n      if (x < 0) x = -x;\n\n      if (x >= 3.0) {\n        return 0.0;\n      }\n\n      if (x < 1.19209290E-07) {\n        return 1.0;\n      }\n\n      var xpi = x * Math.PI;\n      return Math.sin(xpi) / xpi * Math.sin(xpi / 3.0) / (xpi / 3.0);\n    }\n  },\n  // Magic Kernel Sharp 2013, win = 2.5\n  // http://johncostella.com/magic/\n  mks2013: {\n    win: 2.5,\n    fn: function fn(x) {\n      if (x < 0) x = -x;\n\n      if (x >= 2.5) {\n        return 0.0;\n      }\n\n      if (x >= 1.5) {\n        return -0.125 * (x - 2.5) * (x - 2.5);\n      }\n\n      if (x >= 0.5) {\n        return 0.25 * (4 * x * x - 11 * x + 7);\n      }\n\n      return 1.0625 - 1.75 * x * x;\n    }\n  }\n};\nmodule.exports = {\n  filter: filter,\n  // Legacy mapping\n  f2q: {\n    box: 0,\n    hamming: 1,\n    lanczos2: 2,\n    lanczos3: 3\n  },\n  q2f: ['box', 'hamming', 'lanczos2', 'lanczos3']\n};\n\n},{}],8:[function(_dereq_,module,exports){\n'use strict';\n\nvar createFilters = _dereq_('./resize_filter_gen');\n\nfunction hasAlpha(src, width, height) {\n  var ptr = 3,\n      len = width * height * 4 | 0;\n\n  while (ptr < len) {\n    if (src[ptr] !== 255) return true;\n    ptr = ptr + 4 | 0;\n  }\n\n  return false;\n}\n\nfunction resetAlpha(dst, width, height) {\n  var ptr = 3,\n      len = width * height * 4 | 0;\n\n  while (ptr < len) {\n    dst[ptr] = 0xFF;\n    ptr = ptr + 4 | 0;\n  }\n}\n\nfunction asUint8Array(src) {\n  return new Uint8Array(src.buffer, 0, src.byteLength);\n}\n\nvar IS_LE = true; // should not crash everything on module load in old browsers\n\ntry {\n  IS_LE = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1;\n} catch (__) {}\n\nfunction copyInt16asLE(src, target, target_offset) {\n  if (IS_LE) {\n    target.set(asUint8Array(src), target_offset);\n    return;\n  }\n\n  for (var ptr = target_offset, i = 0; i < src.length; i++) {\n    var data = src[i];\n    target[ptr++] = data & 0xFF;\n    target[ptr++] = data >> 8 & 0xFF;\n  }\n}\n\nmodule.exports = function resize_wasm(options) {\n  var src = options.src;\n  var srcW = options.width;\n  var srcH = options.height;\n  var destW = options.toWidth;\n  var destH = options.toHeight;\n  var scaleX = options.scaleX || options.toWidth / options.width;\n  var scaleY = options.scaleY || options.toHeight / options.height;\n  var offsetX = options.offsetX || 0.0;\n  var offsetY = options.offsetY || 0.0;\n  var dest = options.dest || new Uint8Array(destW * destH * 4);\n  var filter = typeof options.filter === 'undefined' ? 'mks2013' : options.filter;\n  var filtersX = createFilters(filter, srcW, destW, scaleX, offsetX),\n      filtersY = createFilters(filter, srcH, destH, scaleY, offsetY); // destination is 0 too.\n\n  var src_offset = 0;\n  var src_size = Math.max(src.byteLength, dest.byteLength); // buffer between convolve passes\n\n  var tmp_offset = this.__align(src_offset + src_size);\n\n  var tmp_size = srcH * destW * 4 * 2; // 2 bytes per channel\n\n  var filtersX_offset = this.__align(tmp_offset + tmp_size);\n\n  var filtersY_offset = this.__align(filtersX_offset + filtersX.byteLength);\n\n  var alloc_bytes = filtersY_offset + filtersY.byteLength;\n\n  var instance = this.__instance('resize', alloc_bytes); //\n  // Fill memory block with data to process\n  //\n\n\n  var mem = new Uint8Array(this.__memory.buffer);\n  var mem32 = new Uint32Array(this.__memory.buffer); // 32-bit copy is much faster in chrome\n\n  var src32 = new Uint32Array(src.buffer);\n  mem32.set(src32); // We should guarantee LE bytes order. Filters are not big, so\n  // speed difference is not significant vs direct .set()\n\n  copyInt16asLE(filtersX, mem, filtersX_offset);\n  copyInt16asLE(filtersY, mem, filtersY_offset); // Now call webassembly method\n  // emsdk does method names with '_'\n\n  var fn = instance.exports.convolveHV || instance.exports._convolveHV;\n\n  if (hasAlpha(src, srcW, srcH)) {\n    fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH, 1);\n  } else {\n    fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH, 0);\n    resetAlpha(dest, destW, destH);\n  } //\n  // Copy data back to typed array\n  //\n  // 32-bit copy is much faster in chrome\n\n\n  var dest32 = new Uint32Array(dest.buffer);\n  dest32.set(new Uint32Array(this.__memory.buffer, 0, destH * destW));\n  return dest;\n};\n\n},{\"./resize_filter_gen\":6}],9:[function(_dereq_,module,exports){\n'use strict';\n\nmodule.exports = {\n  name: 'unsharp_mask',\n  fn: _dereq_('./unsharp_mask'),\n  wasm_fn: _dereq_('./unsharp_mask_wasm'),\n  wasm_src: _dereq_('./unsharp_mask_wasm_base64')\n};\n\n},{\"./unsharp_mask\":10,\"./unsharp_mask_wasm\":11,\"./unsharp_mask_wasm_base64\":12}],10:[function(_dereq_,module,exports){\n// Unsharp mask filter\n//\n// http://stackoverflow.com/a/23322820/1031804\n// USM(O) = O + (2 * (Amount / 100) * (O - GB))\n// GB - gaussian blur.\n//\n// Image is converted from RGB to HSV, unsharp mask is applied to the\n// brightness channel and then image is converted back to RGB.\n//\n'use strict';\n\nvar glur_mono16 = _dereq_('glur/mono16');\n\nfunction hsv_v16(img, width, height) {\n  var size = width * height;\n  var out = new Uint16Array(size);\n  var r, g, b, max;\n\n  for (var i = 0; i < size; i++) {\n    r = img[4 * i];\n    g = img[4 * i + 1];\n    b = img[4 * i + 2];\n    max = r >= g && r >= b ? r : g >= b && g >= r ? g : b;\n    out[i] = max << 8;\n  }\n\n  return out;\n}\n\nmodule.exports = function unsharp(img, width, height, amount, radius, threshold) {\n  var v1, v2, vmul;\n  var diff, iTimes4;\n\n  if (amount === 0 || radius < 0.5) {\n    return;\n  }\n\n  if (radius > 2.0) {\n    radius = 2.0;\n  }\n\n  var brightness = hsv_v16(img, width, height);\n  var blured = new Uint16Array(brightness); // copy, because blur modify src\n\n  glur_mono16(blured, width, height, radius);\n  var amountFp = amount / 100 * 0x1000 + 0.5 | 0;\n  var thresholdFp = threshold << 8;\n  var size = width * height;\n  /* eslint-disable indent */\n\n  for (var i = 0; i < size; i++) {\n    v1 = brightness[i];\n    diff = v1 - blured[i];\n\n    if (Math.abs(diff) >= thresholdFp) {\n      // add unsharp mask to the brightness channel\n      v2 = v1 + (amountFp * diff + 0x800 >> 12); // Both v1 and v2 are within [0.0 .. 255.0] (0000-FF00) range, never going into\n      // [255.003 .. 255.996] (FF01-FFFF). This allows to round this value as (x+.5)|0\n      // later without overflowing.\n\n      v2 = v2 > 0xff00 ? 0xff00 : v2;\n      v2 = v2 < 0x0000 ? 0x0000 : v2; // Avoid division by 0. V=0 means rgb(0,0,0), unsharp with unsharpAmount>0 cannot\n      // change this value (because diff between colors gets inflated), so no need to verify correctness.\n\n      v1 = v1 !== 0 ? v1 : 1; // Multiplying V in HSV model by a constant is equivalent to multiplying each component\n      // in RGB by the same constant (same for HSL), see also:\n      // https://beesbuzz.biz/code/16-hsv-color-transforms\n\n      vmul = (v2 << 12) / v1 | 0; // Result will be in [0..255] range because:\n      //  - all numbers are positive\n      //  - r,g,b <= (v1/256)\n      //  - r,g,b,(v1/256),(v2/256) <= 255\n      // So highest this number can get is X*255/X+0.5=255.5 which is < 256 and rounds down.\n\n      iTimes4 = i * 4;\n      img[iTimes4] = img[iTimes4] * vmul + 0x800 >> 12; // R\n\n      img[iTimes4 + 1] = img[iTimes4 + 1] * vmul + 0x800 >> 12; // G\n\n      img[iTimes4 + 2] = img[iTimes4 + 2] * vmul + 0x800 >> 12; // B\n    }\n  }\n};\n\n},{\"glur/mono16\":18}],11:[function(_dereq_,module,exports){\n'use strict';\n\nmodule.exports = function unsharp(img, width, height, amount, radius, threshold) {\n  if (amount === 0 || radius < 0.5) {\n    return;\n  }\n\n  if (radius > 2.0) {\n    radius = 2.0;\n  }\n\n  var pixels = width * height;\n  var img_bytes_cnt = pixels * 4;\n  var hsv_bytes_cnt = pixels * 2;\n  var blur_bytes_cnt = pixels * 2;\n  var blur_line_byte_cnt = Math.max(width, height) * 4; // float32 array\n\n  var blur_coeffs_byte_cnt = 8 * 4; // float32 array\n\n  var img_offset = 0;\n  var hsv_offset = img_bytes_cnt;\n  var blur_offset = hsv_offset + hsv_bytes_cnt;\n  var blur_tmp_offset = blur_offset + blur_bytes_cnt;\n  var blur_line_offset = blur_tmp_offset + blur_bytes_cnt;\n  var blur_coeffs_offset = blur_line_offset + blur_line_byte_cnt;\n\n  var instance = this.__instance('unsharp_mask', img_bytes_cnt + hsv_bytes_cnt + blur_bytes_cnt * 2 + blur_line_byte_cnt + blur_coeffs_byte_cnt, {\n    exp: Math.exp\n  }); // 32-bit copy is much faster in chrome\n\n\n  var img32 = new Uint32Array(img.buffer);\n  var mem32 = new Uint32Array(this.__memory.buffer);\n  mem32.set(img32); // HSL\n\n  var fn = instance.exports.hsv_v16 || instance.exports._hsv_v16;\n  fn(img_offset, hsv_offset, width, height); // BLUR\n\n  fn = instance.exports.blurMono16 || instance.exports._blurMono16;\n  fn(hsv_offset, blur_offset, blur_tmp_offset, blur_line_offset, blur_coeffs_offset, width, height, radius); // UNSHARP\n\n  fn = instance.exports.unsharp || instance.exports._unsharp;\n  fn(img_offset, img_offset, hsv_offset, blur_offset, width, height, amount, threshold); // 32-bit copy is much faster in chrome\n\n  img32.set(new Uint32Array(this.__memory.buffer, 0, pixels));\n};\n\n},{}],12:[function(_dereq_,module,exports){\n// This is autogenerated file from math.wasm, don't edit.\n//\n'use strict';\n/* eslint-disable max-len */\n\nmodule.exports = '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';\n\n},{}],13:[function(_dereq_,module,exports){\n'use strict';\n\nvar GC_INTERVAL = 100;\n\nfunction Pool(create, idle) {\n  this.create = create;\n  this.available = [];\n  this.acquired = {};\n  this.lastId = 1;\n  this.timeoutId = 0;\n  this.idle = idle || 2000;\n}\n\nPool.prototype.acquire = function () {\n  var _this = this;\n\n  var resource;\n\n  if (this.available.length !== 0) {\n    resource = this.available.pop();\n  } else {\n    resource = this.create();\n    resource.id = this.lastId++;\n\n    resource.release = function () {\n      return _this.release(resource);\n    };\n  }\n\n  this.acquired[resource.id] = resource;\n  return resource;\n};\n\nPool.prototype.release = function (resource) {\n  var _this2 = this;\n\n  delete this.acquired[resource.id];\n  resource.lastUsed = Date.now();\n  this.available.push(resource);\n\n  if (this.timeoutId === 0) {\n    this.timeoutId = setTimeout(function () {\n      return _this2.gc();\n    }, GC_INTERVAL);\n  }\n};\n\nPool.prototype.gc = function () {\n  var _this3 = this;\n\n  var now = Date.now();\n  this.available = this.available.filter(function (resource) {\n    if (now - resource.lastUsed > _this3.idle) {\n      resource.destroy();\n      return false;\n    }\n\n    return true;\n  });\n\n  if (this.available.length !== 0) {\n    this.timeoutId = setTimeout(function () {\n      return _this3.gc();\n    }, GC_INTERVAL);\n  } else {\n    this.timeoutId = 0;\n  }\n};\n\nmodule.exports = Pool;\n\n},{}],14:[function(_dereq_,module,exports){\n// Add intermediate resizing steps when scaling down by a very large factor.\n//\n// For example, when resizing 10000x10000 down to 10x10, it'll resize it to\n// 300x300 first.\n//\n// It's needed because tiler has issues when the entire tile is scaled down\n// to a few pixels (1024px source tile with border size 3 should result in\n// at least 3+3+2 = 8px target tile, so max scale factor is 128 here).\n//\n// Also, adding intermediate steps can speed up processing if we use lower\n// quality algorithms for first stages.\n//\n'use strict'; // min size = 0 results in infinite loop,\n// min size = 1 can consume large amount of memory\n\nvar MIN_INNER_TILE_SIZE = 2;\n\nmodule.exports = function createStages(fromWidth, fromHeight, toWidth, toHeight, srcTileSize, destTileBorder) {\n  var scaleX = toWidth / fromWidth;\n  var scaleY = toHeight / fromHeight; // derived from createRegions equation:\n  // innerTileWidth = pixelFloor(srcTileSize * scaleX) - 2 * destTileBorder;\n\n  var minScale = (2 * destTileBorder + MIN_INNER_TILE_SIZE + 1) / srcTileSize; // refuse to scale image multiple times by less than twice each time,\n  // it could only happen because of invalid options\n\n  if (minScale > 0.5) return [[toWidth, toHeight]];\n  var stageCount = Math.ceil(Math.log(Math.min(scaleX, scaleY)) / Math.log(minScale)); // no additional resizes are necessary,\n  // stageCount can be zero or be negative when enlarging the image\n\n  if (stageCount <= 1) return [[toWidth, toHeight]];\n  var result = [];\n\n  for (var i = 0; i < stageCount; i++) {\n    var width = Math.round(Math.pow(Math.pow(fromWidth, stageCount - i - 1) * Math.pow(toWidth, i + 1), 1 / stageCount));\n    var height = Math.round(Math.pow(Math.pow(fromHeight, stageCount - i - 1) * Math.pow(toHeight, i + 1), 1 / stageCount));\n    result.push([width, height]);\n  }\n\n  return result;\n};\n\n},{}],15:[function(_dereq_,module,exports){\n// Split original image into multiple 1024x1024 chunks to reduce memory usage\n// (images have to be unpacked into typed arrays for resizing) and allow\n// parallel processing of multiple tiles at a time.\n//\n'use strict';\n/*\n * pixelFloor and pixelCeil are modified versions of Math.floor and Math.ceil\n * functions which take into account floating point arithmetic errors.\n * Those errors can cause undesired increments/decrements of sizes and offsets:\n * Math.ceil(36 / (36 / 500)) = 501\n * pixelCeil(36 / (36 / 500)) = 500\n */\n\nvar PIXEL_EPSILON = 1e-5;\n\nfunction pixelFloor(x) {\n  var nearest = Math.round(x);\n\n  if (Math.abs(x - nearest) < PIXEL_EPSILON) {\n    return nearest;\n  }\n\n  return Math.floor(x);\n}\n\nfunction pixelCeil(x) {\n  var nearest = Math.round(x);\n\n  if (Math.abs(x - nearest) < PIXEL_EPSILON) {\n    return nearest;\n  }\n\n  return Math.ceil(x);\n}\n\nmodule.exports = function createRegions(options) {\n  var scaleX = options.toWidth / options.width;\n  var scaleY = options.toHeight / options.height;\n  var innerTileWidth = pixelFloor(options.srcTileSize * scaleX) - 2 * options.destTileBorder;\n  var innerTileHeight = pixelFloor(options.srcTileSize * scaleY) - 2 * options.destTileBorder; // prevent infinite loop, this should never happen\n\n  if (innerTileWidth < 1 || innerTileHeight < 1) {\n    throw new Error('Internal error in pica: target tile width/height is too small.');\n  }\n\n  var x, y;\n  var innerX, innerY, toTileWidth, toTileHeight;\n  var tiles = [];\n  var tile; // we go top-to-down instead of left-to-right to make image displayed from top to\n  // doesn in the browser\n\n  for (innerY = 0; innerY < options.toHeight; innerY += innerTileHeight) {\n    for (innerX = 0; innerX < options.toWidth; innerX += innerTileWidth) {\n      x = innerX - options.destTileBorder;\n\n      if (x < 0) {\n        x = 0;\n      }\n\n      toTileWidth = innerX + innerTileWidth + options.destTileBorder - x;\n\n      if (x + toTileWidth >= options.toWidth) {\n        toTileWidth = options.toWidth - x;\n      }\n\n      y = innerY - options.destTileBorder;\n\n      if (y < 0) {\n        y = 0;\n      }\n\n      toTileHeight = innerY + innerTileHeight + options.destTileBorder - y;\n\n      if (y + toTileHeight >= options.toHeight) {\n        toTileHeight = options.toHeight - y;\n      }\n\n      tile = {\n        toX: x,\n        toY: y,\n        toWidth: toTileWidth,\n        toHeight: toTileHeight,\n        toInnerX: innerX,\n        toInnerY: innerY,\n        toInnerWidth: innerTileWidth,\n        toInnerHeight: innerTileHeight,\n        offsetX: x / scaleX - pixelFloor(x / scaleX),\n        offsetY: y / scaleY - pixelFloor(y / scaleY),\n        scaleX: scaleX,\n        scaleY: scaleY,\n        x: pixelFloor(x / scaleX),\n        y: pixelFloor(y / scaleY),\n        width: pixelCeil(toTileWidth / scaleX),\n        height: pixelCeil(toTileHeight / scaleY)\n      };\n      tiles.push(tile);\n    }\n  }\n\n  return tiles;\n};\n\n},{}],16:[function(_dereq_,module,exports){\n'use strict';\n\nfunction objClass(obj) {\n  return Object.prototype.toString.call(obj);\n}\n\nmodule.exports.isCanvas = function isCanvas(element) {\n  var cname = objClass(element);\n  return cname === '[object HTMLCanvasElement]'\n  /* browser */\n  || cname === '[object OffscreenCanvas]' || cname === '[object Canvas]'\n  /* node-canvas */\n  ;\n};\n\nmodule.exports.isImage = function isImage(element) {\n  return objClass(element) === '[object HTMLImageElement]';\n};\n\nmodule.exports.isImageBitmap = function isImageBitmap(element) {\n  return objClass(element) === '[object ImageBitmap]';\n};\n\nmodule.exports.limiter = function limiter(concurrency) {\n  var active = 0,\n      queue = [];\n\n  function roll() {\n    if (active < concurrency && queue.length) {\n      active++;\n      queue.shift()();\n    }\n  }\n\n  return function limit(fn) {\n    return new Promise(function (resolve, reject) {\n      queue.push(function () {\n        fn().then(function (result) {\n          resolve(result);\n          active--;\n          roll();\n        }, function (err) {\n          reject(err);\n          active--;\n          roll();\n        });\n      });\n      roll();\n    });\n  };\n};\n\nmodule.exports.cib_quality_name = function cib_quality_name(num) {\n  switch (num) {\n    case 0:\n      return 'pixelated';\n\n    case 1:\n      return 'low';\n\n    case 2:\n      return 'medium';\n  }\n\n  return 'high';\n};\n\nmodule.exports.cib_support = function cib_support(createCanvas) {\n  return Promise.resolve().then(function () {\n    if (typeof createImageBitmap === 'undefined') {\n      return false;\n    }\n\n    var c = createCanvas(100, 100);\n    return createImageBitmap(c, 0, 0, 100, 100, {\n      resizeWidth: 10,\n      resizeHeight: 10,\n      resizeQuality: 'high'\n    }).then(function (bitmap) {\n      var status = bitmap.width === 10; // Branch below is filtered on upper level. We do not call resize\n      // detection for basic ImageBitmap.\n      //\n      // https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap\n      // old Crome 51 has ImageBitmap without .close(). Then this code\n      // will throw and return 'false' as expected.\n      //\n\n      bitmap.close();\n      c = null;\n      return status;\n    });\n  })[\"catch\"](function () {\n    return false;\n  });\n};\n\nmodule.exports.worker_offscreen_canvas_support = function worker_offscreen_canvas_support() {\n  return new Promise(function (resolve, reject) {\n    if (typeof OffscreenCanvas === 'undefined') {\n      // if OffscreenCanvas is present, we assume browser supports Worker and built-in Promise as well\n      resolve(false);\n      return;\n    }\n\n    function workerPayload(self) {\n      if (typeof createImageBitmap === 'undefined') {\n        self.postMessage(false);\n        return;\n      }\n\n      Promise.resolve().then(function () {\n        var canvas = new OffscreenCanvas(10, 10); // test that 2d context can be used in worker\n\n        var ctx = canvas.getContext('2d');\n        ctx.rect(0, 0, 1, 1); // test that cib can be used to return image bitmap from worker\n\n        return createImageBitmap(canvas, 0, 0, 1, 1);\n      }).then(function () {\n        return self.postMessage(true);\n      }, function () {\n        return self.postMessage(false);\n      });\n    }\n\n    var code = btoa(\"(\".concat(workerPayload.toString(), \")(self);\"));\n    var w = new Worker(\"data:text/javascript;base64,\".concat(code));\n\n    w.onmessage = function (ev) {\n      return resolve(ev.data);\n    };\n\n    w.onerror = reject;\n  }).then(function (result) {\n    return result;\n  }, function () {\n    return false;\n  });\n}; // Check if canvas.getContext('2d').getImageData can be used,\n// FireFox randomizes the output of that function in `privacy.resistFingerprinting` mode\n\n\nmodule.exports.can_use_canvas = function can_use_canvas(createCanvas) {\n  var usable = false;\n\n  try {\n    var canvas = createCanvas(2, 1);\n    var ctx = canvas.getContext('2d');\n    var d = ctx.createImageData(2, 1);\n    d.data[0] = 12;\n    d.data[1] = 23;\n    d.data[2] = 34;\n    d.data[3] = 255;\n    d.data[4] = 45;\n    d.data[5] = 56;\n    d.data[6] = 67;\n    d.data[7] = 255;\n    ctx.putImageData(d, 0, 0);\n    d = null;\n    d = ctx.getImageData(0, 0, 2, 1);\n\n    if (d.data[0] === 12 && d.data[1] === 23 && d.data[2] === 34 && d.data[3] === 255 && d.data[4] === 45 && d.data[5] === 56 && d.data[6] === 67 && d.data[7] === 255) {\n      usable = true;\n    }\n  } catch (err) {}\n\n  return usable;\n}; // Check if createImageBitmap(img, sx, sy, sw, sh) signature works correctly\n// with JPEG images oriented with Exif;\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1220671\n// TODO: remove after it's fixed in chrome for at least 2 releases\n\n\nmodule.exports.cib_can_use_region = function cib_can_use_region() {\n  return new Promise(function (resolve) {\n    // `Image` check required for use in `ServiceWorker`\n    if (typeof Image === 'undefined' || typeof createImageBitmap === 'undefined') {\n      resolve(false);\n      return;\n    }\n\n    var image = new Image();\n    image.src = 'data:image/jpeg;base64,' + '/9j/4QBiRXhpZgAATU0AKgAAAAgABQESAAMAAAABAAYAAAEaAAUAAAABAAAASgEbAAUAA' + 'AABAAAAUgEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAAAAABIAAAAAQAAAEgAAAAB/9' + 'sAQwAEAwMEAwMEBAMEBQQEBQYKBwYGBgYNCQoICg8NEBAPDQ8OERMYFBESFxIODxUcFRc' + 'ZGRsbGxAUHR8dGh8YGhsa/9sAQwEEBQUGBQYMBwcMGhEPERoaGhoaGhoaGhoaGhoaGhoa' + 'GhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoa/8IAEQgAAQACAwERAAIRAQMRA' + 'f/EABQAAQAAAAAAAAAAAAAAAAAAAAf/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAA' + 'IQAxAAAAF/P//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAQUCf//EABQRAQAAAAA' + 'AAAAAAAAAAAAAAAD/2gAIAQMBAT8Bf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIB' + 'AT8Bf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEABj8Cf//EABQQAQAAAAAAAAAAA' + 'AAAAAAAAAD/2gAIAQEAAT8hf//aAAwDAQACAAMAAAAQH//EABQRAQAAAAAAAAAAAAAAAA' + 'AAAAD/2gAIAQMBAT8Qf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Qf//EABQ' + 'QAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8Qf//Z';\n\n    image.onload = function () {\n      createImageBitmap(image, 0, 0, image.width, image.height).then(function (bitmap) {\n        if (bitmap.width === image.width && bitmap.height === image.height) {\n          resolve(true);\n        } else {\n          resolve(false);\n        }\n      }, function () {\n        return resolve(false);\n      });\n    };\n\n    image.onerror = function () {\n      return resolve(false);\n    };\n  });\n};\n\n},{}],17:[function(_dereq_,module,exports){\n// Web Worker wrapper for image resize function\n'use strict';\n\nmodule.exports = function () {\n  var MathLib = _dereq_('./mathlib');\n\n  var mathLib;\n  /* eslint-disable no-undef */\n\n  onmessage = function onmessage(ev) {\n    var tileOpts = ev.data.opts;\n    var returnBitmap = false;\n\n    if (!tileOpts.src && tileOpts.srcBitmap) {\n      var canvas = new OffscreenCanvas(tileOpts.width, tileOpts.height);\n      var ctx = canvas.getContext('2d');\n      ctx.drawImage(tileOpts.srcBitmap, 0, 0);\n      tileOpts.src = ctx.getImageData(0, 0, tileOpts.width, tileOpts.height).data;\n      canvas.width = canvas.height = 0;\n      canvas = null;\n      tileOpts.srcBitmap.close();\n      tileOpts.srcBitmap = null; // Temporary force out data to typed array, because Chrome have artefacts\n      // https://github.com/nodeca/pica/issues/223\n      // returnBitmap = true;\n    }\n\n    if (!mathLib) mathLib = new MathLib(ev.data.features); // Use multimath's sync auto-init. Avoid Promise use in old browsers,\n    // because polyfills are not propagated to webworker.\n\n    var data = mathLib.resizeAndUnsharp(tileOpts);\n\n    if (returnBitmap) {\n      var toImageData = new ImageData(new Uint8ClampedArray(data), tileOpts.toWidth, tileOpts.toHeight);\n\n      var _canvas = new OffscreenCanvas(tileOpts.toWidth, tileOpts.toHeight);\n\n      var _ctx = _canvas.getContext('2d');\n\n      _ctx.putImageData(toImageData, 0, 0);\n\n      createImageBitmap(_canvas).then(function (bitmap) {\n        postMessage({\n          bitmap: bitmap\n        }, [bitmap]);\n      });\n    } else {\n      postMessage({\n        data: data\n      }, [data.buffer]);\n    }\n  };\n};\n\n},{\"./mathlib\":1}],18:[function(_dereq_,module,exports){\n// Calculate Gaussian blur of an image using IIR filter\n// The method is taken from Intel's white paper and code example attached to it:\n// https://software.intel.com/en-us/articles/iir-gaussian-blur-filter\n// -implementation-using-intel-advanced-vector-extensions\n\nvar a0, a1, a2, a3, b1, b2, left_corner, right_corner;\n\nfunction gaussCoef(sigma) {\n  if (sigma < 0.5) {\n    sigma = 0.5;\n  }\n\n  var a = Math.exp(0.726 * 0.726) / sigma,\n      g1 = Math.exp(-a),\n      g2 = Math.exp(-2 * a),\n      k = (1 - g1) * (1 - g1) / (1 + 2 * a * g1 - g2);\n\n  a0 = k;\n  a1 = k * (a - 1) * g1;\n  a2 = k * (a + 1) * g1;\n  a3 = -k * g2;\n  b1 = 2 * g1;\n  b2 = -g2;\n  left_corner = (a0 + a1) / (1 - b1 - b2);\n  right_corner = (a2 + a3) / (1 - b1 - b2);\n\n  // Attempt to force type to FP32.\n  return new Float32Array([ a0, a1, a2, a3, b1, b2, left_corner, right_corner ]);\n}\n\nfunction convolveMono16(src, out, line, coeff, width, height) {\n  // takes src image and writes the blurred and transposed result into out\n\n  var prev_src, curr_src, curr_out, prev_out, prev_prev_out;\n  var src_index, out_index, line_index;\n  var i, j;\n  var coeff_a0, coeff_a1, coeff_b1, coeff_b2;\n\n  for (i = 0; i < height; i++) {\n    src_index = i * width;\n    out_index = i;\n    line_index = 0;\n\n    // left to right\n    prev_src = src[src_index];\n    prev_prev_out = prev_src * coeff[6];\n    prev_out = prev_prev_out;\n\n    coeff_a0 = coeff[0];\n    coeff_a1 = coeff[1];\n    coeff_b1 = coeff[4];\n    coeff_b2 = coeff[5];\n\n    for (j = 0; j < width; j++) {\n      curr_src = src[src_index];\n\n      curr_out = curr_src * coeff_a0 +\n                 prev_src * coeff_a1 +\n                 prev_out * coeff_b1 +\n                 prev_prev_out * coeff_b2;\n\n      prev_prev_out = prev_out;\n      prev_out = curr_out;\n      prev_src = curr_src;\n\n      line[line_index] = prev_out;\n      line_index++;\n      src_index++;\n    }\n\n    src_index--;\n    line_index--;\n    out_index += height * (width - 1);\n\n    // right to left\n    prev_src = src[src_index];\n    prev_prev_out = prev_src * coeff[7];\n    prev_out = prev_prev_out;\n    curr_src = prev_src;\n\n    coeff_a0 = coeff[2];\n    coeff_a1 = coeff[3];\n\n    for (j = width - 1; j >= 0; j--) {\n      curr_out = curr_src * coeff_a0 +\n                 prev_src * coeff_a1 +\n                 prev_out * coeff_b1 +\n                 prev_prev_out * coeff_b2;\n\n      prev_prev_out = prev_out;\n      prev_out = curr_out;\n\n      prev_src = curr_src;\n      curr_src = src[src_index];\n\n      out[out_index] = line[line_index] + prev_out;\n\n      src_index--;\n      line_index--;\n      out_index -= height;\n    }\n  }\n}\n\n\nfunction blurMono16(src, width, height, radius) {\n  // Quick exit on zero radius\n  if (!radius) { return; }\n\n  var out      = new Uint16Array(src.length),\n      tmp_line = new Float32Array(Math.max(width, height));\n\n  var coeff = gaussCoef(radius);\n\n  convolveMono16(src, out, tmp_line, coeff, width, height, radius);\n  convolveMono16(out, src, tmp_line, coeff, height, width, radius);\n}\n\nmodule.exports = blurMono16;\n\n},{}],19:[function(_dereq_,module,exports){\n'use strict';\n\n\nvar assign         = _dereq_('object-assign');\nvar base64decode   = _dereq_('./lib/base64decode');\nvar hasWebAssembly = _dereq_('./lib/wa_detect');\n\n\nvar DEFAULT_OPTIONS = {\n  js: true,\n  wasm: true\n};\n\n\nfunction MultiMath(options) {\n  if (!(this instanceof MultiMath)) return new MultiMath(options);\n\n  var opts = assign({}, DEFAULT_OPTIONS, options || {});\n\n  this.options         = opts;\n\n  this.__cache         = {};\n\n  this.__init_promise  = null;\n  this.__modules       = opts.modules || {};\n  this.__memory        = null;\n  this.__wasm          = {};\n\n  this.__isLE = ((new Uint32Array((new Uint8Array([ 1, 0, 0, 0 ])).buffer))[0] === 1);\n\n  if (!this.options.js && !this.options.wasm) {\n    throw new Error('mathlib: at least \"js\" or \"wasm\" should be enabled');\n  }\n}\n\n\nMultiMath.prototype.has_wasm = hasWebAssembly;\n\n\nMultiMath.prototype.use = function (module) {\n  this.__modules[module.name] = module;\n\n  // Pin the best possible implementation\n  if (this.options.wasm && this.has_wasm() && module.wasm_fn) {\n    this[module.name] = module.wasm_fn;\n  } else {\n    this[module.name] = module.fn;\n  }\n\n  return this;\n};\n\n\nMultiMath.prototype.init = function () {\n  if (this.__init_promise) return this.__init_promise;\n\n  if (!this.options.js && this.options.wasm && !this.has_wasm()) {\n    return Promise.reject(new Error('mathlib: only \"wasm\" was enabled, but it\\'s not supported'));\n  }\n\n  var self = this;\n\n  this.__init_promise = Promise.all(Object.keys(self.__modules).map(function (name) {\n    var module = self.__modules[name];\n\n    if (!self.options.wasm || !self.has_wasm() || !module.wasm_fn) return null;\n\n    // If already compiled - exit\n    if (self.__wasm[name]) return null;\n\n    // Compile wasm source\n    return WebAssembly.compile(self.__base64decode(module.wasm_src))\n      .then(function (m) { self.__wasm[name] = m; });\n  }))\n    .then(function () { return self; });\n\n  return this.__init_promise;\n};\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Methods below are for internal use from plugins\n\n\n// Simple decode base64 to typed array. Useful to load embedded webassembly\n// code. You probably don't need to call this method directly.\n//\nMultiMath.prototype.__base64decode = base64decode;\n\n\n// Increase current memory to include specified number of bytes. Do nothing if\n// size is already ok. You probably don't need to call this method directly,\n// because it will be invoked from `.__instance()`.\n//\nMultiMath.prototype.__reallocate = function mem_grow_to(bytes) {\n  if (!this.__memory) {\n    this.__memory = new WebAssembly.Memory({\n      initial: Math.ceil(bytes / (64 * 1024))\n    });\n    return this.__memory;\n  }\n\n  var mem_size = this.__memory.buffer.byteLength;\n\n  if (mem_size < bytes) {\n    this.__memory.grow(Math.ceil((bytes - mem_size) / (64 * 1024)));\n  }\n\n  return this.__memory;\n};\n\n\n// Returns instantinated webassembly item by name, with specified memory size\n// and environment.\n// - use cache if available\n// - do sync module init, if async init was not called earlier\n// - allocate memory if not enougth\n// - can export functions to webassembly via \"env_extra\",\n//   for example, { exp: Math.exp }\n//\nMultiMath.prototype.__instance = function instance(name, memsize, env_extra) {\n  if (memsize) this.__reallocate(memsize);\n\n  // If .init() was not called, do sync compile\n  if (!this.__wasm[name]) {\n    var module = this.__modules[name];\n    this.__wasm[name] = new WebAssembly.Module(this.__base64decode(module.wasm_src));\n  }\n\n  if (!this.__cache[name]) {\n    var env_base = {\n      memoryBase: 0,\n      memory: this.__memory,\n      tableBase: 0,\n      table: new WebAssembly.Table({ initial: 0, element: 'anyfunc' })\n    };\n\n    this.__cache[name] = new WebAssembly.Instance(this.__wasm[name], {\n      env: assign(env_base, env_extra || {})\n    });\n  }\n\n  return this.__cache[name];\n};\n\n\n// Helper to calculate memory aligh for pointers. Webassembly does not require\n// this, but you may wish to experiment. Default base = 8;\n//\nMultiMath.prototype.__align = function align(number, base) {\n  base = base || 8;\n  var reminder = number % base;\n  return number + (reminder ? base - reminder : 0);\n};\n\n\nmodule.exports = MultiMath;\n\n},{\"./lib/base64decode\":20,\"./lib/wa_detect\":21,\"object-assign\":22}],20:[function(_dereq_,module,exports){\n// base64 decode str -> Uint8Array, to load WA modules\n//\n'use strict';\n\n\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n\nmodule.exports = function base64decode(str) {\n  var input = str.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max   = input.length;\n\n  var out = new Uint8Array((max * 3) >> 2);\n\n  // Collect by 6*4 bits (3 bytes)\n\n  var bits = 0;\n  var ptr  = 0;\n\n  for (var idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      out[ptr++] = (bits >> 16) & 0xFF;\n      out[ptr++] = (bits >> 8) & 0xFF;\n      out[ptr++] = bits & 0xFF;\n    }\n\n    bits = (bits << 6) | BASE64_MAP.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  var tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    out[ptr++] = (bits >> 16) & 0xFF;\n    out[ptr++] = (bits >> 8) & 0xFF;\n    out[ptr++] = bits & 0xFF;\n  } else if (tailbits === 18) {\n    out[ptr++] = (bits >> 10) & 0xFF;\n    out[ptr++] = (bits >> 2) & 0xFF;\n  } else if (tailbits === 12) {\n    out[ptr++] = (bits >> 4) & 0xFF;\n  }\n\n  return out;\n};\n\n},{}],21:[function(_dereq_,module,exports){\n// Detect WebAssembly support.\n// - Check global WebAssembly object\n// - Try to load simple module (can be disabled via CSP)\n//\n'use strict';\n\n\nvar wa;\n\n\nmodule.exports = function hasWebAssembly() {\n  // use cache if called before;\n  if (typeof wa !== 'undefined') return wa;\n\n  wa = false;\n\n  if (typeof WebAssembly === 'undefined') return wa;\n\n  // If WebAssenbly is disabled, code can throw on compile\n  try {\n    // https://github.com/brion/min-wasm-fail/blob/master/min-wasm-fail.in.js\n    // Additional check that WA internals are correct\n\n    /* eslint-disable comma-spacing, max-len */\n    var bin      = new Uint8Array([ 0,97,115,109,1,0,0,0,1,6,1,96,1,127,1,127,3,2,1,0,5,3,1,0,1,7,8,1,4,116,101,115,116,0,0,10,16,1,14,0,32,0,65,1,54,2,0,32,0,40,2,0,11 ]);\n    var module   = new WebAssembly.Module(bin);\n    var instance = new WebAssembly.Instance(module, {});\n\n    // test storing to and loading from a non-zero location via a parameter.\n    // Safari on iOS 11.2.5 returns 0 unexpectedly at non-zero locations\n    if (instance.exports.test(4) !== 0) wa = true;\n\n    return wa;\n  } catch (__) {}\n\n  return wa;\n};\n\n},{}],22:[function(_dereq_,module,exports){\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n},{}],23:[function(_dereq_,module,exports){\nvar bundleFn = arguments[3];\nvar sources = arguments[4];\nvar cache = arguments[5];\n\nvar stringify = JSON.stringify;\n\nmodule.exports = function (fn, options) {\n    var wkey;\n    var cacheKeys = Object.keys(cache);\n\n    for (var i = 0, l = cacheKeys.length; i < l; i++) {\n        var key = cacheKeys[i];\n        var exp = cache[key].exports;\n        // Using babel as a transpiler to use esmodule, the export will always\n        // be an object with the default export as a property of it. To ensure\n        // the existing api and babel esmodule exports are both supported we\n        // check for both\n        if (exp === fn || exp && exp.default === fn) {\n            wkey = key;\n            break;\n        }\n    }\n\n    if (!wkey) {\n        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n        var wcache = {};\n        for (var i = 0, l = cacheKeys.length; i < l; i++) {\n            var key = cacheKeys[i];\n            wcache[key] = key;\n        }\n        sources[wkey] = [\n            'function(require,module,exports){' + fn + '(self); }',\n            wcache\n        ];\n    }\n    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n\n    var scache = {}; scache[wkey] = wkey;\n    sources[skey] = [\n        'function(require,module,exports){' +\n            // try to call default if defined to also support babel esmodule exports\n            'var f = require(' + stringify(wkey) + ');' +\n            '(f.default ? f.default : f)(self);' +\n        '}',\n        scache\n    ];\n\n    var workerSources = {};\n    resolveSources(skey);\n\n    function resolveSources(key) {\n        workerSources[key] = true;\n\n        for (var depPath in sources[key][1]) {\n            var depKey = sources[key][1][depPath];\n            if (!workerSources[depKey]) {\n                resolveSources(depKey);\n            }\n        }\n    }\n\n    var src = '(' + bundleFn + ')({'\n        + Object.keys(workerSources).map(function (key) {\n            return stringify(key) + ':['\n                + sources[key][0]\n                + ',' + stringify(sources[key][1]) + ']'\n            ;\n        }).join(',')\n        + '},{},[' + stringify(skey) + '])'\n    ;\n\n    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n    var blob = new Blob([src], { type: 'text/javascript' });\n    if (options && options.bare) { return blob; }\n    var workerUrl = URL.createObjectURL(blob);\n    var worker = new Worker(workerUrl);\n    worker.objectURL = workerUrl;\n    return worker;\n};\n\n},{}],\"/index.js\":[function(_dereq_,module,exports){\n'use strict';\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar assign = _dereq_('object-assign');\n\nvar webworkify = _dereq_('webworkify');\n\nvar MathLib = _dereq_('./lib/mathlib');\n\nvar Pool = _dereq_('./lib/pool');\n\nvar utils = _dereq_('./lib/utils');\n\nvar worker = _dereq_('./lib/worker');\n\nvar createStages = _dereq_('./lib/stepper');\n\nvar createRegions = _dereq_('./lib/tiler');\n\nvar filter_info = _dereq_('./lib/mm_resize/resize_filter_info'); // Deduplicate pools & limiters with the same configs\n// when user creates multiple pica instances.\n\n\nvar singletones = {};\nvar NEED_SAFARI_FIX = false;\n\ntry {\n  if (typeof navigator !== 'undefined' && navigator.userAgent) {\n    NEED_SAFARI_FIX = navigator.userAgent.indexOf('Safari') >= 0;\n  }\n} catch (e) {}\n\nvar concurrency = 1;\n\nif (typeof navigator !== 'undefined') {\n  concurrency = Math.min(navigator.hardwareConcurrency || 1, 4);\n}\n\nvar DEFAULT_PICA_OPTS = {\n  tile: 1024,\n  concurrency: concurrency,\n  features: ['js', 'wasm', 'ww'],\n  idle: 2000,\n  createCanvas: function createCanvas(width, height) {\n    var tmpCanvas = document.createElement('canvas');\n    tmpCanvas.width = width;\n    tmpCanvas.height = height;\n    return tmpCanvas;\n  }\n};\nvar DEFAULT_RESIZE_OPTS = {\n  filter: 'mks2013',\n  unsharpAmount: 0,\n  unsharpRadius: 0.0,\n  unsharpThreshold: 0\n};\nvar CAN_NEW_IMAGE_DATA = false;\nvar CAN_CREATE_IMAGE_BITMAP = false;\nvar CAN_USE_CANVAS_GET_IMAGE_DATA = false;\nvar CAN_USE_OFFSCREEN_CANVAS = false;\nvar CAN_USE_CIB_REGION_FOR_IMAGE = false;\n\nfunction workerFabric() {\n  return {\n    value: webworkify(worker),\n    destroy: function destroy() {\n      this.value.terminate();\n\n      if (typeof window !== 'undefined') {\n        var url = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n        if (url && url.revokeObjectURL && this.value.objectURL) {\n          url.revokeObjectURL(this.value.objectURL);\n        }\n      }\n    }\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n// API methods\n\n\nfunction Pica(options) {\n  if (!(this instanceof Pica)) return new Pica(options);\n  this.options = assign({}, DEFAULT_PICA_OPTS, options || {});\n  var limiter_key = \"lk_\".concat(this.options.concurrency); // Share limiters to avoid multiple parallel workers when user creates\n  // multiple pica instances.\n\n  this.__limit = singletones[limiter_key] || utils.limiter(this.options.concurrency);\n  if (!singletones[limiter_key]) singletones[limiter_key] = this.__limit; // List of supported features, according to options & browser/node.js\n\n  this.features = {\n    js: false,\n    // pure JS implementation, can be disabled for testing\n    wasm: false,\n    // webassembly implementation for heavy functions\n    cib: false,\n    // resize via createImageBitmap (only FF at this moment)\n    ww: false // webworkers\n\n  };\n  this.__workersPool = null; // Store requested features for webworkers\n\n  this.__requested_features = [];\n  this.__mathlib = null;\n}\n\nPica.prototype.init = function () {\n  var _this = this;\n\n  if (this.__initPromise) return this.__initPromise; // Test if we can create ImageData without canvas and memory copy\n\n  if (typeof ImageData !== 'undefined' && typeof Uint8ClampedArray !== 'undefined') {\n    try {\n      /* eslint-disable no-new */\n      new ImageData(new Uint8ClampedArray(400), 10, 10);\n      CAN_NEW_IMAGE_DATA = true;\n    } catch (__) {}\n  } // ImageBitmap can be effective in 2 places:\n  //\n  // 1. Threaded jpeg unpack (basic)\n  // 2. Built-in resize (blocked due problem in chrome, see issue #89)\n  //\n  // For basic use we also need ImageBitmap wo support .close() method,\n  // see https://developer.mozilla.org/ru/docs/Web/API/ImageBitmap\n\n\n  if (typeof ImageBitmap !== 'undefined') {\n    if (ImageBitmap.prototype && ImageBitmap.prototype.close) {\n      CAN_CREATE_IMAGE_BITMAP = true;\n    } else {\n      this.debug('ImageBitmap does not support .close(), disabled');\n    }\n  }\n\n  var features = this.options.features.slice();\n\n  if (features.indexOf('all') >= 0) {\n    features = ['cib', 'wasm', 'js', 'ww'];\n  }\n\n  this.__requested_features = features;\n  this.__mathlib = new MathLib(features); // Check WebWorker support if requested\n\n  if (features.indexOf('ww') >= 0) {\n    if (typeof window !== 'undefined' && 'Worker' in window) {\n      // IE <= 11 don't allow to create webworkers from string. We should check it.\n      // https://connect.microsoft.com/IE/feedback/details/801810/web-workers-from-blob-urls-in-ie-10-and-11\n      try {\n        var wkr = _dereq_('webworkify')(function () {});\n\n        wkr.terminate();\n        this.features.ww = true; // pool uniqueness depends on pool config + webworker config\n\n        var wpool_key = \"wp_\".concat(JSON.stringify(this.options));\n\n        if (singletones[wpool_key]) {\n          this.__workersPool = singletones[wpool_key];\n        } else {\n          this.__workersPool = new Pool(workerFabric, this.options.idle);\n          singletones[wpool_key] = this.__workersPool;\n        }\n      } catch (__) {}\n    }\n  }\n\n  var initMath = this.__mathlib.init().then(function (mathlib) {\n    // Copy detected features\n    assign(_this.features, mathlib.features);\n  });\n\n  var checkCibResize;\n\n  if (!CAN_CREATE_IMAGE_BITMAP) {\n    checkCibResize = Promise.resolve(false);\n  } else {\n    checkCibResize = utils.cib_support(this.options.createCanvas).then(function (status) {\n      if (_this.features.cib && features.indexOf('cib') < 0) {\n        _this.debug('createImageBitmap() resize supported, but disabled by config');\n\n        return;\n      }\n\n      if (features.indexOf('cib') >= 0) _this.features.cib = status;\n    });\n  }\n\n  CAN_USE_CANVAS_GET_IMAGE_DATA = utils.can_use_canvas(this.options.createCanvas);\n  var checkOffscreenCanvas;\n\n  if (CAN_CREATE_IMAGE_BITMAP && CAN_NEW_IMAGE_DATA && features.indexOf('ww') !== -1) {\n    checkOffscreenCanvas = utils.worker_offscreen_canvas_support();\n  } else {\n    checkOffscreenCanvas = Promise.resolve(false);\n  }\n\n  checkOffscreenCanvas = checkOffscreenCanvas.then(function (result) {\n    CAN_USE_OFFSCREEN_CANVAS = result;\n  }); // we use createImageBitmap to crop image data and pass it to workers,\n  // so need to check whether function works correctly;\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1220671\n\n  var checkCibRegion = utils.cib_can_use_region().then(function (result) {\n    CAN_USE_CIB_REGION_FOR_IMAGE = result;\n  }); // Init math lib. That's async because can load some\n\n  this.__initPromise = Promise.all([initMath, checkCibResize, checkOffscreenCanvas, checkCibRegion]).then(function () {\n    return _this;\n  });\n  return this.__initPromise;\n}; // Call resizer in webworker or locally, depending on config\n\n\nPica.prototype.__invokeResize = function (tileOpts, opts) {\n  var _this2 = this;\n\n  // Share cache between calls:\n  //\n  // - wasm instance\n  // - wasm memory object\n  //\n  opts.__mathCache = opts.__mathCache || {};\n  return Promise.resolve().then(function () {\n    if (!_this2.features.ww) {\n      // not possible to have ImageBitmap here if user disabled WW\n      return {\n        data: _this2.__mathlib.resizeAndUnsharp(tileOpts, opts.__mathCache)\n      };\n    }\n\n    return new Promise(function (resolve, reject) {\n      var w = _this2.__workersPool.acquire();\n\n      if (opts.cancelToken) opts.cancelToken[\"catch\"](function (err) {\n        return reject(err);\n      });\n\n      w.value.onmessage = function (ev) {\n        w.release();\n        if (ev.data.err) reject(ev.data.err);else resolve(ev.data);\n      };\n\n      var transfer = [];\n      if (tileOpts.src) transfer.push(tileOpts.src.buffer);\n      if (tileOpts.srcBitmap) transfer.push(tileOpts.srcBitmap);\n      w.value.postMessage({\n        opts: tileOpts,\n        features: _this2.__requested_features,\n        preload: {\n          wasm_nodule: _this2.__mathlib.__\n        }\n      }, transfer);\n    });\n  });\n}; // this function can return promise if createImageBitmap is used\n\n\nPica.prototype.__extractTileData = function (tile, from, opts, stageEnv, extractTo) {\n  if (this.features.ww && CAN_USE_OFFSCREEN_CANVAS && ( // createImageBitmap doesn't work for images (Image, ImageBitmap) with Exif orientation in Chrome,\n  // can use canvas because canvas doesn't have orientation;\n  // see https://bugs.chromium.org/p/chromium/issues/detail?id=1220671\n  utils.isCanvas(from) || CAN_USE_CIB_REGION_FOR_IMAGE)) {\n    this.debug('Create tile for OffscreenCanvas');\n    return createImageBitmap(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height).then(function (bitmap) {\n      extractTo.srcBitmap = bitmap;\n      return extractTo;\n    });\n  } // Extract tile RGBA buffer, depending on input type\n\n\n  if (utils.isCanvas(from)) {\n    if (!stageEnv.srcCtx) stageEnv.srcCtx = from.getContext('2d'); // If input is Canvas - extract region data directly\n\n    this.debug('Get tile pixel data');\n    extractTo.src = stageEnv.srcCtx.getImageData(tile.x, tile.y, tile.width, tile.height).data;\n    return extractTo;\n  } // If input is Image or decoded to ImageBitmap,\n  // draw region to temporary canvas and extract data from it\n  //\n  // Note! Attempt to reuse this canvas causes significant slowdown in chrome\n  //\n\n\n  this.debug('Draw tile imageBitmap/image to temporary canvas');\n  var tmpCanvas = this.options.createCanvas(tile.width, tile.height);\n  var tmpCtx = tmpCanvas.getContext('2d');\n  tmpCtx.globalCompositeOperation = 'copy';\n  tmpCtx.drawImage(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height, 0, 0, tile.width, tile.height);\n  this.debug('Get tile pixel data');\n  extractTo.src = tmpCtx.getImageData(0, 0, tile.width, tile.height).data; // Safari 12 workaround\n  // https://github.com/nodeca/pica/issues/199\n\n  tmpCanvas.width = tmpCanvas.height = 0;\n  return extractTo;\n};\n\nPica.prototype.__landTileData = function (tile, result, stageEnv) {\n  var toImageData;\n  this.debug('Convert raw rgba tile result to ImageData');\n\n  if (result.bitmap) {\n    stageEnv.toCtx.drawImage(result.bitmap, tile.toX, tile.toY);\n    return null;\n  }\n\n  if (CAN_NEW_IMAGE_DATA) {\n    // this branch is for modern browsers\n    // If `new ImageData()` & Uint8ClampedArray suported\n    toImageData = new ImageData(new Uint8ClampedArray(result.data), tile.toWidth, tile.toHeight);\n  } else {\n    // fallback for `node-canvas` and old browsers\n    // (IE11 has ImageData but does not support `new ImageData()`)\n    toImageData = stageEnv.toCtx.createImageData(tile.toWidth, tile.toHeight);\n\n    if (toImageData.data.set) {\n      toImageData.data.set(result.data);\n    } else {\n      // IE9 don't have `.set()`\n      for (var i = toImageData.data.length - 1; i >= 0; i--) {\n        toImageData.data[i] = result.data[i];\n      }\n    }\n  }\n\n  this.debug('Draw tile');\n\n  if (NEED_SAFARI_FIX) {\n    // Safari draws thin white stripes between tiles without this fix\n    stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth + 1e-5, tile.toInnerHeight + 1e-5);\n  } else {\n    stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth, tile.toInnerHeight);\n  }\n\n  return null;\n};\n\nPica.prototype.__tileAndResize = function (from, to, opts) {\n  var _this3 = this;\n\n  var stageEnv = {\n    srcCtx: null,\n    srcImageBitmap: null,\n    isImageBitmapReused: false,\n    toCtx: null\n  };\n\n  var processTile = function processTile(tile) {\n    return _this3.__limit(function () {\n      if (opts.canceled) return opts.cancelToken;\n      var tileOpts = {\n        width: tile.width,\n        height: tile.height,\n        toWidth: tile.toWidth,\n        toHeight: tile.toHeight,\n        scaleX: tile.scaleX,\n        scaleY: tile.scaleY,\n        offsetX: tile.offsetX,\n        offsetY: tile.offsetY,\n        filter: opts.filter,\n        unsharpAmount: opts.unsharpAmount,\n        unsharpRadius: opts.unsharpRadius,\n        unsharpThreshold: opts.unsharpThreshold\n      };\n\n      _this3.debug('Invoke resize math');\n\n      return Promise.resolve(tileOpts).then(function (tileOpts) {\n        return _this3.__extractTileData(tile, from, opts, stageEnv, tileOpts);\n      }).then(function (tileOpts) {\n        _this3.debug('Invoke resize math');\n\n        return _this3.__invokeResize(tileOpts, opts);\n      }).then(function (result) {\n        if (opts.canceled) return opts.cancelToken;\n        stageEnv.srcImageData = null;\n        return _this3.__landTileData(tile, result, stageEnv);\n      });\n    });\n  }; // Need to normalize data source first. It can be canvas or image.\n  // If image - try to decode in background if possible\n\n\n  return Promise.resolve().then(function () {\n    stageEnv.toCtx = to.getContext('2d');\n    if (utils.isCanvas(from)) return null;\n\n    if (utils.isImageBitmap(from)) {\n      stageEnv.srcImageBitmap = from;\n      stageEnv.isImageBitmapReused = true;\n      return null;\n    }\n\n    if (utils.isImage(from)) {\n      // try do decode image in background for faster next operations;\n      // if we're using offscreen canvas, cib is called per tile, so not needed here\n      if (!CAN_CREATE_IMAGE_BITMAP) return null;\n\n      _this3.debug('Decode image via createImageBitmap');\n\n      return createImageBitmap(from).then(function (imageBitmap) {\n        stageEnv.srcImageBitmap = imageBitmap;\n      }) // Suppress error to use fallback, if method fails\n      // https://github.com/nodeca/pica/issues/190\n\n      /* eslint-disable no-unused-vars */\n      [\"catch\"](function (e) {\n        return null;\n      });\n    }\n\n    throw new Error('Pica: \".from\" should be Image, Canvas or ImageBitmap');\n  }).then(function () {\n    if (opts.canceled) return opts.cancelToken;\n\n    _this3.debug('Calculate tiles'); //\n    // Here we are with \"normalized\" source,\n    // follow to tiling\n    //\n\n\n    var regions = createRegions({\n      width: opts.width,\n      height: opts.height,\n      srcTileSize: _this3.options.tile,\n      toWidth: opts.toWidth,\n      toHeight: opts.toHeight,\n      destTileBorder: opts.__destTileBorder\n    });\n    var jobs = regions.map(function (tile) {\n      return processTile(tile);\n    });\n\n    function cleanup(stageEnv) {\n      if (stageEnv.srcImageBitmap) {\n        if (!stageEnv.isImageBitmapReused) stageEnv.srcImageBitmap.close();\n        stageEnv.srcImageBitmap = null;\n      }\n    }\n\n    _this3.debug('Process tiles');\n\n    return Promise.all(jobs).then(function () {\n      _this3.debug('Finished!');\n\n      cleanup(stageEnv);\n      return to;\n    }, function (err) {\n      cleanup(stageEnv);\n      throw err;\n    });\n  });\n};\n\nPica.prototype.__processStages = function (stages, from, to, opts) {\n  var _this4 = this;\n\n  if (opts.canceled) return opts.cancelToken;\n\n  var _stages$shift = stages.shift(),\n      _stages$shift2 = _slicedToArray(_stages$shift, 2),\n      toWidth = _stages$shift2[0],\n      toHeight = _stages$shift2[1];\n\n  var isLastStage = stages.length === 0; // Optimization for legacy filters -\n  // only use user-defined quality for the last stage,\n  // use simpler (Hamming) filter for the first stages where\n  // scale factor is large enough (more than 2-3)\n  //\n  // For advanced filters (mks2013 and custom) - skip optimization,\n  // because need to apply sharpening every time\n\n  var filter;\n  if (isLastStage || filter_info.q2f.indexOf(opts.filter) < 0) filter = opts.filter;else if (opts.filter === 'box') filter = 'box';else filter = 'hamming';\n  opts = assign({}, opts, {\n    toWidth: toWidth,\n    toHeight: toHeight,\n    filter: filter\n  });\n  var tmpCanvas;\n\n  if (!isLastStage) {\n    // create temporary canvas\n    tmpCanvas = this.options.createCanvas(toWidth, toHeight);\n  }\n\n  return this.__tileAndResize(from, isLastStage ? to : tmpCanvas, opts).then(function () {\n    if (isLastStage) return to;\n    opts.width = toWidth;\n    opts.height = toHeight;\n    return _this4.__processStages(stages, tmpCanvas, to, opts);\n  }).then(function (res) {\n    if (tmpCanvas) {\n      // Safari 12 workaround\n      // https://github.com/nodeca/pica/issues/199\n      tmpCanvas.width = tmpCanvas.height = 0;\n    }\n\n    return res;\n  });\n};\n\nPica.prototype.__resizeViaCreateImageBitmap = function (from, to, opts) {\n  var _this5 = this;\n\n  var toCtx = to.getContext('2d');\n  this.debug('Resize via createImageBitmap()');\n  return createImageBitmap(from, {\n    resizeWidth: opts.toWidth,\n    resizeHeight: opts.toHeight,\n    resizeQuality: utils.cib_quality_name(filter_info.f2q[opts.filter])\n  }).then(function (imageBitmap) {\n    if (opts.canceled) return opts.cancelToken; // if no unsharp - draw directly to output canvas\n\n    if (!opts.unsharpAmount) {\n      toCtx.drawImage(imageBitmap, 0, 0);\n      imageBitmap.close();\n      toCtx = null;\n\n      _this5.debug('Finished!');\n\n      return to;\n    }\n\n    _this5.debug('Unsharp result');\n\n    var tmpCanvas = _this5.options.createCanvas(opts.toWidth, opts.toHeight);\n\n    var tmpCtx = tmpCanvas.getContext('2d');\n    tmpCtx.drawImage(imageBitmap, 0, 0);\n    imageBitmap.close();\n    var iData = tmpCtx.getImageData(0, 0, opts.toWidth, opts.toHeight);\n\n    _this5.__mathlib.unsharp_mask(iData.data, opts.toWidth, opts.toHeight, opts.unsharpAmount, opts.unsharpRadius, opts.unsharpThreshold);\n\n    toCtx.putImageData(iData, 0, 0); // Safari 12 workaround\n    // https://github.com/nodeca/pica/issues/199\n\n    tmpCanvas.width = tmpCanvas.height = 0;\n    iData = tmpCtx = tmpCanvas = toCtx = null;\n\n    _this5.debug('Finished!');\n\n    return to;\n  });\n};\n\nPica.prototype.resize = function (from, to, options) {\n  var _this6 = this;\n\n  this.debug('Start resize...');\n  var opts = assign({}, DEFAULT_RESIZE_OPTS);\n\n  if (!isNaN(options)) {\n    opts = assign(opts, {\n      quality: options\n    });\n  } else if (options) {\n    opts = assign(opts, options);\n  }\n\n  opts.toWidth = to.width;\n  opts.toHeight = to.height;\n  opts.width = from.naturalWidth || from.width;\n  opts.height = from.naturalHeight || from.height; // Legacy `.quality` option\n\n  if (Object.prototype.hasOwnProperty.call(opts, 'quality')) {\n    if (opts.quality < 0 || opts.quality > 3) {\n      throw new Error(\"Pica: .quality should be [0..3], got \".concat(opts.quality));\n    }\n\n    opts.filter = filter_info.q2f[opts.quality];\n  } // Prevent stepper from infinite loop\n\n\n  if (to.width === 0 || to.height === 0) {\n    return Promise.reject(new Error(\"Invalid output size: \".concat(to.width, \"x\").concat(to.height)));\n  }\n\n  if (opts.unsharpRadius > 2) opts.unsharpRadius = 2;\n  opts.canceled = false;\n\n  if (opts.cancelToken) {\n    // Wrap cancelToken to avoid successive resolve & set flag\n    opts.cancelToken = opts.cancelToken.then(function (data) {\n      opts.canceled = true;\n      throw data;\n    }, function (err) {\n      opts.canceled = true;\n      throw err;\n    });\n  }\n\n  var DEST_TILE_BORDER = 3; // Max possible filter window size\n\n  opts.__destTileBorder = Math.ceil(Math.max(DEST_TILE_BORDER, 2.5 * opts.unsharpRadius | 0));\n  return this.init().then(function () {\n    if (opts.canceled) return opts.cancelToken; // if createImageBitmap supports resize, just do it and return\n\n    if (_this6.features.cib) {\n      if (filter_info.q2f.indexOf(opts.filter) >= 0) {\n        return _this6.__resizeViaCreateImageBitmap(from, to, opts);\n      }\n\n      _this6.debug('cib is enabled, but not supports provided filter, fallback to manual math');\n    }\n\n    if (!CAN_USE_CANVAS_GET_IMAGE_DATA) {\n      var err = new Error('Pica: cannot use getImageData on canvas, ' + \"make sure fingerprinting protection isn't enabled\");\n      err.code = 'ERR_GET_IMAGE_DATA';\n      throw err;\n    } //\n    // No easy way, let's resize manually via arrays\n    //\n\n\n    var stages = createStages(opts.width, opts.height, opts.toWidth, opts.toHeight, _this6.options.tile, opts.__destTileBorder);\n    return _this6.__processStages(stages, from, to, opts);\n  });\n}; // RGBA buffer resize\n//\n\n\nPica.prototype.resizeBuffer = function (options) {\n  var _this7 = this;\n\n  var opts = assign({}, DEFAULT_RESIZE_OPTS, options); // Legacy `.quality` option\n\n  if (Object.prototype.hasOwnProperty.call(opts, 'quality')) {\n    if (opts.quality < 0 || opts.quality > 3) {\n      throw new Error(\"Pica: .quality should be [0..3], got \".concat(opts.quality));\n    }\n\n    opts.filter = filter_info.q2f[opts.quality];\n  }\n\n  return this.init().then(function () {\n    return _this7.__mathlib.resizeAndUnsharp(opts);\n  });\n};\n\nPica.prototype.toBlob = function (canvas, mimeType, quality) {\n  mimeType = mimeType || 'image/png';\n  return new Promise(function (resolve) {\n    if (canvas.toBlob) {\n      canvas.toBlob(function (blob) {\n        return resolve(blob);\n      }, mimeType, quality);\n      return;\n    }\n\n    if (canvas.convertToBlob) {\n      resolve(canvas.convertToBlob({\n        type: mimeType,\n        quality: quality\n      }));\n      return;\n    } // Fallback for old browsers\n\n\n    var asString = atob(canvas.toDataURL(mimeType, quality).split(',')[1]);\n    var len = asString.length;\n    var asBuffer = new Uint8Array(len);\n\n    for (var i = 0; i < len; i++) {\n      asBuffer[i] = asString.charCodeAt(i);\n    }\n\n    resolve(new Blob([asBuffer], {\n      type: mimeType\n    }));\n  });\n};\n\nPica.prototype.debug = function () {};\n\nmodule.exports = Pica;\n\n},{\"./lib/mathlib\":1,\"./lib/mm_resize/resize_filter_info\":7,\"./lib/pool\":13,\"./lib/stepper\":14,\"./lib/tiler\":15,\"./lib/utils\":16,\"./lib/worker\":17,\"object-assign\":22,\"webworkify\":23}]},{},[])(\"/index.js\")\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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b3VyY2VzQ29udGVudCI6WyIvKiFcblxucGljYVxuaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9waWNhXG5cbiovXG5cbihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLnBpY2EgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvbGxlY3Rpb24gb2YgbWF0aCBmdW5jdGlvbnNcbi8vXG4vLyAxLiBDb21iaW5lIGNvbXBvbmVudHMgdG9nZXRoZXJcbi8vIDIuIEhhcyBhc3luYyBpbml0IHRvIGxvYWQgd2FzbSBtb2R1bGVzXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTXVsdGltYXRoID0gX2RlcmVxXygnbXVsdGltYXRoJyk7XG5cbnZhciBtbV91bnNoYXJwX21hc2sgPSBfZGVyZXFfKCcuL21tX3Vuc2hhcnBfbWFzaycpO1xuXG52YXIgbW1fcmVzaXplID0gX2RlcmVxXygnLi9tbV9yZXNpemUnKTtcblxuZnVuY3Rpb24gTWF0aExpYihyZXF1ZXN0ZWRfZmVhdHVyZXMpIHtcbiAgdmFyIF9fcmVxdWVzdGVkX2ZlYXR1cmVzID0gcmVxdWVzdGVkX2ZlYXR1cmVzIHx8IFtdO1xuXG4gIHZhciBmZWF0dXJlcyA9IHtcbiAgICBqczogX19yZXF1ZXN0ZWRfZmVhdHVyZXMuaW5kZXhPZignanMnKSA+PSAwLFxuICAgIHdhc206IF9fcmVxdWVzdGVkX2ZlYXR1cmVzLmluZGV4T2YoJ3dhc20nKSA+PSAwXG4gIH07XG4gIE11bHRpbWF0aC5jYWxsKHRoaXMsIGZlYXR1cmVzKTtcbiAgdGhpcy5mZWF0dXJlcyA9IHtcbiAgICBqczogZmVhdHVyZXMuanMsXG4gICAgd2FzbTogZmVhdHVyZXMud2FzbSAmJiB0aGlzLmhhc193YXNtKClcbiAgfTtcbiAgdGhpcy51c2UobW1fdW5zaGFycF9tYXNrKTtcbiAgdGhpcy51c2UobW1fcmVzaXplKTtcbn1cblxuTWF0aExpYi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE11bHRpbWF0aC5wcm90b3R5cGUpO1xuTWF0aExpYi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXRoTGliO1xuXG5NYXRoTGliLnByb3RvdHlwZS5yZXNpemVBbmRVbnNoYXJwID0gZnVuY3Rpb24gcmVzaXplQW5kVW5zaGFycChvcHRpb25zLCBjYWNoZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5yZXNpemUob3B0aW9ucywgY2FjaGUpO1xuXG4gIGlmIChvcHRpb25zLnVuc2hhcnBBbW91bnQpIHtcbiAgICB0aGlzLnVuc2hhcnBfbWFzayhyZXN1bHQsIG9wdGlvbnMudG9XaWR0aCwgb3B0aW9ucy50b0hlaWdodCwgb3B0aW9ucy51bnNoYXJwQW1vdW50LCBvcHRpb25zLnVuc2hhcnBSYWRpdXMsIG9wdGlvbnMudW5zaGFycFRocmVzaG9sZCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXRoTGliO1xuXG59LHtcIi4vbW1fcmVzaXplXCI6NCxcIi4vbW1fdW5zaGFycF9tYXNrXCI6OSxcIm11bHRpbWF0aFwiOjE5fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBSZXNpemUgY29udm9sdmVycywgcHVyZSBKUyBpbXBsZW1lbnRhdGlvblxuLy9cbid1c2Ugc3RyaWN0JzsgLy8gUHJlY2lzaW9uIG9mIGZpeGVkIEZQIHZhbHVlc1xuLy92YXIgRklYRURfRlJBQ19CSVRTID0gMTQ7XG5cbmZ1bmN0aW9uIGNsYW1wVG84KGkpIHtcbiAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAyNTUgPyAyNTUgOiBpO1xufVxuXG5mdW5jdGlvbiBjbGFtcE5lZ2F0aXZlKGkpIHtcbiAgcmV0dXJuIGkgPj0gMCA/IGkgOiAwO1xufSAvLyBDb252b2x2ZSBpbWFnZSBkYXRhIGluIGhvcml6b250YWwgZGlyZWN0aW9uLiBDYW4gYmUgdXNlZCBmb3I6XG4vL1xuLy8gMS4gYml0bWFwIHdpdGggcHJlbXVsdGlwbGllZCBhbHBoYVxuLy8gMi4gYml0bWFwIHdpdGhvdXQgYWxwaGEgKGFsbCB2YWx1ZXMgMjU1KVxuLy9cbi8vIE5vdGVzOlxuLy9cbi8vIC0gb3V0cHV0IGlzIHRyYW5zcG9zZWRcbi8vIC0gb3V0cHV0IHJlc29sdXRpb24gaXMgfjE1IGJpdHMgcGVyIGNoYW5uZWwoZm9yIGJldHRlciBwcmVjaXNpb24pLlxuLy9cblxuXG5mdW5jdGlvbiBjb252b2x2ZUhvcihzcmMsIGRlc3QsIHNyY1csIHNyY0gsIGRlc3RXLCBmaWx0ZXJzKSB7XG4gIHZhciByLCBnLCBiLCBhO1xuICB2YXIgZmlsdGVyUHRyLCBmaWx0ZXJTaGlmdCwgZmlsdGVyU2l6ZTtcbiAgdmFyIHNyY1B0ciwgc3JjWSwgZGVzdFgsIGZpbHRlclZhbDtcbiAgdmFyIHNyY09mZnNldCA9IDAsXG4gICAgICBkZXN0T2Zmc2V0ID0gMDsgLy8gRm9yIGVhY2ggcm93XG5cbiAgZm9yIChzcmNZID0gMDsgc3JjWSA8IHNyY0g7IHNyY1krKykge1xuICAgIGZpbHRlclB0ciA9IDA7IC8vIEFwcGx5IHByZWNvbXB1dGVkIGZpbHRlcnMgdG8gZWFjaCBkZXN0aW5hdGlvbiByb3cgcG9pbnRcblxuICAgIGZvciAoZGVzdFggPSAwOyBkZXN0WCA8IGRlc3RXOyBkZXN0WCsrKSB7XG4gICAgICAvLyBHZXQgdGhlIGZpbHRlciB0aGF0IGRldGVybWluZXMgdGhlIGN1cnJlbnQgb3V0cHV0IHBpeGVsLlxuICAgICAgZmlsdGVyU2hpZnQgPSBmaWx0ZXJzW2ZpbHRlclB0cisrXTtcbiAgICAgIGZpbHRlclNpemUgPSBmaWx0ZXJzW2ZpbHRlclB0cisrXTtcbiAgICAgIHNyY1B0ciA9IHNyY09mZnNldCArIGZpbHRlclNoaWZ0ICogNCB8IDA7XG4gICAgICByID0gZyA9IGIgPSBhID0gMDsgLy8gQXBwbHkgdGhlIGZpbHRlciB0byB0aGUgcm93IHRvIGdldCB0aGUgZGVzdGluYXRpb24gcGl4ZWwgciwgZywgYiwgYVxuXG4gICAgICBmb3IgKDsgZmlsdGVyU2l6ZSA+IDA7IGZpbHRlclNpemUtLSkge1xuICAgICAgICBmaWx0ZXJWYWwgPSBmaWx0ZXJzW2ZpbHRlclB0cisrXTsgLy8gVXNlIHJldmVyc2Ugb3JkZXIgdG8gd29ya2Fyb3VuZCBkZW9wdHMgaW4gb2xkIHY4IChub2RlIHYuMTApXG4gICAgICAgIC8vIEJpZyB0aGFua3MgdG8gQG1yYWxlcGggKFZ5YWNoZXNsYXYgRWdvcm92KSBmb3IgdGhlIHRpcC5cblxuICAgICAgICBhID0gYSArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHIgKyAzXSB8IDA7XG4gICAgICAgIGIgPSBiICsgZmlsdGVyVmFsICogc3JjW3NyY1B0ciArIDJdIHwgMDtcbiAgICAgICAgZyA9IGcgKyBmaWx0ZXJWYWwgKiBzcmNbc3JjUHRyICsgMV0gfCAwO1xuICAgICAgICByID0gciArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHJdIHwgMDtcbiAgICAgICAgc3JjUHRyID0gc3JjUHRyICsgNCB8IDA7XG4gICAgICB9IC8vIFN0b3JlIDE1IGJpdHMgYmV0d2VlbiBwYXNzZXMgZm9yIGJldHRlciBwcmVjaXNpb25cbiAgICAgIC8vIEluc3RlYWQgb2Ygc2hpZnQgdG8gMTQgKEZJWEVEX0ZSQUNfQklUUyksIHNoaWZ0IHRvIDcgb25seVxuICAgICAgLy9cblxuXG4gICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAzXSA9IGNsYW1wTmVnYXRpdmUoYSA+PiA3KTtcbiAgICAgIGRlc3RbZGVzdE9mZnNldCArIDJdID0gY2xhbXBOZWdhdGl2ZShiID4+IDcpO1xuICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMV0gPSBjbGFtcE5lZ2F0aXZlKGcgPj4gNyk7XG4gICAgICBkZXN0W2Rlc3RPZmZzZXRdID0gY2xhbXBOZWdhdGl2ZShyID4+IDcpO1xuICAgICAgZGVzdE9mZnNldCA9IGRlc3RPZmZzZXQgKyBzcmNIICogNCB8IDA7XG4gICAgfVxuXG4gICAgZGVzdE9mZnNldCA9IChzcmNZICsgMSkgKiA0IHwgMDtcbiAgICBzcmNPZmZzZXQgPSAoc3JjWSArIDEpICogc3JjVyAqIDQgfCAwO1xuICB9XG59IC8vIFN1cHBsZW1lbnRhcnkgbWV0aG9kIGZvciBgY29udm9sdmVIb3IoKWBcbi8vXG5cblxuZnVuY3Rpb24gY29udm9sdmVWZXJ0KHNyYywgZGVzdCwgc3JjVywgc3JjSCwgZGVzdFcsIGZpbHRlcnMpIHtcbiAgdmFyIHIsIGcsIGIsIGE7XG4gIHZhciBmaWx0ZXJQdHIsIGZpbHRlclNoaWZ0LCBmaWx0ZXJTaXplO1xuICB2YXIgc3JjUHRyLCBzcmNZLCBkZXN0WCwgZmlsdGVyVmFsO1xuICB2YXIgc3JjT2Zmc2V0ID0gMCxcbiAgICAgIGRlc3RPZmZzZXQgPSAwOyAvLyBGb3IgZWFjaCByb3dcblxuICBmb3IgKHNyY1kgPSAwOyBzcmNZIDwgc3JjSDsgc3JjWSsrKSB7XG4gICAgZmlsdGVyUHRyID0gMDsgLy8gQXBwbHkgcHJlY29tcHV0ZWQgZmlsdGVycyB0byBlYWNoIGRlc3RpbmF0aW9uIHJvdyBwb2ludFxuXG4gICAgZm9yIChkZXN0WCA9IDA7IGRlc3RYIDwgZGVzdFc7IGRlc3RYKyspIHtcbiAgICAgIC8vIEdldCB0aGUgZmlsdGVyIHRoYXQgZGV0ZXJtaW5lcyB0aGUgY3VycmVudCBvdXRwdXQgcGl4ZWwuXG4gICAgICBmaWx0ZXJTaGlmdCA9IGZpbHRlcnNbZmlsdGVyUHRyKytdO1xuICAgICAgZmlsdGVyU2l6ZSA9IGZpbHRlcnNbZmlsdGVyUHRyKytdO1xuICAgICAgc3JjUHRyID0gc3JjT2Zmc2V0ICsgZmlsdGVyU2hpZnQgKiA0IHwgMDtcbiAgICAgIHIgPSBnID0gYiA9IGEgPSAwOyAvLyBBcHBseSB0aGUgZmlsdGVyIHRvIHRoZSByb3cgdG8gZ2V0IHRoZSBkZXN0aW5hdGlvbiBwaXhlbCByLCBnLCBiLCBhXG5cbiAgICAgIGZvciAoOyBmaWx0ZXJTaXplID4gMDsgZmlsdGVyU2l6ZS0tKSB7XG4gICAgICAgIGZpbHRlclZhbCA9IGZpbHRlcnNbZmlsdGVyUHRyKytdOyAvLyBVc2UgcmV2ZXJzZSBvcmRlciB0byB3b3JrYXJvdW5kIGRlb3B0cyBpbiBvbGQgdjggKG5vZGUgdi4xMClcbiAgICAgICAgLy8gQmlnIHRoYW5rcyB0byBAbXJhbGVwaCAoVnlhY2hlc2xhdiBFZ29yb3YpIGZvciB0aGUgdGlwLlxuXG4gICAgICAgIGEgPSBhICsgZmlsdGVyVmFsICogc3JjW3NyY1B0ciArIDNdIHwgMDtcbiAgICAgICAgYiA9IGIgKyBmaWx0ZXJWYWwgKiBzcmNbc3JjUHRyICsgMl0gfCAwO1xuICAgICAgICBnID0gZyArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHIgKyAxXSB8IDA7XG4gICAgICAgIHIgPSByICsgZmlsdGVyVmFsICogc3JjW3NyY1B0cl0gfCAwO1xuICAgICAgICBzcmNQdHIgPSBzcmNQdHIgKyA0IHwgMDtcbiAgICAgIH0gLy8gU3luYyB3aXRoIHByZW11bHRpcGxpZWQgdmVyc2lvbiBmb3IgZXhhY3QgcmVzdWx0IG1hdGNoXG5cblxuICAgICAgciA+Pj0gNztcbiAgICAgIGcgPj49IDc7XG4gICAgICBiID4+PSA3O1xuICAgICAgYSA+Pj0gNzsgLy8gQnJpbmcgdGhpcyB2YWx1ZSBiYWNrIGluIHJhbmdlICsgcm91bmQgcmVzdWx0LlxuICAgICAgLy9cblxuICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgM10gPSBjbGFtcFRvOChhICsgKDEgPDwgMTMpID4+IDE0KTtcbiAgICAgIGRlc3RbZGVzdE9mZnNldCArIDJdID0gY2xhbXBUbzgoYiArICgxIDw8IDEzKSA+PiAxNCk7XG4gICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAxXSA9IGNsYW1wVG84KGcgKyAoMSA8PCAxMykgPj4gMTQpO1xuICAgICAgZGVzdFtkZXN0T2Zmc2V0XSA9IGNsYW1wVG84KHIgKyAoMSA8PCAxMykgPj4gMTQpO1xuICAgICAgZGVzdE9mZnNldCA9IGRlc3RPZmZzZXQgKyBzcmNIICogNCB8IDA7XG4gICAgfVxuXG4gICAgZGVzdE9mZnNldCA9IChzcmNZICsgMSkgKiA0IHwgMDtcbiAgICBzcmNPZmZzZXQgPSAoc3JjWSArIDEpICogc3JjVyAqIDQgfCAwO1xuICB9XG59IC8vIFByZW11bHRpcGx5ICYgY29udm9sdmUgaW1hZ2UgZGF0YSBpbiBob3Jpem9udGFsIGRpcmVjdGlvbi4gQ2FuIGJlIHVzZWQgZm9yOlxuLy9cbi8vIC0gQW55IGJpdG1hcCBkYXRhLCBleHRyYWN0ZWQgd2l0aCBgLmdldEltYWdlRGF0YSgpYCBtZXRob2QgKHdpdGhcbi8vICAgbm9uLXByZW11bHRpcGxpZWQgYWxwaGEpXG4vL1xuLy8gRm9yIGltYWdlcyB3aXRob3V0IGFscGhhIGNoYW5uZWwgdGhpcyBtZXRob2QgaXMgc2xvd2VyIHRoYW4gYGNvbnZvbHZlSG9yKClgXG4vL1xuXG5cbmZ1bmN0aW9uIGNvbnZvbHZlSG9yV2l0aFByZShzcmMsIGRlc3QsIHNyY1csIHNyY0gsIGRlc3RXLCBmaWx0ZXJzKSB7XG4gIHZhciByLCBnLCBiLCBhLCBhbHBoYTtcbiAgdmFyIGZpbHRlclB0ciwgZmlsdGVyU2hpZnQsIGZpbHRlclNpemU7XG4gIHZhciBzcmNQdHIsIHNyY1ksIGRlc3RYLCBmaWx0ZXJWYWw7XG4gIHZhciBzcmNPZmZzZXQgPSAwLFxuICAgICAgZGVzdE9mZnNldCA9IDA7IC8vIEZvciBlYWNoIHJvd1xuXG4gIGZvciAoc3JjWSA9IDA7IHNyY1kgPCBzcmNIOyBzcmNZKyspIHtcbiAgICBmaWx0ZXJQdHIgPSAwOyAvLyBBcHBseSBwcmVjb21wdXRlZCBmaWx0ZXJzIHRvIGVhY2ggZGVzdGluYXRpb24gcm93IHBvaW50XG5cbiAgICBmb3IgKGRlc3RYID0gMDsgZGVzdFggPCBkZXN0VzsgZGVzdFgrKykge1xuICAgICAgLy8gR2V0IHRoZSBmaWx0ZXIgdGhhdCBkZXRlcm1pbmVzIHRoZSBjdXJyZW50IG91dHB1dCBwaXhlbC5cbiAgICAgIGZpbHRlclNoaWZ0ID0gZmlsdGVyc1tmaWx0ZXJQdHIrK107XG4gICAgICBmaWx0ZXJTaXplID0gZmlsdGVyc1tmaWx0ZXJQdHIrK107XG4gICAgICBzcmNQdHIgPSBzcmNPZmZzZXQgKyBmaWx0ZXJTaGlmdCAqIDQgfCAwO1xuICAgICAgciA9IGcgPSBiID0gYSA9IDA7IC8vIEFwcGx5IHRoZSBmaWx0ZXIgdG8gdGhlIHJvdyB0byBnZXQgdGhlIGRlc3RpbmF0aW9uIHBpeGVsIHIsIGcsIGIsIGFcblxuICAgICAgZm9yICg7IGZpbHRlclNpemUgPiAwOyBmaWx0ZXJTaXplLS0pIHtcbiAgICAgICAgZmlsdGVyVmFsID0gZmlsdGVyc1tmaWx0ZXJQdHIrK107IC8vIFVzZSByZXZlcnNlIG9yZGVyIHRvIHdvcmthcm91bmQgZGVvcHRzIGluIG9sZCB2OCAobm9kZSB2LjEwKVxuICAgICAgICAvLyBCaWcgdGhhbmtzIHRvIEBtcmFsZXBoIChWeWFjaGVzbGF2IEVnb3JvdikgZm9yIHRoZSB0aXAuXG5cbiAgICAgICAgYWxwaGEgPSBzcmNbc3JjUHRyICsgM107XG4gICAgICAgIGEgPSBhICsgZmlsdGVyVmFsICogYWxwaGEgfCAwO1xuICAgICAgICBiID0gYiArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHIgKyAyXSAqIGFscGhhIHwgMDtcbiAgICAgICAgZyA9IGcgKyBmaWx0ZXJWYWwgKiBzcmNbc3JjUHRyICsgMV0gKiBhbHBoYSB8IDA7XG4gICAgICAgIHIgPSByICsgZmlsdGVyVmFsICogc3JjW3NyY1B0cl0gKiBhbHBoYSB8IDA7XG4gICAgICAgIHNyY1B0ciA9IHNyY1B0ciArIDQgfCAwO1xuICAgICAgfSAvLyBQcmVtdWx0aXBseSBpcyAoKiBhbHBoYSAvIDI1NSkuXG4gICAgICAvLyBQb3N0cG9uZSBkaXZpc2lvbiBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG5cblxuICAgICAgYiA9IGIgLyAyNTUgfCAwO1xuICAgICAgZyA9IGcgLyAyNTUgfCAwO1xuICAgICAgciA9IHIgLyAyNTUgfCAwOyAvLyBTdG9yZSAxNSBiaXRzIGJldHdlZW4gcGFzc2VzIGZvciBiZXR0ZXIgcHJlY2lzaW9uXG4gICAgICAvLyBJbnN0ZWFkIG9mIHNoaWZ0IHRvIDE0IChGSVhFRF9GUkFDX0JJVFMpLCBzaGlmdCB0byA3IG9ubHlcbiAgICAgIC8vXG5cbiAgICAgIGRlc3RbZGVzdE9mZnNldCArIDNdID0gY2xhbXBOZWdhdGl2ZShhID4+IDcpO1xuICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMl0gPSBjbGFtcE5lZ2F0aXZlKGIgPj4gNyk7XG4gICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAxXSA9IGNsYW1wTmVnYXRpdmUoZyA+PiA3KTtcbiAgICAgIGRlc3RbZGVzdE9mZnNldF0gPSBjbGFtcE5lZ2F0aXZlKHIgPj4gNyk7XG4gICAgICBkZXN0T2Zmc2V0ID0gZGVzdE9mZnNldCArIHNyY0ggKiA0IHwgMDtcbiAgICB9XG5cbiAgICBkZXN0T2Zmc2V0ID0gKHNyY1kgKyAxKSAqIDQgfCAwO1xuICAgIHNyY09mZnNldCA9IChzcmNZICsgMSkgKiBzcmNXICogNCB8IDA7XG4gIH1cbn0gLy8gU3VwcGxlbWVudGFyeSBtZXRob2QgZm9yIGBjb252b2x2ZUhvcldpdGhQcmUoKWBcbi8vXG5cblxuZnVuY3Rpb24gY29udm9sdmVWZXJ0V2l0aFByZShzcmMsIGRlc3QsIHNyY1csIHNyY0gsIGRlc3RXLCBmaWx0ZXJzKSB7XG4gIHZhciByLCBnLCBiLCBhO1xuICB2YXIgZmlsdGVyUHRyLCBmaWx0ZXJTaGlmdCwgZmlsdGVyU2l6ZTtcbiAgdmFyIHNyY1B0ciwgc3JjWSwgZGVzdFgsIGZpbHRlclZhbDtcbiAgdmFyIHNyY09mZnNldCA9IDAsXG4gICAgICBkZXN0T2Zmc2V0ID0gMDsgLy8gRm9yIGVhY2ggcm93XG5cbiAgZm9yIChzcmNZID0gMDsgc3JjWSA8IHNyY0g7IHNyY1krKykge1xuICAgIGZpbHRlclB0ciA9IDA7IC8vIEFwcGx5IHByZWNvbXB1dGVkIGZpbHRlcnMgdG8gZWFjaCBkZXN0aW5hdGlvbiByb3cgcG9pbnRcblxuICAgIGZvciAoZGVzdFggPSAwOyBkZXN0WCA8IGRlc3RXOyBkZXN0WCsrKSB7XG4gICAgICAvLyBHZXQgdGhlIGZpbHRlciB0aGF0IGRldGVybWluZXMgdGhlIGN1cnJlbnQgb3V0cHV0IHBpeGVsLlxuICAgICAgZmlsdGVyU2hpZnQgPSBmaWx0ZXJzW2ZpbHRlclB0cisrXTtcbiAgICAgIGZpbHRlclNpemUgPSBmaWx0ZXJzW2ZpbHRlclB0cisrXTtcbiAgICAgIHNyY1B0ciA9IHNyY09mZnNldCArIGZpbHRlclNoaWZ0ICogNCB8IDA7XG4gICAgICByID0gZyA9IGIgPSBhID0gMDsgLy8gQXBwbHkgdGhlIGZpbHRlciB0byB0aGUgcm93IHRvIGdldCB0aGUgZGVzdGluYXRpb24gcGl4ZWwgciwgZywgYiwgYVxuXG4gICAgICBmb3IgKDsgZmlsdGVyU2l6ZSA+IDA7IGZpbHRlclNpemUtLSkge1xuICAgICAgICBmaWx0ZXJWYWwgPSBmaWx0ZXJzW2ZpbHRlclB0cisrXTsgLy8gVXNlIHJldmVyc2Ugb3JkZXIgdG8gd29ya2Fyb3VuZCBkZW9wdHMgaW4gb2xkIHY4IChub2RlIHYuMTApXG4gICAgICAgIC8vIEJpZyB0aGFua3MgdG8gQG1yYWxlcGggKFZ5YWNoZXNsYXYgRWdvcm92KSBmb3IgdGhlIHRpcC5cblxuICAgICAgICBhID0gYSArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHIgKyAzXSB8IDA7XG4gICAgICAgIGIgPSBiICsgZmlsdGVyVmFsICogc3JjW3NyY1B0ciArIDJdIHwgMDtcbiAgICAgICAgZyA9IGcgKyBmaWx0ZXJWYWwgKiBzcmNbc3JjUHRyICsgMV0gfCAwO1xuICAgICAgICByID0gciArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHJdIHwgMDtcbiAgICAgICAgc3JjUHRyID0gc3JjUHRyICsgNCB8IDA7XG4gICAgICB9IC8vIERvd25zY2FsZSB0byBsZWF2ZSByb29tIGZvciB1bi1wcmVtdWx0aXBseVxuXG5cbiAgICAgIHIgPj49IDc7XG4gICAgICBnID4+PSA3O1xuICAgICAgYiA+Pj0gNztcbiAgICAgIGEgPj49IDc7IC8vIFVuLXByZW11bHRpcGx5XG5cbiAgICAgIGEgPSBjbGFtcFRvOChhICsgKDEgPDwgMTMpID4+IDE0KTtcblxuICAgICAgaWYgKGEgPiAwKSB7XG4gICAgICAgIHIgPSByICogMjU1IC8gYSB8IDA7XG4gICAgICAgIGcgPSBnICogMjU1IC8gYSB8IDA7XG4gICAgICAgIGIgPSBiICogMjU1IC8gYSB8IDA7XG4gICAgICB9IC8vIEJyaW5nIHRoaXMgdmFsdWUgYmFjayBpbiByYW5nZSArIHJvdW5kIHJlc3VsdC5cbiAgICAgIC8vIFNoaWZ0IHZhbHVlID0gRklYRURfRlJBQ19CSVRTICsgN1xuICAgICAgLy9cblxuXG4gICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAzXSA9IGE7XG4gICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAyXSA9IGNsYW1wVG84KGIgKyAoMSA8PCAxMykgPj4gMTQpO1xuICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMV0gPSBjbGFtcFRvOChnICsgKDEgPDwgMTMpID4+IDE0KTtcbiAgICAgIGRlc3RbZGVzdE9mZnNldF0gPSBjbGFtcFRvOChyICsgKDEgPDwgMTMpID4+IDE0KTtcbiAgICAgIGRlc3RPZmZzZXQgPSBkZXN0T2Zmc2V0ICsgc3JjSCAqIDQgfCAwO1xuICAgIH1cblxuICAgIGRlc3RPZmZzZXQgPSAoc3JjWSArIDEpICogNCB8IDA7XG4gICAgc3JjT2Zmc2V0ID0gKHNyY1kgKyAxKSAqIHNyY1cgKiA0IHwgMDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29udm9sdmVIb3I6IGNvbnZvbHZlSG9yLFxuICBjb252b2x2ZVZlcnQ6IGNvbnZvbHZlVmVydCxcbiAgY29udm9sdmVIb3JXaXRoUHJlOiBjb252b2x2ZUhvcldpdGhQcmUsXG4gIGNvbnZvbHZlVmVydFdpdGhQcmU6IGNvbnZvbHZlVmVydFdpdGhQcmVcbn07XG5cbn0se31dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gVGhpcyBpcyBhdXRvZ2VuZXJhdGVkIGZpbGUgZnJvbSBtYXRoLndhc20sIGRvbid0IGVkaXQuXG4vL1xuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9ICdBR0Z6YlFFQUFBQUFEQVprZVd4cGJtc0FBQUFBQUFFWUEyQUdmMzkvZjM5L0FHQUFBR0FJZjM5L2YzOS9mMzhBQWc4QkEyVnVkZ1p0WlcxdmNua0NBQUFEQndZQkFBQUFBQUlHQmdGL0FFRUFDd2VVQVFnUlgxOTNZWE50WDJOaGJHeGZZM1J2Y25NQUFBdGpiMjUyYjJ4MlpVaHZjZ0FCREdOdmJuWnZiSFpsVm1WeWRBQUNFbU52Ym5admJIWmxTRzl5VjJsMGFGQnlaUUFERTJOdmJuWnZiSFpsVm1WeWRGZHBkR2hRY21VQUJBcGpiMjUyYjJ4MlpVaFdBQVVNWDE5a2MyOWZhR0Z1Wkd4bEF3QVlYMTkzWVhOdFgyRndjR3g1WDJSaGRHRmZjbVZzYjJOekFBQUt5QTRHQXdBQkM0d0RBUkIvQWtBZ0EwVU5BQ0FFUlEwQUlBTkJBblFoRlFOQVFRQWhFMEVBSVFzRFFDQUxRUUpxSVFjQ2Z5QUxRUUYwSUFWcUlnWXVBUUlpQzBVRVFFRUFJUWhCQUNFR1FRQWhDVUVBSVFvZ0J3d0JDeUFTSUFZdUFRQnFJUWhCQUNFSlFRQWhDaUFMSVJSQkFDRU9JQWNoQmtFQUlROERRQ0FGSUFaQkFYUnFMZ0VBSWhBZ0FDQUlRUUowYWlnQ0FDSVJRUmgyYkNBUGFpRVBJQkZCL3dGeElCQnNJQWxxSVFrZ0VVRVFka0gvQVhFZ0VHd2dEbW9oRGlBUlFRaDJRZjhCY1NBUWJDQUthaUVLSUFoQkFXb2hDQ0FHUVFGcUlRWWdGRUVCYXlJVURRQUxJQWxCQjNVaENDQUtRUWQxSVFZZ0RrRUhkU0VKSUE5QkIzVWhDaUFISUF0cUN5RUxJQUVnREVFQmRDSUhhaUFJUVFBZ0NFRUFTaHM3QVFBZ0FTQUhRUUp5YWlBR1FRQWdCa0VBU2hzN0FRQWdBU0FIUVFSeWFpQUpRUUFnQ1VFQVNoczdBUUFnQVNBSFFRWnlhaUFLUVFBZ0NrRUFTaHM3QVFBZ0RDQVZhaUVNSUJOQkFXb2lFeUFFUncwQUN5QU5RUUZxSWcwZ0Ftd2hFaUFOUVFKMElRd2dBeUFOUncwQUN3c0wyZ01CRDM4Q1FDQURSUTBBSUFSRkRRQWdBa0VDZENFVUEwQWdDeUVNUVFBaEUwRUFJUUlEUUNBQ1FRSnFJUVlDZnlBQ1FRRjBJQVZxSWdjdUFRSWlBa1VFUUVFQUlRaEJBQ0VIUVFBaENrRUFJUWtnQmd3QkN5QUhMZ0VBUVFKMElCSnFJUWhCQUNFSklBSWhDa0VBSVEwZ0JpRUhRUUFoRGtFQUlROERRQ0FGSUFkQkFYUnFMZ0VBSWhBZ0FDQUlRUUYwSWhGcUx3RUFiQ0FKYWlFSklBQWdFVUVHY21vdkFRQWdFR3dnRG1vaERpQUFJQkZCQkhKcUx3RUFJQkJzSUE5cUlROGdBQ0FSUVFKeWFpOEJBQ0FRYkNBTmFpRU5JQWhCQkdvaENDQUhRUUZxSVFjZ0NrRUJheUlLRFFBTElBbEJCM1VoQ0NBTlFRZDFJUWNnRGtFSGRTRUtJQTlCQjNVaENTQUNJQVpxQ3lFQ0lBRWdERUVDZEdvZ0IwR0FRR3RCRG5VaUJrSC9BU0FHUWY4QlNCc2lCa0VBSUFaQkFFb2JRUWgwUVlEK0EzRWdDVUdBUUd0QkRuVWlCa0gvQVNBR1FmOEJTQnNpQmtFQUlBWkJBRW9iUVJCMFFZQ0EvQWR4SUFwQmdFQnJRUTUxSWdaQi93RWdCa0gvQVVnYklnWkJBQ0FHUVFCS0cwRVlkSEp5SUFoQmdFQnJRUTUxSWdaQi93RWdCa0gvQVVnYklnWkJBQ0FHUVFCS0czSTJBZ0FnQXlBTWFpRU1JQk5CQVdvaUV5QUVSdzBBQ3lBVUlBdEJBV29pQzJ3aEVpQURJQXRIRFFBTEN3dVNBd0VRZndKQUlBTkZEUUFnQkVVTkFDQURRUUowSVJVRFFFRUFJUk5CQUNFR0EwQWdCa0VDYWlFSUFuOGdCa0VCZENBRmFpSUdMZ0VDSWdkRkJFQkJBQ0VKUVFBaERFRUFJUTFCQUNFT0lBZ01BUXNnRWlBR0xnRUFhaUVKUVFBaERrRUFJUTFCQUNFTUlBY2hGRUVBSVE4Z0NDRUdBMEFnQlNBR1FRRjBhaTRCQUNBQUlBbEJBblJxS0FJQUloQkJHSFpzSWhFZ0Qyb2hEeUFSSUJCQkVIWkIvd0Z4YkNBTWFpRU1JQkVnRUVFSWRrSC9BWEZzSUExcUlRMGdFU0FRUWY4QmNXd2dEbW9oRGlBSlFRRnFJUWtnQmtFQmFpRUdJQlJCQVdzaUZBMEFDeUFQUVFkMUlRa2dCeUFJYWdzaEJpQUJJQXBCQVhRaUNHb2dEa0gvQVcxQkIzVWlCMEVBSUFkQkFFb2JPd0VBSUFFZ0NFRUNjbW9nRFVIL0FXMUJCM1VpQjBFQUlBZEJBRW9iT3dFQUlBRWdDRUVFY21vZ0RFSC9BVzFCQjNVaUIwRUFJQWRCQUVvYk93RUFJQUVnQ0VFR2Ntb2dDVUVBSUFsQkFFb2JPd0VBSUFvZ0ZXb2hDaUFUUVFGcUloTWdCRWNOQUFzZ0MwRUJhaUlMSUFKc0lSSWdDMEVDZENFS0lBTWdDMGNOQUFzTEM0SUVBUTkvQWtBZ0EwVU5BQ0FFUlEwQUlBSkJBblFoRkFOQUlBc2hERUVBSVJKQkFDRUhBMEFnQjBFQ2FpRUtBbjhnQjBFQmRDQUZhaUlDTGdFQ0loTkZCRUJCQUNFSVFRQWhDVUVBSVFZZ0NpRUhRUUFNQVFzZ0FpNEJBRUVDZENBUmFpRUpRUUFoQnlBVElRSkJBQ0VOSUFvaEJrRUFJUTVCQUNFUEEwQWdCU0FHUVFGMGFpNEJBQ0lJSUFBZ0NVRUJkQ0lRYWk4QkFHd2dCMm9oQnlBQUlCQkJCbkpxTHdFQUlBaHNJQTVxSVE0Z0FDQVFRUVJ5YWk4QkFDQUliQ0FQYWlFUElBQWdFRUVDY21vdkFRQWdDR3dnRFdvaERTQUpRUVJxSVFrZ0JrRUJhaUVHSUFKQkFXc2lBZzBBQ3lBSFFRZDFJUWdnRFVFSGRTRUpJQTlCQjNVaEJpQUtJQk5xSVFjZ0RrRUhkUXRCZ0VCclFRNTFJZ0pCL3dFZ0FrSC9BVWdiSWdKQkFDQUNRUUJLR3lJS1FmOEJjUVJBSUFsQi93RnNJQUp0SVFrZ0NFSC9BV3dnQW0waENDQUdRZjhCYkNBQ2JTRUdDeUFCSUF4QkFuUnFJQWxCZ0VCclFRNTFJZ0pCL3dFZ0FrSC9BVWdiSWdKQkFDQUNRUUJLRzBFSWRFR0EvZ054SUFaQmdFQnJRUTUxSWdKQi93RWdBa0gvQVVnYklnSkJBQ0FDUVFCS0cwRVFkRUdBZ1B3SGNTQUtRUmgwY2lBSVFZQkFhMEVPZFNJQ1FmOEJJQUpCL3dGSUd5SUNRUUFnQWtFQVNodHljallDQUNBRElBeHFJUXdnRWtFQmFpSVNJQVJIRFFBTElCUWdDMEVCYWlJTGJDRVJJQU1nQzBjTkFBc0xDMEFBSUFjRVFFRUFJQUlnQXlBRUlBVWdBQkFESUFKQkFDQUVJQVVnQmlBQkVBUVBDMEVBSUFJZ0F5QUVJQVVnQUJBQklBSkJBQ0FFSUFVZ0JpQUJFQUlMJztcblxufSx7fV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAncmVzaXplJyxcbiAgZm46IF9kZXJlcV8oJy4vcmVzaXplJyksXG4gIHdhc21fZm46IF9kZXJlcV8oJy4vcmVzaXplX3dhc20nKSxcbiAgd2FzbV9zcmM6IF9kZXJlcV8oJy4vY29udm9sdmVfd2FzbV9iYXNlNjQnKVxufTtcblxufSx7XCIuL2NvbnZvbHZlX3dhc21fYmFzZTY0XCI6MyxcIi4vcmVzaXplXCI6NSxcIi4vcmVzaXplX3dhc21cIjo4fV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVGaWx0ZXJzID0gX2RlcmVxXygnLi9yZXNpemVfZmlsdGVyX2dlbicpO1xuXG52YXIgX3JlcXVpcmUgPSBfZGVyZXFfKCcuL2NvbnZvbHZlJyksXG4gICAgY29udm9sdmVIb3IgPSBfcmVxdWlyZS5jb252b2x2ZUhvcixcbiAgICBjb252b2x2ZVZlcnQgPSBfcmVxdWlyZS5jb252b2x2ZVZlcnQsXG4gICAgY29udm9sdmVIb3JXaXRoUHJlID0gX3JlcXVpcmUuY29udm9sdmVIb3JXaXRoUHJlLFxuICAgIGNvbnZvbHZlVmVydFdpdGhQcmUgPSBfcmVxdWlyZS5jb252b2x2ZVZlcnRXaXRoUHJlO1xuXG5mdW5jdGlvbiBoYXNBbHBoYShzcmMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHB0ciA9IDMsXG4gICAgICBsZW4gPSB3aWR0aCAqIGhlaWdodCAqIDQgfCAwO1xuXG4gIHdoaWxlIChwdHIgPCBsZW4pIHtcbiAgICBpZiAoc3JjW3B0cl0gIT09IDI1NSkgcmV0dXJuIHRydWU7XG4gICAgcHRyID0gcHRyICsgNCB8IDA7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlc2V0QWxwaGEoZHN0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBwdHIgPSAzLFxuICAgICAgbGVuID0gd2lkdGggKiBoZWlnaHQgKiA0IHwgMDtcblxuICB3aGlsZSAocHRyIDwgbGVuKSB7XG4gICAgZHN0W3B0cl0gPSAweEZGO1xuICAgIHB0ciA9IHB0ciArIDQgfCAwO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVzaXplKG9wdGlvbnMpIHtcbiAgdmFyIHNyYyA9IG9wdGlvbnMuc3JjO1xuICB2YXIgc3JjVyA9IG9wdGlvbnMud2lkdGg7XG4gIHZhciBzcmNIID0gb3B0aW9ucy5oZWlnaHQ7XG4gIHZhciBkZXN0VyA9IG9wdGlvbnMudG9XaWR0aDtcbiAgdmFyIGRlc3RIID0gb3B0aW9ucy50b0hlaWdodDtcbiAgdmFyIHNjYWxlWCA9IG9wdGlvbnMuc2NhbGVYIHx8IG9wdGlvbnMudG9XaWR0aCAvIG9wdGlvbnMud2lkdGg7XG4gIHZhciBzY2FsZVkgPSBvcHRpb25zLnNjYWxlWSB8fCBvcHRpb25zLnRvSGVpZ2h0IC8gb3B0aW9ucy5oZWlnaHQ7XG4gIHZhciBvZmZzZXRYID0gb3B0aW9ucy5vZmZzZXRYIHx8IDA7XG4gIHZhciBvZmZzZXRZID0gb3B0aW9ucy5vZmZzZXRZIHx8IDA7XG4gIHZhciBkZXN0ID0gb3B0aW9ucy5kZXN0IHx8IG5ldyBVaW50OEFycmF5KGRlc3RXICogZGVzdEggKiA0KTtcbiAgdmFyIGZpbHRlciA9IHR5cGVvZiBvcHRpb25zLmZpbHRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnbWtzMjAxMycgOiBvcHRpb25zLmZpbHRlcjtcbiAgdmFyIGZpbHRlcnNYID0gY3JlYXRlRmlsdGVycyhmaWx0ZXIsIHNyY1csIGRlc3RXLCBzY2FsZVgsIG9mZnNldFgpLFxuICAgICAgZmlsdGVyc1kgPSBjcmVhdGVGaWx0ZXJzKGZpbHRlciwgc3JjSCwgZGVzdEgsIHNjYWxlWSwgb2Zmc2V0WSk7XG4gIHZhciB0bXAgPSBuZXcgVWludDE2QXJyYXkoZGVzdFcgKiBzcmNIICogNCk7IC8vIEF1dG9kZXRlY3QgaWYgYWxwaGEgY2hhbm5lbCBleGlzdHMsIGFuZCB1c2UgYXBwcm9wcmlhdGUgbWV0aG9kXG5cbiAgaWYgKGhhc0FscGhhKHNyYywgc3JjVywgc3JjSCkpIHtcbiAgICBjb252b2x2ZUhvcldpdGhQcmUoc3JjLCB0bXAsIHNyY1csIHNyY0gsIGRlc3RXLCBmaWx0ZXJzWCk7XG4gICAgY29udm9sdmVWZXJ0V2l0aFByZSh0bXAsIGRlc3QsIHNyY0gsIGRlc3RXLCBkZXN0SCwgZmlsdGVyc1kpO1xuICB9IGVsc2Uge1xuICAgIGNvbnZvbHZlSG9yKHNyYywgdG1wLCBzcmNXLCBzcmNILCBkZXN0VywgZmlsdGVyc1gpO1xuICAgIGNvbnZvbHZlVmVydCh0bXAsIGRlc3QsIHNyY0gsIGRlc3RXLCBkZXN0SCwgZmlsdGVyc1kpO1xuICAgIHJlc2V0QWxwaGEoZGVzdCwgZGVzdFcsIGRlc3RIKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxufSx7XCIuL2NvbnZvbHZlXCI6MixcIi4vcmVzaXplX2ZpbHRlcl9nZW5cIjo2fV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDYWxjdWxhdGUgY29udm9sdXRpb24gZmlsdGVycyBmb3IgZWFjaCBkZXN0aW5hdGlvbiBwb2ludCxcbi8vIGFuZCBwYWNrIGRhdGEgdG8gSW50MTZBcnJheTpcbi8vXG4vLyBbIHNoaWZ0LCBsZW5ndGgsIGRhdGEuLi4sIHNoaWZ0MiwgbGVuZ3RoMiwgZGF0YS4uLiwgLi4uIF1cbi8vXG4vLyAtIHNoaWZ0IC0gb2Zmc2V0IGluIHNyYyBpbWFnZVxuLy8gLSBsZW5ndGggLSBmaWx0ZXIgbGVuZ3RoIChpbiBzcmMgcG9pbnRzKVxuLy8gLSBkYXRhIC0gZmlsdGVyIHZhbHVlcyBzZXF1ZW5jZVxuLy9cbid1c2Ugc3RyaWN0JztcblxudmFyIEZJTFRFUl9JTkZPID0gX2RlcmVxXygnLi9yZXNpemVfZmlsdGVyX2luZm8nKTsgLy8gUHJlY2lzaW9uIG9mIGZpeGVkIEZQIHZhbHVlc1xuXG5cbnZhciBGSVhFRF9GUkFDX0JJVFMgPSAxNDtcblxuZnVuY3Rpb24gdG9GaXhlZFBvaW50KG51bSkge1xuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiAoKDEgPDwgRklYRURfRlJBQ19CSVRTKSAtIDEpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXNpemVGaWx0ZXJHZW4oZmlsdGVyLCBzcmNTaXplLCBkZXN0U2l6ZSwgc2NhbGUsIG9mZnNldCkge1xuICB2YXIgZmlsdGVyRnVuY3Rpb24gPSBGSUxURVJfSU5GTy5maWx0ZXJbZmlsdGVyXS5mbjtcbiAgdmFyIHNjYWxlSW52ZXJ0ZWQgPSAxLjAgLyBzY2FsZTtcbiAgdmFyIHNjYWxlQ2xhbXBlZCA9IE1hdGgubWluKDEuMCwgc2NhbGUpOyAvLyBGb3IgdXBzY2FsZVxuICAvLyBGaWx0ZXIgd2luZG93IChhdmVyYWdpbmcgaW50ZXJ2YWwpLCBzY2FsZWQgdG8gc3JjIGltYWdlXG5cbiAgdmFyIHNyY1dpbmRvdyA9IEZJTFRFUl9JTkZPLmZpbHRlcltmaWx0ZXJdLndpbiAvIHNjYWxlQ2xhbXBlZDtcbiAgdmFyIGRlc3RQaXhlbCwgc3JjUGl4ZWwsIHNyY0ZpcnN0LCBzcmNMYXN0LCBmaWx0ZXJFbGVtZW50U2l6ZSwgZmxvYXRGaWx0ZXIsIGZ4cEZpbHRlciwgdG90YWwsIHB4bCwgaWR4LCBmbG9hdFZhbCwgZmlsdGVyVG90YWwsIGZpbHRlclZhbDtcbiAgdmFyIGxlZnROb3RFbXB0eSwgcmlnaHROb3RFbXB0eSwgZmlsdGVyU2hpZnQsIGZpbHRlclNpemU7XG4gIHZhciBtYXhGaWx0ZXJFbGVtZW50U2l6ZSA9IE1hdGguZmxvb3IoKHNyY1dpbmRvdyArIDEpICogMik7XG4gIHZhciBwYWNrZWRGaWx0ZXIgPSBuZXcgSW50MTZBcnJheSgobWF4RmlsdGVyRWxlbWVudFNpemUgKyAyKSAqIGRlc3RTaXplKTtcbiAgdmFyIHBhY2tlZEZpbHRlclB0ciA9IDA7XG4gIHZhciBzbG93Q29weSA9ICFwYWNrZWRGaWx0ZXIuc3ViYXJyYXkgfHwgIXBhY2tlZEZpbHRlci5zZXQ7IC8vIEZvciBlYWNoIGRlc3RpbmF0aW9uIHBpeGVsIGNhbGN1bGF0ZSBzb3VyY2UgcmFuZ2UgYW5kIGJ1aWx0IGZpbHRlciB2YWx1ZXNcblxuICBmb3IgKGRlc3RQaXhlbCA9IDA7IGRlc3RQaXhlbCA8IGRlc3RTaXplOyBkZXN0UGl4ZWwrKykge1xuICAgIC8vIFNjYWxpbmcgc2hvdWxkIGJlIGRvbmUgcmVsYXRpdmUgdG8gY2VudHJhbCBwaXhlbCBwb2ludFxuICAgIHNyY1BpeGVsID0gKGRlc3RQaXhlbCArIDAuNSkgKiBzY2FsZUludmVydGVkICsgb2Zmc2V0O1xuICAgIHNyY0ZpcnN0ID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihzcmNQaXhlbCAtIHNyY1dpbmRvdykpO1xuICAgIHNyY0xhc3QgPSBNYXRoLm1pbihzcmNTaXplIC0gMSwgTWF0aC5jZWlsKHNyY1BpeGVsICsgc3JjV2luZG93KSk7XG4gICAgZmlsdGVyRWxlbWVudFNpemUgPSBzcmNMYXN0IC0gc3JjRmlyc3QgKyAxO1xuICAgIGZsb2F0RmlsdGVyID0gbmV3IEZsb2F0MzJBcnJheShmaWx0ZXJFbGVtZW50U2l6ZSk7XG4gICAgZnhwRmlsdGVyID0gbmV3IEludDE2QXJyYXkoZmlsdGVyRWxlbWVudFNpemUpO1xuICAgIHRvdGFsID0gMC4wOyAvLyBGaWxsIGZpbHRlciB2YWx1ZXMgZm9yIGNhbGN1bGF0ZWQgcmFuZ2VcblxuICAgIGZvciAocHhsID0gc3JjRmlyc3QsIGlkeCA9IDA7IHB4bCA8PSBzcmNMYXN0OyBweGwrKywgaWR4KyspIHtcbiAgICAgIGZsb2F0VmFsID0gZmlsdGVyRnVuY3Rpb24oKHB4bCArIDAuNSAtIHNyY1BpeGVsKSAqIHNjYWxlQ2xhbXBlZCk7XG4gICAgICB0b3RhbCArPSBmbG9hdFZhbDtcbiAgICAgIGZsb2F0RmlsdGVyW2lkeF0gPSBmbG9hdFZhbDtcbiAgICB9IC8vIE5vcm1hbGl6ZSBmaWx0ZXIsIGNvbnZlcnQgdG8gZml4ZWQgcG9pbnQgYW5kIGFjY3VtdWxhdGUgY29udmVyc2lvbiBlcnJvclxuXG5cbiAgICBmaWx0ZXJUb3RhbCA9IDA7XG5cbiAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGZsb2F0RmlsdGVyLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGZpbHRlclZhbCA9IGZsb2F0RmlsdGVyW2lkeF0gLyB0b3RhbDtcbiAgICAgIGZpbHRlclRvdGFsICs9IGZpbHRlclZhbDtcbiAgICAgIGZ4cEZpbHRlcltpZHhdID0gdG9GaXhlZFBvaW50KGZpbHRlclZhbCk7XG4gICAgfSAvLyBDb21wZW5zYXRlIG5vcm1hbGl6YXRpb24gZXJyb3IsIHRvIG1pbmltaXplIGJyaWdodG5lc3MgZHJpZnRcblxuXG4gICAgZnhwRmlsdGVyW2Rlc3RTaXplID4+IDFdICs9IHRvRml4ZWRQb2ludCgxLjAgLSBmaWx0ZXJUb3RhbCk7IC8vXG4gICAgLy8gTm93IHBhY2sgZmlsdGVyIHRvIHVzZWFibGUgZm9ybVxuICAgIC8vXG4gICAgLy8gMS4gVHJpbSBoZWFkaW5nIGFuZCB0YWlsaW5nIHplcm8gdmFsdWVzLCBhbmQgY29tcGVuc2F0ZSBzaGl0Zi9sZW5ndGhcbiAgICAvLyAyLiBQdXQgYWxsIHRvIHNpbmdsZSBhcnJheSBpbiB0aGlzIGZvcm1hdDpcbiAgICAvL1xuICAgIC8vICAgIFsgcG9zIHNoaWZ0LCBkYXRhIGxlbmd0aCwgdmFsdWUxLCB2YWx1ZTIsIHZhbHVlMywgLi4uIF1cbiAgICAvL1xuXG4gICAgbGVmdE5vdEVtcHR5ID0gMDtcblxuICAgIHdoaWxlIChsZWZ0Tm90RW1wdHkgPCBmeHBGaWx0ZXIubGVuZ3RoICYmIGZ4cEZpbHRlcltsZWZ0Tm90RW1wdHldID09PSAwKSB7XG4gICAgICBsZWZ0Tm90RW1wdHkrKztcbiAgICB9XG5cbiAgICBpZiAobGVmdE5vdEVtcHR5IDwgZnhwRmlsdGVyLmxlbmd0aCkge1xuICAgICAgcmlnaHROb3RFbXB0eSA9IGZ4cEZpbHRlci5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocmlnaHROb3RFbXB0eSA+IDAgJiYgZnhwRmlsdGVyW3JpZ2h0Tm90RW1wdHldID09PSAwKSB7XG4gICAgICAgIHJpZ2h0Tm90RW1wdHktLTtcbiAgICAgIH1cblxuICAgICAgZmlsdGVyU2hpZnQgPSBzcmNGaXJzdCArIGxlZnROb3RFbXB0eTtcbiAgICAgIGZpbHRlclNpemUgPSByaWdodE5vdEVtcHR5IC0gbGVmdE5vdEVtcHR5ICsgMTtcbiAgICAgIHBhY2tlZEZpbHRlcltwYWNrZWRGaWx0ZXJQdHIrK10gPSBmaWx0ZXJTaGlmdDsgLy8gc2hpZnRcblxuICAgICAgcGFja2VkRmlsdGVyW3BhY2tlZEZpbHRlclB0cisrXSA9IGZpbHRlclNpemU7IC8vIHNpemVcblxuICAgICAgaWYgKCFzbG93Q29weSkge1xuICAgICAgICBwYWNrZWRGaWx0ZXIuc2V0KGZ4cEZpbHRlci5zdWJhcnJheShsZWZ0Tm90RW1wdHksIHJpZ2h0Tm90RW1wdHkgKyAxKSwgcGFja2VkRmlsdGVyUHRyKTtcbiAgICAgICAgcGFja2VkRmlsdGVyUHRyICs9IGZpbHRlclNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmYWxsYmFjayBmb3Igb2xkIElFIDwgMTEsIHdpdGhvdXQgc3ViYXJyYXkvc2V0IG1ldGhvZHNcbiAgICAgICAgZm9yIChpZHggPSBsZWZ0Tm90RW1wdHk7IGlkeCA8PSByaWdodE5vdEVtcHR5OyBpZHgrKykge1xuICAgICAgICAgIHBhY2tlZEZpbHRlcltwYWNrZWRGaWx0ZXJQdHIrK10gPSBmeHBGaWx0ZXJbaWR4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB6ZXJvIGRhdGEsIHdyaXRlIGhlYWRlciBvbmx5XG4gICAgICBwYWNrZWRGaWx0ZXJbcGFja2VkRmlsdGVyUHRyKytdID0gMDsgLy8gc2hpZnRcblxuICAgICAgcGFja2VkRmlsdGVyW3BhY2tlZEZpbHRlclB0cisrXSA9IDA7IC8vIHNpemVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFja2VkRmlsdGVyO1xufTtcblxufSx7XCIuL3Jlc2l6ZV9maWx0ZXJfaW5mb1wiOjd9XSw3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIEZpbHRlciBkZWZpbml0aW9ucyB0byBidWlsZCB0YWJsZXMgZm9yXG4vLyByZXNpemluZyBjb252b2x2ZXJzLlxuLy9cbi8vIFByZXNldHMgZm9yIHF1YWxpdHkgMC4uMy4gRmlsdGVyIGZ1bmN0aW9ucyArIHdpbmRvdyBzaXplXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZmlsdGVyID0ge1xuICAvLyBOZWFyZXN0IG5laWJvclxuICBib3g6IHtcbiAgICB3aW46IDAuNSxcbiAgICBmbjogZnVuY3Rpb24gZm4oeCkge1xuICAgICAgaWYgKHggPCAwKSB4ID0gLXg7XG4gICAgICByZXR1cm4geCA8IDAuNSA/IDEuMCA6IDAuMDtcbiAgICB9XG4gIH0sXG4gIC8vIC8vIEhhbW1pbmdcbiAgaGFtbWluZzoge1xuICAgIHdpbjogMS4wLFxuICAgIGZuOiBmdW5jdGlvbiBmbih4KSB7XG4gICAgICBpZiAoeCA8IDApIHggPSAteDtcblxuICAgICAgaWYgKHggPj0gMS4wKSB7XG4gICAgICAgIHJldHVybiAwLjA7XG4gICAgICB9XG5cbiAgICAgIGlmICh4IDwgMS4xOTIwOTI5MEUtMDcpIHtcbiAgICAgICAgcmV0dXJuIDEuMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHhwaSA9IHggKiBNYXRoLlBJO1xuICAgICAgcmV0dXJuIE1hdGguc2luKHhwaSkgLyB4cGkgKiAoMC41NCArIDAuNDYgKiBNYXRoLmNvcyh4cGkgLyAxLjApKTtcbiAgICB9XG4gIH0sXG4gIC8vIExhbmN6b3MsIHdpbiA9IDJcbiAgbGFuY3pvczI6IHtcbiAgICB3aW46IDIuMCxcbiAgICBmbjogZnVuY3Rpb24gZm4oeCkge1xuICAgICAgaWYgKHggPCAwKSB4ID0gLXg7XG5cbiAgICAgIGlmICh4ID49IDIuMCkge1xuICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA8IDEuMTkyMDkyOTBFLTA3KSB7XG4gICAgICAgIHJldHVybiAxLjA7XG4gICAgICB9XG5cbiAgICAgIHZhciB4cGkgPSB4ICogTWF0aC5QSTtcbiAgICAgIHJldHVybiBNYXRoLnNpbih4cGkpIC8geHBpICogTWF0aC5zaW4oeHBpIC8gMi4wKSAvICh4cGkgLyAyLjApO1xuICAgIH1cbiAgfSxcbiAgLy8gTGFuY3pvcywgd2luID0gM1xuICBsYW5jem9zMzoge1xuICAgIHdpbjogMy4wLFxuICAgIGZuOiBmdW5jdGlvbiBmbih4KSB7XG4gICAgICBpZiAoeCA8IDApIHggPSAteDtcblxuICAgICAgaWYgKHggPj0gMy4wKSB7XG4gICAgICAgIHJldHVybiAwLjA7XG4gICAgICB9XG5cbiAgICAgIGlmICh4IDwgMS4xOTIwOTI5MEUtMDcpIHtcbiAgICAgICAgcmV0dXJuIDEuMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHhwaSA9IHggKiBNYXRoLlBJO1xuICAgICAgcmV0dXJuIE1hdGguc2luKHhwaSkgLyB4cGkgKiBNYXRoLnNpbih4cGkgLyAzLjApIC8gKHhwaSAvIDMuMCk7XG4gICAgfVxuICB9LFxuICAvLyBNYWdpYyBLZXJuZWwgU2hhcnAgMjAxMywgd2luID0gMi41XG4gIC8vIGh0dHA6Ly9qb2huY29zdGVsbGEuY29tL21hZ2ljL1xuICBta3MyMDEzOiB7XG4gICAgd2luOiAyLjUsXG4gICAgZm46IGZ1bmN0aW9uIGZuKHgpIHtcbiAgICAgIGlmICh4IDwgMCkgeCA9IC14O1xuXG4gICAgICBpZiAoeCA+PSAyLjUpIHtcbiAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHggPj0gMS41KSB7XG4gICAgICAgIHJldHVybiAtMC4xMjUgKiAoeCAtIDIuNSkgKiAoeCAtIDIuNSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh4ID49IDAuNSkge1xuICAgICAgICByZXR1cm4gMC4yNSAqICg0ICogeCAqIHggLSAxMSAqIHggKyA3KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDEuMDYyNSAtIDEuNzUgKiB4ICogeDtcbiAgICB9XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZmlsdGVyOiBmaWx0ZXIsXG4gIC8vIExlZ2FjeSBtYXBwaW5nXG4gIGYycToge1xuICAgIGJveDogMCxcbiAgICBoYW1taW5nOiAxLFxuICAgIGxhbmN6b3MyOiAyLFxuICAgIGxhbmN6b3MzOiAzXG4gIH0sXG4gIHEyZjogWydib3gnLCAnaGFtbWluZycsICdsYW5jem9zMicsICdsYW5jem9zMyddXG59O1xuXG59LHt9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZUZpbHRlcnMgPSBfZGVyZXFfKCcuL3Jlc2l6ZV9maWx0ZXJfZ2VuJyk7XG5cbmZ1bmN0aW9uIGhhc0FscGhhKHNyYywgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgcHRyID0gMyxcbiAgICAgIGxlbiA9IHdpZHRoICogaGVpZ2h0ICogNCB8IDA7XG5cbiAgd2hpbGUgKHB0ciA8IGxlbikge1xuICAgIGlmIChzcmNbcHRyXSAhPT0gMjU1KSByZXR1cm4gdHJ1ZTtcbiAgICBwdHIgPSBwdHIgKyA0IHwgMDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVzZXRBbHBoYShkc3QsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHB0ciA9IDMsXG4gICAgICBsZW4gPSB3aWR0aCAqIGhlaWdodCAqIDQgfCAwO1xuXG4gIHdoaWxlIChwdHIgPCBsZW4pIHtcbiAgICBkc3RbcHRyXSA9IDB4RkY7XG4gICAgcHRyID0gcHRyICsgNCB8IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNVaW50OEFycmF5KHNyYykge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc3JjLmJ1ZmZlciwgMCwgc3JjLmJ5dGVMZW5ndGgpO1xufVxuXG52YXIgSVNfTEUgPSB0cnVlOyAvLyBzaG91bGQgbm90IGNyYXNoIGV2ZXJ5dGhpbmcgb24gbW9kdWxlIGxvYWQgaW4gb2xkIGJyb3dzZXJzXG5cbnRyeSB7XG4gIElTX0xFID0gbmV3IFVpbnQzMkFycmF5KG5ldyBVaW50OEFycmF5KFsxLCAwLCAwLCAwXSkuYnVmZmVyKVswXSA9PT0gMTtcbn0gY2F0Y2ggKF9fKSB7fVxuXG5mdW5jdGlvbiBjb3B5SW50MTZhc0xFKHNyYywgdGFyZ2V0LCB0YXJnZXRfb2Zmc2V0KSB7XG4gIGlmIChJU19MRSkge1xuICAgIHRhcmdldC5zZXQoYXNVaW50OEFycmF5KHNyYyksIHRhcmdldF9vZmZzZXQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIHB0ciA9IHRhcmdldF9vZmZzZXQsIGkgPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRhdGEgPSBzcmNbaV07XG4gICAgdGFyZ2V0W3B0cisrXSA9IGRhdGEgJiAweEZGO1xuICAgIHRhcmdldFtwdHIrK10gPSBkYXRhID4+IDggJiAweEZGO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVzaXplX3dhc20ob3B0aW9ucykge1xuICB2YXIgc3JjID0gb3B0aW9ucy5zcmM7XG4gIHZhciBzcmNXID0gb3B0aW9ucy53aWR0aDtcbiAgdmFyIHNyY0ggPSBvcHRpb25zLmhlaWdodDtcbiAgdmFyIGRlc3RXID0gb3B0aW9ucy50b1dpZHRoO1xuICB2YXIgZGVzdEggPSBvcHRpb25zLnRvSGVpZ2h0O1xuICB2YXIgc2NhbGVYID0gb3B0aW9ucy5zY2FsZVggfHwgb3B0aW9ucy50b1dpZHRoIC8gb3B0aW9ucy53aWR0aDtcbiAgdmFyIHNjYWxlWSA9IG9wdGlvbnMuc2NhbGVZIHx8IG9wdGlvbnMudG9IZWlnaHQgLyBvcHRpb25zLmhlaWdodDtcbiAgdmFyIG9mZnNldFggPSBvcHRpb25zLm9mZnNldFggfHwgMC4wO1xuICB2YXIgb2Zmc2V0WSA9IG9wdGlvbnMub2Zmc2V0WSB8fCAwLjA7XG4gIHZhciBkZXN0ID0gb3B0aW9ucy5kZXN0IHx8IG5ldyBVaW50OEFycmF5KGRlc3RXICogZGVzdEggKiA0KTtcbiAgdmFyIGZpbHRlciA9IHR5cGVvZiBvcHRpb25zLmZpbHRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnbWtzMjAxMycgOiBvcHRpb25zLmZpbHRlcjtcbiAgdmFyIGZpbHRlcnNYID0gY3JlYXRlRmlsdGVycyhmaWx0ZXIsIHNyY1csIGRlc3RXLCBzY2FsZVgsIG9mZnNldFgpLFxuICAgICAgZmlsdGVyc1kgPSBjcmVhdGVGaWx0ZXJzKGZpbHRlciwgc3JjSCwgZGVzdEgsIHNjYWxlWSwgb2Zmc2V0WSk7IC8vIGRlc3RpbmF0aW9uIGlzIDAgdG9vLlxuXG4gIHZhciBzcmNfb2Zmc2V0ID0gMDtcbiAgdmFyIHNyY19zaXplID0gTWF0aC5tYXgoc3JjLmJ5dGVMZW5ndGgsIGRlc3QuYnl0ZUxlbmd0aCk7IC8vIGJ1ZmZlciBiZXR3ZWVuIGNvbnZvbHZlIHBhc3Nlc1xuXG4gIHZhciB0bXBfb2Zmc2V0ID0gdGhpcy5fX2FsaWduKHNyY19vZmZzZXQgKyBzcmNfc2l6ZSk7XG5cbiAgdmFyIHRtcF9zaXplID0gc3JjSCAqIGRlc3RXICogNCAqIDI7IC8vIDIgYnl0ZXMgcGVyIGNoYW5uZWxcblxuICB2YXIgZmlsdGVyc1hfb2Zmc2V0ID0gdGhpcy5fX2FsaWduKHRtcF9vZmZzZXQgKyB0bXBfc2l6ZSk7XG5cbiAgdmFyIGZpbHRlcnNZX29mZnNldCA9IHRoaXMuX19hbGlnbihmaWx0ZXJzWF9vZmZzZXQgKyBmaWx0ZXJzWC5ieXRlTGVuZ3RoKTtcblxuICB2YXIgYWxsb2NfYnl0ZXMgPSBmaWx0ZXJzWV9vZmZzZXQgKyBmaWx0ZXJzWS5ieXRlTGVuZ3RoO1xuXG4gIHZhciBpbnN0YW5jZSA9IHRoaXMuX19pbnN0YW5jZSgncmVzaXplJywgYWxsb2NfYnl0ZXMpOyAvL1xuICAvLyBGaWxsIG1lbW9yeSBibG9jayB3aXRoIGRhdGEgdG8gcHJvY2Vzc1xuICAvL1xuXG5cbiAgdmFyIG1lbSA9IG5ldyBVaW50OEFycmF5KHRoaXMuX19tZW1vcnkuYnVmZmVyKTtcbiAgdmFyIG1lbTMyID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuX19tZW1vcnkuYnVmZmVyKTsgLy8gMzItYml0IGNvcHkgaXMgbXVjaCBmYXN0ZXIgaW4gY2hyb21lXG5cbiAgdmFyIHNyYzMyID0gbmV3IFVpbnQzMkFycmF5KHNyYy5idWZmZXIpO1xuICBtZW0zMi5zZXQoc3JjMzIpOyAvLyBXZSBzaG91bGQgZ3VhcmFudGVlIExFIGJ5dGVzIG9yZGVyLiBGaWx0ZXJzIGFyZSBub3QgYmlnLCBzb1xuICAvLyBzcGVlZCBkaWZmZXJlbmNlIGlzIG5vdCBzaWduaWZpY2FudCB2cyBkaXJlY3QgLnNldCgpXG5cbiAgY29weUludDE2YXNMRShmaWx0ZXJzWCwgbWVtLCBmaWx0ZXJzWF9vZmZzZXQpO1xuICBjb3B5SW50MTZhc0xFKGZpbHRlcnNZLCBtZW0sIGZpbHRlcnNZX29mZnNldCk7IC8vIE5vdyBjYWxsIHdlYmFzc2VtYmx5IG1ldGhvZFxuICAvLyBlbXNkayBkb2VzIG1ldGhvZCBuYW1lcyB3aXRoICdfJ1xuXG4gIHZhciBmbiA9IGluc3RhbmNlLmV4cG9ydHMuY29udm9sdmVIViB8fCBpbnN0YW5jZS5leHBvcnRzLl9jb252b2x2ZUhWO1xuXG4gIGlmIChoYXNBbHBoYShzcmMsIHNyY1csIHNyY0gpKSB7XG4gICAgZm4oZmlsdGVyc1hfb2Zmc2V0LCBmaWx0ZXJzWV9vZmZzZXQsIHRtcF9vZmZzZXQsIHNyY1csIHNyY0gsIGRlc3RXLCBkZXN0SCwgMSk7XG4gIH0gZWxzZSB7XG4gICAgZm4oZmlsdGVyc1hfb2Zmc2V0LCBmaWx0ZXJzWV9vZmZzZXQsIHRtcF9vZmZzZXQsIHNyY1csIHNyY0gsIGRlc3RXLCBkZXN0SCwgMCk7XG4gICAgcmVzZXRBbHBoYShkZXN0LCBkZXN0VywgZGVzdEgpO1xuICB9IC8vXG4gIC8vIENvcHkgZGF0YSBiYWNrIHRvIHR5cGVkIGFycmF5XG4gIC8vXG4gIC8vIDMyLWJpdCBjb3B5IGlzIG11Y2ggZmFzdGVyIGluIGNocm9tZVxuXG5cbiAgdmFyIGRlc3QzMiA9IG5ldyBVaW50MzJBcnJheShkZXN0LmJ1ZmZlcik7XG4gIGRlc3QzMi5zZXQobmV3IFVpbnQzMkFycmF5KHRoaXMuX19tZW1vcnkuYnVmZmVyLCAwLCBkZXN0SCAqIGRlc3RXKSk7XG4gIHJldHVybiBkZXN0O1xufTtcblxufSx7XCIuL3Jlc2l6ZV9maWx0ZXJfZ2VuXCI6Nn1dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ3Vuc2hhcnBfbWFzaycsXG4gIGZuOiBfZGVyZXFfKCcuL3Vuc2hhcnBfbWFzaycpLFxuICB3YXNtX2ZuOiBfZGVyZXFfKCcuL3Vuc2hhcnBfbWFza193YXNtJyksXG4gIHdhc21fc3JjOiBfZGVyZXFfKCcuL3Vuc2hhcnBfbWFza193YXNtX2Jhc2U2NCcpXG59O1xuXG59LHtcIi4vdW5zaGFycF9tYXNrXCI6MTAsXCIuL3Vuc2hhcnBfbWFza193YXNtXCI6MTEsXCIuL3Vuc2hhcnBfbWFza193YXNtX2Jhc2U2NFwiOjEyfV0sMTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gVW5zaGFycCBtYXNrIGZpbHRlclxuLy9cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIzMzIyODIwLzEwMzE4MDRcbi8vIFVTTShPKSA9IE8gKyAoMiAqIChBbW91bnQgLyAxMDApICogKE8gLSBHQikpXG4vLyBHQiAtIGdhdXNzaWFuIGJsdXIuXG4vL1xuLy8gSW1hZ2UgaXMgY29udmVydGVkIGZyb20gUkdCIHRvIEhTViwgdW5zaGFycCBtYXNrIGlzIGFwcGxpZWQgdG8gdGhlXG4vLyBicmlnaHRuZXNzIGNoYW5uZWwgYW5kIHRoZW4gaW1hZ2UgaXMgY29udmVydGVkIGJhY2sgdG8gUkdCLlxuLy9cbid1c2Ugc3RyaWN0JztcblxudmFyIGdsdXJfbW9ubzE2ID0gX2RlcmVxXygnZ2x1ci9tb25vMTYnKTtcblxuZnVuY3Rpb24gaHN2X3YxNihpbWcsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHNpemUgPSB3aWR0aCAqIGhlaWdodDtcbiAgdmFyIG91dCA9IG5ldyBVaW50MTZBcnJheShzaXplKTtcbiAgdmFyIHIsIGcsIGIsIG1heDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIHIgPSBpbWdbNCAqIGldO1xuICAgIGcgPSBpbWdbNCAqIGkgKyAxXTtcbiAgICBiID0gaW1nWzQgKiBpICsgMl07XG4gICAgbWF4ID0gciA+PSBnICYmIHIgPj0gYiA/IHIgOiBnID49IGIgJiYgZyA+PSByID8gZyA6IGI7XG4gICAgb3V0W2ldID0gbWF4IDw8IDg7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVuc2hhcnAoaW1nLCB3aWR0aCwgaGVpZ2h0LCBhbW91bnQsIHJhZGl1cywgdGhyZXNob2xkKSB7XG4gIHZhciB2MSwgdjIsIHZtdWw7XG4gIHZhciBkaWZmLCBpVGltZXM0O1xuXG4gIGlmIChhbW91bnQgPT09IDAgfHwgcmFkaXVzIDwgMC41KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHJhZGl1cyA+IDIuMCkge1xuICAgIHJhZGl1cyA9IDIuMDtcbiAgfVxuXG4gIHZhciBicmlnaHRuZXNzID0gaHN2X3YxNihpbWcsIHdpZHRoLCBoZWlnaHQpO1xuICB2YXIgYmx1cmVkID0gbmV3IFVpbnQxNkFycmF5KGJyaWdodG5lc3MpOyAvLyBjb3B5LCBiZWNhdXNlIGJsdXIgbW9kaWZ5IHNyY1xuXG4gIGdsdXJfbW9ubzE2KGJsdXJlZCwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKTtcbiAgdmFyIGFtb3VudEZwID0gYW1vdW50IC8gMTAwICogMHgxMDAwICsgMC41IHwgMDtcbiAgdmFyIHRocmVzaG9sZEZwID0gdGhyZXNob2xkIDw8IDg7XG4gIHZhciBzaXplID0gd2lkdGggKiBoZWlnaHQ7XG4gIC8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgdjEgPSBicmlnaHRuZXNzW2ldO1xuICAgIGRpZmYgPSB2MSAtIGJsdXJlZFtpXTtcblxuICAgIGlmIChNYXRoLmFicyhkaWZmKSA+PSB0aHJlc2hvbGRGcCkge1xuICAgICAgLy8gYWRkIHVuc2hhcnAgbWFzayB0byB0aGUgYnJpZ2h0bmVzcyBjaGFubmVsXG4gICAgICB2MiA9IHYxICsgKGFtb3VudEZwICogZGlmZiArIDB4ODAwID4+IDEyKTsgLy8gQm90aCB2MSBhbmQgdjIgYXJlIHdpdGhpbiBbMC4wIC4uIDI1NS4wXSAoMDAwMC1GRjAwKSByYW5nZSwgbmV2ZXIgZ29pbmcgaW50b1xuICAgICAgLy8gWzI1NS4wMDMgLi4gMjU1Ljk5Nl0gKEZGMDEtRkZGRikuIFRoaXMgYWxsb3dzIHRvIHJvdW5kIHRoaXMgdmFsdWUgYXMgKHgrLjUpfDBcbiAgICAgIC8vIGxhdGVyIHdpdGhvdXQgb3ZlcmZsb3dpbmcuXG5cbiAgICAgIHYyID0gdjIgPiAweGZmMDAgPyAweGZmMDAgOiB2MjtcbiAgICAgIHYyID0gdjIgPCAweDAwMDAgPyAweDAwMDAgOiB2MjsgLy8gQXZvaWQgZGl2aXNpb24gYnkgMC4gVj0wIG1lYW5zIHJnYigwLDAsMCksIHVuc2hhcnAgd2l0aCB1bnNoYXJwQW1vdW50PjAgY2Fubm90XG4gICAgICAvLyBjaGFuZ2UgdGhpcyB2YWx1ZSAoYmVjYXVzZSBkaWZmIGJldHdlZW4gY29sb3JzIGdldHMgaW5mbGF0ZWQpLCBzbyBubyBuZWVkIHRvIHZlcmlmeSBjb3JyZWN0bmVzcy5cblxuICAgICAgdjEgPSB2MSAhPT0gMCA/IHYxIDogMTsgLy8gTXVsdGlwbHlpbmcgViBpbiBIU1YgbW9kZWwgYnkgYSBjb25zdGFudCBpcyBlcXVpdmFsZW50IHRvIG11bHRpcGx5aW5nIGVhY2ggY29tcG9uZW50XG4gICAgICAvLyBpbiBSR0IgYnkgdGhlIHNhbWUgY29uc3RhbnQgKHNhbWUgZm9yIEhTTCksIHNlZSBhbHNvOlxuICAgICAgLy8gaHR0cHM6Ly9iZWVzYnV6ei5iaXovY29kZS8xNi1oc3YtY29sb3ItdHJhbnNmb3Jtc1xuXG4gICAgICB2bXVsID0gKHYyIDw8IDEyKSAvIHYxIHwgMDsgLy8gUmVzdWx0IHdpbGwgYmUgaW4gWzAuLjI1NV0gcmFuZ2UgYmVjYXVzZTpcbiAgICAgIC8vICAtIGFsbCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuICAgICAgLy8gIC0gcixnLGIgPD0gKHYxLzI1NilcbiAgICAgIC8vICAtIHIsZyxiLCh2MS8yNTYpLCh2Mi8yNTYpIDw9IDI1NVxuICAgICAgLy8gU28gaGlnaGVzdCB0aGlzIG51bWJlciBjYW4gZ2V0IGlzIFgqMjU1L1grMC41PTI1NS41IHdoaWNoIGlzIDwgMjU2IGFuZCByb3VuZHMgZG93bi5cblxuICAgICAgaVRpbWVzNCA9IGkgKiA0O1xuICAgICAgaW1nW2lUaW1lczRdID0gaW1nW2lUaW1lczRdICogdm11bCArIDB4ODAwID4+IDEyOyAvLyBSXG5cbiAgICAgIGltZ1tpVGltZXM0ICsgMV0gPSBpbWdbaVRpbWVzNCArIDFdICogdm11bCArIDB4ODAwID4+IDEyOyAvLyBHXG5cbiAgICAgIGltZ1tpVGltZXM0ICsgMl0gPSBpbWdbaVRpbWVzNCArIDJdICogdm11bCArIDB4ODAwID4+IDEyOyAvLyBCXG4gICAgfVxuICB9XG59O1xuXG59LHtcImdsdXIvbW9ubzE2XCI6MTh9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdW5zaGFycChpbWcsIHdpZHRoLCBoZWlnaHQsIGFtb3VudCwgcmFkaXVzLCB0aHJlc2hvbGQpIHtcbiAgaWYgKGFtb3VudCA9PT0gMCB8fCByYWRpdXMgPCAwLjUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocmFkaXVzID4gMi4wKSB7XG4gICAgcmFkaXVzID0gMi4wO1xuICB9XG5cbiAgdmFyIHBpeGVscyA9IHdpZHRoICogaGVpZ2h0O1xuICB2YXIgaW1nX2J5dGVzX2NudCA9IHBpeGVscyAqIDQ7XG4gIHZhciBoc3ZfYnl0ZXNfY250ID0gcGl4ZWxzICogMjtcbiAgdmFyIGJsdXJfYnl0ZXNfY250ID0gcGl4ZWxzICogMjtcbiAgdmFyIGJsdXJfbGluZV9ieXRlX2NudCA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpICogNDsgLy8gZmxvYXQzMiBhcnJheVxuXG4gIHZhciBibHVyX2NvZWZmc19ieXRlX2NudCA9IDggKiA0OyAvLyBmbG9hdDMyIGFycmF5XG5cbiAgdmFyIGltZ19vZmZzZXQgPSAwO1xuICB2YXIgaHN2X29mZnNldCA9IGltZ19ieXRlc19jbnQ7XG4gIHZhciBibHVyX29mZnNldCA9IGhzdl9vZmZzZXQgKyBoc3ZfYnl0ZXNfY250O1xuICB2YXIgYmx1cl90bXBfb2Zmc2V0ID0gYmx1cl9vZmZzZXQgKyBibHVyX2J5dGVzX2NudDtcbiAgdmFyIGJsdXJfbGluZV9vZmZzZXQgPSBibHVyX3RtcF9vZmZzZXQgKyBibHVyX2J5dGVzX2NudDtcbiAgdmFyIGJsdXJfY29lZmZzX29mZnNldCA9IGJsdXJfbGluZV9vZmZzZXQgKyBibHVyX2xpbmVfYnl0ZV9jbnQ7XG5cbiAgdmFyIGluc3RhbmNlID0gdGhpcy5fX2luc3RhbmNlKCd1bnNoYXJwX21hc2snLCBpbWdfYnl0ZXNfY250ICsgaHN2X2J5dGVzX2NudCArIGJsdXJfYnl0ZXNfY250ICogMiArIGJsdXJfbGluZV9ieXRlX2NudCArIGJsdXJfY29lZmZzX2J5dGVfY250LCB7XG4gICAgZXhwOiBNYXRoLmV4cFxuICB9KTsgLy8gMzItYml0IGNvcHkgaXMgbXVjaCBmYXN0ZXIgaW4gY2hyb21lXG5cblxuICB2YXIgaW1nMzIgPSBuZXcgVWludDMyQXJyYXkoaW1nLmJ1ZmZlcik7XG4gIHZhciBtZW0zMiA9IG5ldyBVaW50MzJBcnJheSh0aGlzLl9fbWVtb3J5LmJ1ZmZlcik7XG4gIG1lbTMyLnNldChpbWczMik7IC8vIEhTTFxuXG4gIHZhciBmbiA9IGluc3RhbmNlLmV4cG9ydHMuaHN2X3YxNiB8fCBpbnN0YW5jZS5leHBvcnRzLl9oc3ZfdjE2O1xuICBmbihpbWdfb2Zmc2V0LCBoc3Zfb2Zmc2V0LCB3aWR0aCwgaGVpZ2h0KTsgLy8gQkxVUlxuXG4gIGZuID0gaW5zdGFuY2UuZXhwb3J0cy5ibHVyTW9ubzE2IHx8IGluc3RhbmNlLmV4cG9ydHMuX2JsdXJNb25vMTY7XG4gIGZuKGhzdl9vZmZzZXQsIGJsdXJfb2Zmc2V0LCBibHVyX3RtcF9vZmZzZXQsIGJsdXJfbGluZV9vZmZzZXQsIGJsdXJfY29lZmZzX29mZnNldCwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKTsgLy8gVU5TSEFSUFxuXG4gIGZuID0gaW5zdGFuY2UuZXhwb3J0cy51bnNoYXJwIHx8IGluc3RhbmNlLmV4cG9ydHMuX3Vuc2hhcnA7XG4gIGZuKGltZ19vZmZzZXQsIGltZ19vZmZzZXQsIGhzdl9vZmZzZXQsIGJsdXJfb2Zmc2V0LCB3aWR0aCwgaGVpZ2h0LCBhbW91bnQsIHRocmVzaG9sZCk7IC8vIDMyLWJpdCBjb3B5IGlzIG11Y2ggZmFzdGVyIGluIGNocm9tZVxuXG4gIGltZzMyLnNldChuZXcgVWludDMyQXJyYXkodGhpcy5fX21lbW9yeS5idWZmZXIsIDAsIHBpeGVscykpO1xufTtcblxufSx7fV0sMTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gVGhpcyBpcyBhdXRvZ2VuZXJhdGVkIGZpbGUgZnJvbSBtYXRoLndhc20sIGRvbid0IGVkaXQuXG4vL1xuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9ICdBR0Z6YlFFQUFBQUFEQVprZVd4cGJtc0FBQUFBQUFFMEIyQUFBR0FFZjM5L2Z3QmdCbjkvZjM5L2Z3QmdDSDkvZjM5L2YzOS9BR0FJZjM5L2YzOS9mMzBBWUFKOWZ3QmdBWHdCZkFJWkFnTmxibllEWlhod0FBWURaVzUyQm0xbGJXOXllUUlBQUFNSEJnQUZBZ1FCQXdZR0FYOEFRUUFMQjRvQkNCRmZYM2RoYzIxZlkyRnNiRjlqZEc5eWN3QUJGbDlmWW5WcGJHUmZaMkYxYzNOcFlXNWZZMjlsWm5NQUFnNWZYMmRoZFhOek1UWmZiR2x1WlFBRENtSnNkWEpOYjI1dk1UWUFCQWRvYzNaZmRqRTJBQVVIZFc1emFHRnljQUFHREY5ZlpITnZYMmhoYm1Sc1pRTUFHRjlmZDJGemJWOWhjSEJzZVY5a1lYUmhYM0psYkc5amN3QUJDc1VNQmdNQUFRdldBUUVIZkNBQlJOdUd1a09DR3ZzL0lBQzdveUlDUkFBQUFBQUFBQURBb2hBQUlnVzJqRGdDRkNBQklBS2FFQUFpQXlBRG9DSUd0amdDRUNBQlJBQUFBQUFBQVBBL0lBT2hJZ1FnQktJZ0F5QUNJQUtnb2tRQUFBQUFBQUR3UDZBZ0JhR2pJZ1MyT0FJQUlBRWdCU0FFbXFJaUI3WTRBZ3dnQVNBRElBSkVBQUFBQUFBQThEK2dJQVNpb2lJSXRqZ0NDQ0FCSUFNZ0FrUUFBQUFBQUFEd3Y2QWdCS0tpSWdLMk9BSUVJQUVnQnlBSW9DQUZSQUFBQUFBQUFQQS9JQWFob0NJRG83WTRBaHdnQVNBRUlBS2dJQU9qdGpnQ0dBdUdCUU1HZndsOEFuMGdBeW9DRENFVklBTXFBZ2doRmlBREtnSVV1eUVSSUFNcUFoQzdJUkFDUUNBRVFRRnJJZ2hCQUVnaUNRUkFJQUloQnlBQUlRWU1BUXNnQWlBQUx3RUF1Q0lQSUFNcUFoaTdvaUlNSUJHaUlnMGdEQ0FRb2lBUElBTXFBZ1M3SWhPaUloUWdBeW9DQUxzaUVpQVBvcUNnb0NJT3RqZ0NBQ0FDUVFScUlRY2dBRUVDYWlFR0lBaEZEUUFnQ0VFQklBaEJBVWdiSWdwQmYzTWhDd0ovSUFRZ0NtdEJBWEZGQkVBZ0RpRU5JQWdNQVFzZ0FpQU5JQTRnRUtJZ0ZDQVNJQUF2QVFLNElnK2lvS0NnSWcyMk9BSUVJQUpCQ0dvaEJ5QUFRUVJxSVFZZ0RpRU1JQVJCQW1zTElRSWdDMEVBSUFSclJnMEFBMEFnQnlBTUlCR2lJQTBnRUtJZ0R5QVRvaUFTSUFZdkFRQzRJZzZpb0tDZ0lneTJPQUlBSUFjZ0RTQVJvaUFNSUJDaUlBNGdFNklnRWlBR0x3RUN1Q0lQb3FDZ29DSU50amdDQkNBSFFRaHFJUWNnQmtFRWFpRUdJQUpCQWtvaEFDQUNRUUpySVFJZ0FBMEFDd3NDUUNBSkRRQWdBU0FGSUFoc1FRRjBhaUlBQW44Z0JrRUNheThCQUNJQ3VDSU5JQlc3SWhLaUlBMGdGcnNpRTZLZ0lBMGdBeW9DSEx1aUlnd2dFS0tnSUF3Z0VhS2dJZzhnQjBFRWF5SUhLZ0lBdTZBaURrUUFBQUFBQUFEd1FXTWdEa1FBQUFBQUFBQUFBR1p4QkVBZ0Rxc01BUXRCQUFzN0FRQWdDRVVOQUNBR1FRUnJJUVpCQUNBRmEwRUJkQ0VCQTBBQ2Z5QU5JQktpSUFKQi8vOERjYmdpRFNBVG9xQWdEeUlPSUJDaW9DQU1JQkdpb0NJUElBZEJCR3NpQnlvQ0FMdWdJZ3hFQUFBQUFBQUE4RUZqSUF4RUFBQUFBQUFBQUFCbWNRUkFJQXlyREFFTFFRQUxJUU1nQmk4QkFDRUNJQUFnQVdvaUFDQURPd0VBSUFaQkFtc2hCaUFJUVFGS0lRTWdEaUVNSUFoQkFXc2hDQ0FERFFBTEN3dlJBZ0lCZndkOEFrQWdCME1BQUFBQVd3MEFJQVJFMjRhNlE0SWErejhnQjBNQUFBQS9sN3VqSWdsRUFBQUFBQUFBQU1DaUVBQWlETGFNT0FJVUlBUWdDWm9RQUNJS0lBcWdJZzIyT0FJUUlBUkVBQUFBQUFBQThEOGdDcUVpQ3lBTG9pQUtJQWtnQ2FDaVJBQUFBQUFBQVBBL29DQU1vYU1pQzdZNEFnQWdCQ0FNSUF1YW9pSU90amdDRENBRUlBb2dDVVFBQUFBQUFBRHdQNkFnQzZLaUlnKzJPQUlJSUFRZ0NpQUpSQUFBQUFBQUFQQy9vQ0FMb3FJaUNiWTRBZ1FnQkNBT0lBK2dJQXhFQUFBQUFBQUE4RDhnRGFHZ0lncWp0amdDSENBRUlBc2dDYUFnQ3FPMk9BSVlJQVlFUUFOQUlBQWdCU0FJYkVFQmRHb2dBaUFJUVFGMGFpQURJQVFnQlNBR0VBTWdDRUVCYWlJSUlBWkhEUUFMQ3lBRlJRMEFRUUFoQ0FOQUlBSWdCaUFJYkVFQmRHb2dBU0FJUVFGMGFpQURJQVFnQmlBRkVBTWdDRUVCYWlJSUlBVkhEUUFMQ3d0eEFRTi9JQUlnQTJ3aUJRUkFBMEFnQVNBQUtBSUFJZ1JCRUhaQi93RnhJZ0lnQWlBRVFRaDJRZjhCY1NJRElBTWdCRUgvQVhFaUJFa2JJQUlnQTBzYklnWWdCaUFFSUFJZ0JFc2JJQU1nQkVzYlFRaDBPd0VBSUFGQkFtb2hBU0FBUVFScUlRQWdCVUVCYXlJRkRRQUxDd3VaQWdJRGZ3RjhJQVFnQld3aEJBSi9JQWF6UXdBQWdFV1VRd0FBeUVLVnUwUUFBQUFBQUFEZ1A2QWlDNWxFQUFBQUFBQUE0RUZqQkVBZ0M2b01BUXRCZ0lDQWdIZ0xJUVVnQkFSQUlBZEJDSFFoQ1VFQUlRWURRQ0FKSUFJZ0JrRUJkQ0lIYWk4QkFDSUJJQU1nQjJvdkFRQnJJZ2NnQjBFZmRTSUlhaUFJYzAwRVFDQUFJQVpCQW5RaUNHb2lDaUFGSUFkc1FZQVFha0VNZFNBQmFpSUhRWUQrQXlBSFFZRCtBMGdiSWdkQkFDQUhRUUJLRzBFTWRDQUJRUUVnQVJ0dUlnRWdDaTBBQUd4QmdCQnFRUXgyT2dBQUlBQWdDRUVCY21vaUJ5QUJJQWN0QUFCc1FZQVFha0VNZGpvQUFDQUFJQWhCQW5KcUlnY2dBU0FITFFBQWJFR0FFR3BCREhZNkFBQUxJQVpCQVdvaUJpQUVSdzBBQ3dzTCc7XG5cbn0se31dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEdDX0lOVEVSVkFMID0gMTAwO1xuXG5mdW5jdGlvbiBQb29sKGNyZWF0ZSwgaWRsZSkge1xuICB0aGlzLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgdGhpcy5hdmFpbGFibGUgPSBbXTtcbiAgdGhpcy5hY3F1aXJlZCA9IHt9O1xuICB0aGlzLmxhc3RJZCA9IDE7XG4gIHRoaXMudGltZW91dElkID0gMDtcbiAgdGhpcy5pZGxlID0gaWRsZSB8fCAyMDAwO1xufVxuXG5Qb29sLnByb3RvdHlwZS5hY3F1aXJlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZXNvdXJjZTtcblxuICBpZiAodGhpcy5hdmFpbGFibGUubGVuZ3RoICE9PSAwKSB7XG4gICAgcmVzb3VyY2UgPSB0aGlzLmF2YWlsYWJsZS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICByZXNvdXJjZSA9IHRoaXMuY3JlYXRlKCk7XG4gICAgcmVzb3VyY2UuaWQgPSB0aGlzLmxhc3RJZCsrO1xuXG4gICAgcmVzb3VyY2UucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5yZWxlYXNlKHJlc291cmNlKTtcbiAgICB9O1xuICB9XG5cbiAgdGhpcy5hY3F1aXJlZFtyZXNvdXJjZS5pZF0gPSByZXNvdXJjZTtcbiAgcmV0dXJuIHJlc291cmNlO1xufTtcblxuUG9vbC5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uIChyZXNvdXJjZSkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBkZWxldGUgdGhpcy5hY3F1aXJlZFtyZXNvdXJjZS5pZF07XG4gIHJlc291cmNlLmxhc3RVc2VkID0gRGF0ZS5ub3coKTtcbiAgdGhpcy5hdmFpbGFibGUucHVzaChyZXNvdXJjZSk7XG5cbiAgaWYgKHRoaXMudGltZW91dElkID09PSAwKSB7XG4gICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpczIuZ2MoKTtcbiAgICB9LCBHQ19JTlRFUlZBTCk7XG4gIH1cbn07XG5cblBvb2wucHJvdG90eXBlLmdjID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXMzID0gdGhpcztcblxuICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgdGhpcy5hdmFpbGFibGUgPSB0aGlzLmF2YWlsYWJsZS5maWx0ZXIoZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gICAgaWYgKG5vdyAtIHJlc291cmNlLmxhc3RVc2VkID4gX3RoaXMzLmlkbGUpIHtcbiAgICAgIHJlc291cmNlLmRlc3Ryb3koKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgaWYgKHRoaXMuYXZhaWxhYmxlLmxlbmd0aCAhPT0gMCkge1xuICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMzLmdjKCk7XG4gICAgfSwgR0NfSU5URVJWQUwpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudGltZW91dElkID0gMDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sO1xuXG59LHt9XSwxNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBBZGQgaW50ZXJtZWRpYXRlIHJlc2l6aW5nIHN0ZXBzIHdoZW4gc2NhbGluZyBkb3duIGJ5IGEgdmVyeSBsYXJnZSBmYWN0b3IuXG4vL1xuLy8gRm9yIGV4YW1wbGUsIHdoZW4gcmVzaXppbmcgMTAwMDB4MTAwMDAgZG93biB0byAxMHgxMCwgaXQnbGwgcmVzaXplIGl0IHRvXG4vLyAzMDB4MzAwIGZpcnN0LlxuLy9cbi8vIEl0J3MgbmVlZGVkIGJlY2F1c2UgdGlsZXIgaGFzIGlzc3VlcyB3aGVuIHRoZSBlbnRpcmUgdGlsZSBpcyBzY2FsZWQgZG93blxuLy8gdG8gYSBmZXcgcGl4ZWxzICgxMDI0cHggc291cmNlIHRpbGUgd2l0aCBib3JkZXIgc2l6ZSAzIHNob3VsZCByZXN1bHQgaW5cbi8vIGF0IGxlYXN0IDMrMysyID0gOHB4IHRhcmdldCB0aWxlLCBzbyBtYXggc2NhbGUgZmFjdG9yIGlzIDEyOCBoZXJlKS5cbi8vXG4vLyBBbHNvLCBhZGRpbmcgaW50ZXJtZWRpYXRlIHN0ZXBzIGNhbiBzcGVlZCB1cCBwcm9jZXNzaW5nIGlmIHdlIHVzZSBsb3dlclxuLy8gcXVhbGl0eSBhbGdvcml0aG1zIGZvciBmaXJzdCBzdGFnZXMuXG4vL1xuJ3VzZSBzdHJpY3QnOyAvLyBtaW4gc2l6ZSA9IDAgcmVzdWx0cyBpbiBpbmZpbml0ZSBsb29wLFxuLy8gbWluIHNpemUgPSAxIGNhbiBjb25zdW1lIGxhcmdlIGFtb3VudCBvZiBtZW1vcnlcblxudmFyIE1JTl9JTk5FUl9USUxFX1NJWkUgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZVN0YWdlcyhmcm9tV2lkdGgsIGZyb21IZWlnaHQsIHRvV2lkdGgsIHRvSGVpZ2h0LCBzcmNUaWxlU2l6ZSwgZGVzdFRpbGVCb3JkZXIpIHtcbiAgdmFyIHNjYWxlWCA9IHRvV2lkdGggLyBmcm9tV2lkdGg7XG4gIHZhciBzY2FsZVkgPSB0b0hlaWdodCAvIGZyb21IZWlnaHQ7IC8vIGRlcml2ZWQgZnJvbSBjcmVhdGVSZWdpb25zIGVxdWF0aW9uOlxuICAvLyBpbm5lclRpbGVXaWR0aCA9IHBpeGVsRmxvb3Ioc3JjVGlsZVNpemUgKiBzY2FsZVgpIC0gMiAqIGRlc3RUaWxlQm9yZGVyO1xuXG4gIHZhciBtaW5TY2FsZSA9ICgyICogZGVzdFRpbGVCb3JkZXIgKyBNSU5fSU5ORVJfVElMRV9TSVpFICsgMSkgLyBzcmNUaWxlU2l6ZTsgLy8gcmVmdXNlIHRvIHNjYWxlIGltYWdlIG11bHRpcGxlIHRpbWVzIGJ5IGxlc3MgdGhhbiB0d2ljZSBlYWNoIHRpbWUsXG4gIC8vIGl0IGNvdWxkIG9ubHkgaGFwcGVuIGJlY2F1c2Ugb2YgaW52YWxpZCBvcHRpb25zXG5cbiAgaWYgKG1pblNjYWxlID4gMC41KSByZXR1cm4gW1t0b1dpZHRoLCB0b0hlaWdodF1dO1xuICB2YXIgc3RhZ2VDb3VudCA9IE1hdGguY2VpbChNYXRoLmxvZyhNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSkpIC8gTWF0aC5sb2cobWluU2NhbGUpKTsgLy8gbm8gYWRkaXRpb25hbCByZXNpemVzIGFyZSBuZWNlc3NhcnksXG4gIC8vIHN0YWdlQ291bnQgY2FuIGJlIHplcm8gb3IgYmUgbmVnYXRpdmUgd2hlbiBlbmxhcmdpbmcgdGhlIGltYWdlXG5cbiAgaWYgKHN0YWdlQ291bnQgPD0gMSkgcmV0dXJuIFtbdG9XaWR0aCwgdG9IZWlnaHRdXTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhZ2VDb3VudDsgaSsrKSB7XG4gICAgdmFyIHdpZHRoID0gTWF0aC5yb3VuZChNYXRoLnBvdyhNYXRoLnBvdyhmcm9tV2lkdGgsIHN0YWdlQ291bnQgLSBpIC0gMSkgKiBNYXRoLnBvdyh0b1dpZHRoLCBpICsgMSksIDEgLyBzdGFnZUNvdW50KSk7XG4gICAgdmFyIGhlaWdodCA9IE1hdGgucm91bmQoTWF0aC5wb3coTWF0aC5wb3coZnJvbUhlaWdodCwgc3RhZ2VDb3VudCAtIGkgLSAxKSAqIE1hdGgucG93KHRvSGVpZ2h0LCBpICsgMSksIDEgLyBzdGFnZUNvdW50KSk7XG4gICAgcmVzdWx0LnB1c2goW3dpZHRoLCBoZWlnaHRdKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG59LHt9XSwxNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBTcGxpdCBvcmlnaW5hbCBpbWFnZSBpbnRvIG11bHRpcGxlIDEwMjR4MTAyNCBjaHVua3MgdG8gcmVkdWNlIG1lbW9yeSB1c2FnZVxuLy8gKGltYWdlcyBoYXZlIHRvIGJlIHVucGFja2VkIGludG8gdHlwZWQgYXJyYXlzIGZvciByZXNpemluZykgYW5kIGFsbG93XG4vLyBwYXJhbGxlbCBwcm9jZXNzaW5nIG9mIG11bHRpcGxlIHRpbGVzIGF0IGEgdGltZS5cbi8vXG4ndXNlIHN0cmljdCc7XG4vKlxuICogcGl4ZWxGbG9vciBhbmQgcGl4ZWxDZWlsIGFyZSBtb2RpZmllZCB2ZXJzaW9ucyBvZiBNYXRoLmZsb29yIGFuZCBNYXRoLmNlaWxcbiAqIGZ1bmN0aW9ucyB3aGljaCB0YWtlIGludG8gYWNjb3VudCBmbG9hdGluZyBwb2ludCBhcml0aG1ldGljIGVycm9ycy5cbiAqIFRob3NlIGVycm9ycyBjYW4gY2F1c2UgdW5kZXNpcmVkIGluY3JlbWVudHMvZGVjcmVtZW50cyBvZiBzaXplcyBhbmQgb2Zmc2V0czpcbiAqIE1hdGguY2VpbCgzNiAvICgzNiAvIDUwMCkpID0gNTAxXG4gKiBwaXhlbENlaWwoMzYgLyAoMzYgLyA1MDApKSA9IDUwMFxuICovXG5cbnZhciBQSVhFTF9FUFNJTE9OID0gMWUtNTtcblxuZnVuY3Rpb24gcGl4ZWxGbG9vcih4KSB7XG4gIHZhciBuZWFyZXN0ID0gTWF0aC5yb3VuZCh4KTtcblxuICBpZiAoTWF0aC5hYnMoeCAtIG5lYXJlc3QpIDwgUElYRUxfRVBTSUxPTikge1xuICAgIHJldHVybiBuZWFyZXN0O1xuICB9XG5cbiAgcmV0dXJuIE1hdGguZmxvb3IoeCk7XG59XG5cbmZ1bmN0aW9uIHBpeGVsQ2VpbCh4KSB7XG4gIHZhciBuZWFyZXN0ID0gTWF0aC5yb3VuZCh4KTtcblxuICBpZiAoTWF0aC5hYnMoeCAtIG5lYXJlc3QpIDwgUElYRUxfRVBTSUxPTikge1xuICAgIHJldHVybiBuZWFyZXN0O1xuICB9XG5cbiAgcmV0dXJuIE1hdGguY2VpbCh4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVSZWdpb25zKG9wdGlvbnMpIHtcbiAgdmFyIHNjYWxlWCA9IG9wdGlvbnMudG9XaWR0aCAvIG9wdGlvbnMud2lkdGg7XG4gIHZhciBzY2FsZVkgPSBvcHRpb25zLnRvSGVpZ2h0IC8gb3B0aW9ucy5oZWlnaHQ7XG4gIHZhciBpbm5lclRpbGVXaWR0aCA9IHBpeGVsRmxvb3Iob3B0aW9ucy5zcmNUaWxlU2l6ZSAqIHNjYWxlWCkgLSAyICogb3B0aW9ucy5kZXN0VGlsZUJvcmRlcjtcbiAgdmFyIGlubmVyVGlsZUhlaWdodCA9IHBpeGVsRmxvb3Iob3B0aW9ucy5zcmNUaWxlU2l6ZSAqIHNjYWxlWSkgLSAyICogb3B0aW9ucy5kZXN0VGlsZUJvcmRlcjsgLy8gcHJldmVudCBpbmZpbml0ZSBsb29wLCB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW5cblxuICBpZiAoaW5uZXJUaWxlV2lkdGggPCAxIHx8IGlubmVyVGlsZUhlaWdodCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIGVycm9yIGluIHBpY2E6IHRhcmdldCB0aWxlIHdpZHRoL2hlaWdodCBpcyB0b28gc21hbGwuJyk7XG4gIH1cblxuICB2YXIgeCwgeTtcbiAgdmFyIGlubmVyWCwgaW5uZXJZLCB0b1RpbGVXaWR0aCwgdG9UaWxlSGVpZ2h0O1xuICB2YXIgdGlsZXMgPSBbXTtcbiAgdmFyIHRpbGU7IC8vIHdlIGdvIHRvcC10by1kb3duIGluc3RlYWQgb2YgbGVmdC10by1yaWdodCB0byBtYWtlIGltYWdlIGRpc3BsYXllZCBmcm9tIHRvcCB0b1xuICAvLyBkb2VzbiBpbiB0aGUgYnJvd3NlclxuXG4gIGZvciAoaW5uZXJZID0gMDsgaW5uZXJZIDwgb3B0aW9ucy50b0hlaWdodDsgaW5uZXJZICs9IGlubmVyVGlsZUhlaWdodCkge1xuICAgIGZvciAoaW5uZXJYID0gMDsgaW5uZXJYIDwgb3B0aW9ucy50b1dpZHRoOyBpbm5lclggKz0gaW5uZXJUaWxlV2lkdGgpIHtcbiAgICAgIHggPSBpbm5lclggLSBvcHRpb25zLmRlc3RUaWxlQm9yZGVyO1xuXG4gICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgeCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRvVGlsZVdpZHRoID0gaW5uZXJYICsgaW5uZXJUaWxlV2lkdGggKyBvcHRpb25zLmRlc3RUaWxlQm9yZGVyIC0geDtcblxuICAgICAgaWYgKHggKyB0b1RpbGVXaWR0aCA+PSBvcHRpb25zLnRvV2lkdGgpIHtcbiAgICAgICAgdG9UaWxlV2lkdGggPSBvcHRpb25zLnRvV2lkdGggLSB4O1xuICAgICAgfVxuXG4gICAgICB5ID0gaW5uZXJZIC0gb3B0aW9ucy5kZXN0VGlsZUJvcmRlcjtcblxuICAgICAgaWYgKHkgPCAwKSB7XG4gICAgICAgIHkgPSAwO1xuICAgICAgfVxuXG4gICAgICB0b1RpbGVIZWlnaHQgPSBpbm5lclkgKyBpbm5lclRpbGVIZWlnaHQgKyBvcHRpb25zLmRlc3RUaWxlQm9yZGVyIC0geTtcblxuICAgICAgaWYgKHkgKyB0b1RpbGVIZWlnaHQgPj0gb3B0aW9ucy50b0hlaWdodCkge1xuICAgICAgICB0b1RpbGVIZWlnaHQgPSBvcHRpb25zLnRvSGVpZ2h0IC0geTtcbiAgICAgIH1cblxuICAgICAgdGlsZSA9IHtcbiAgICAgICAgdG9YOiB4LFxuICAgICAgICB0b1k6IHksXG4gICAgICAgIHRvV2lkdGg6IHRvVGlsZVdpZHRoLFxuICAgICAgICB0b0hlaWdodDogdG9UaWxlSGVpZ2h0LFxuICAgICAgICB0b0lubmVyWDogaW5uZXJYLFxuICAgICAgICB0b0lubmVyWTogaW5uZXJZLFxuICAgICAgICB0b0lubmVyV2lkdGg6IGlubmVyVGlsZVdpZHRoLFxuICAgICAgICB0b0lubmVySGVpZ2h0OiBpbm5lclRpbGVIZWlnaHQsXG4gICAgICAgIG9mZnNldFg6IHggLyBzY2FsZVggLSBwaXhlbEZsb29yKHggLyBzY2FsZVgpLFxuICAgICAgICBvZmZzZXRZOiB5IC8gc2NhbGVZIC0gcGl4ZWxGbG9vcih5IC8gc2NhbGVZKSxcbiAgICAgICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgICAgIHNjYWxlWTogc2NhbGVZLFxuICAgICAgICB4OiBwaXhlbEZsb29yKHggLyBzY2FsZVgpLFxuICAgICAgICB5OiBwaXhlbEZsb29yKHkgLyBzY2FsZVkpLFxuICAgICAgICB3aWR0aDogcGl4ZWxDZWlsKHRvVGlsZVdpZHRoIC8gc2NhbGVYKSxcbiAgICAgICAgaGVpZ2h0OiBwaXhlbENlaWwodG9UaWxlSGVpZ2h0IC8gc2NhbGVZKVxuICAgICAgfTtcbiAgICAgIHRpbGVzLnB1c2godGlsZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRpbGVzO1xufTtcblxufSx7fV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvYmpDbGFzcyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5pc0NhbnZhcyA9IGZ1bmN0aW9uIGlzQ2FudmFzKGVsZW1lbnQpIHtcbiAgdmFyIGNuYW1lID0gb2JqQ2xhc3MoZWxlbWVudCk7XG4gIHJldHVybiBjbmFtZSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJ1xuICAvKiBicm93c2VyICovXG4gIHx8IGNuYW1lID09PSAnW29iamVjdCBPZmZzY3JlZW5DYW52YXNdJyB8fCBjbmFtZSA9PT0gJ1tvYmplY3QgQ2FudmFzXSdcbiAgLyogbm9kZS1jYW52YXMgKi9cbiAgO1xufTtcblxubW9kdWxlLmV4cG9ydHMuaXNJbWFnZSA9IGZ1bmN0aW9uIGlzSW1hZ2UoZWxlbWVudCkge1xuICByZXR1cm4gb2JqQ2xhc3MoZWxlbWVudCkgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJztcbn07XG5cbm1vZHVsZS5leHBvcnRzLmlzSW1hZ2VCaXRtYXAgPSBmdW5jdGlvbiBpc0ltYWdlQml0bWFwKGVsZW1lbnQpIHtcbiAgcmV0dXJuIG9iakNsYXNzKGVsZW1lbnQpID09PSAnW29iamVjdCBJbWFnZUJpdG1hcF0nO1xufTtcblxubW9kdWxlLmV4cG9ydHMubGltaXRlciA9IGZ1bmN0aW9uIGxpbWl0ZXIoY29uY3VycmVuY3kpIHtcbiAgdmFyIGFjdGl2ZSA9IDAsXG4gICAgICBxdWV1ZSA9IFtdO1xuXG4gIGZ1bmN0aW9uIHJvbGwoKSB7XG4gICAgaWYgKGFjdGl2ZSA8IGNvbmN1cnJlbmN5ICYmIHF1ZXVlLmxlbmd0aCkge1xuICAgICAgYWN0aXZlKys7XG4gICAgICBxdWV1ZS5zaGlmdCgpKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0KGZuKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICBmbigpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICBhY3RpdmUtLTtcbiAgICAgICAgICByb2xsKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICBhY3RpdmUtLTtcbiAgICAgICAgICByb2xsKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByb2xsKCk7XG4gICAgfSk7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jaWJfcXVhbGl0eV9uYW1lID0gZnVuY3Rpb24gY2liX3F1YWxpdHlfbmFtZShudW0pIHtcbiAgc3dpdGNoIChudW0pIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gJ3BpeGVsYXRlZCc7XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gJ2xvdyc7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gJ21lZGl1bSc7XG4gIH1cblxuICByZXR1cm4gJ2hpZ2gnO1xufTtcblxubW9kdWxlLmV4cG9ydHMuY2liX3N1cHBvcnQgPSBmdW5jdGlvbiBjaWJfc3VwcG9ydChjcmVhdGVDYW52YXMpIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGMgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChjLCAwLCAwLCAxMDAsIDEwMCwge1xuICAgICAgcmVzaXplV2lkdGg6IDEwLFxuICAgICAgcmVzaXplSGVpZ2h0OiAxMCxcbiAgICAgIHJlc2l6ZVF1YWxpdHk6ICdoaWdoJ1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGJpdG1hcCkge1xuICAgICAgdmFyIHN0YXR1cyA9IGJpdG1hcC53aWR0aCA9PT0gMTA7IC8vIEJyYW5jaCBiZWxvdyBpcyBmaWx0ZXJlZCBvbiB1cHBlciBsZXZlbC4gV2UgZG8gbm90IGNhbGwgcmVzaXplXG4gICAgICAvLyBkZXRlY3Rpb24gZm9yIGJhc2ljIEltYWdlQml0bWFwLlxuICAgICAgLy9cbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JbWFnZUJpdG1hcFxuICAgICAgLy8gb2xkIENyb21lIDUxIGhhcyBJbWFnZUJpdG1hcCB3aXRob3V0IC5jbG9zZSgpLiBUaGVuIHRoaXMgY29kZVxuICAgICAgLy8gd2lsbCB0aHJvdyBhbmQgcmV0dXJuICdmYWxzZScgYXMgZXhwZWN0ZWQuXG4gICAgICAvL1xuXG4gICAgICBiaXRtYXAuY2xvc2UoKTtcbiAgICAgIGMgPSBudWxsO1xuICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9KTtcbiAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLndvcmtlcl9vZmZzY3JlZW5fY2FudmFzX3N1cHBvcnQgPSBmdW5jdGlvbiB3b3JrZXJfb2Zmc2NyZWVuX2NhbnZhc19zdXBwb3J0KCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gaWYgT2Zmc2NyZWVuQ2FudmFzIGlzIHByZXNlbnQsIHdlIGFzc3VtZSBicm93c2VyIHN1cHBvcnRzIFdvcmtlciBhbmQgYnVpbHQtaW4gUHJvbWlzZSBhcyB3ZWxsXG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3b3JrZXJQYXlsb2FkKHNlbGYpIHtcbiAgICAgIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygxMCwgMTApOyAvLyB0ZXN0IHRoYXQgMmQgY29udGV4dCBjYW4gYmUgdXNlZCBpbiB3b3JrZXJcblxuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5yZWN0KDAsIDAsIDEsIDEpOyAvLyB0ZXN0IHRoYXQgY2liIGNhbiBiZSB1c2VkIHRvIHJldHVybiBpbWFnZSBiaXRtYXAgZnJvbSB3b3JrZXJcblxuICAgICAgICByZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAoY2FudmFzLCAwLCAwLCAxLCAxKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5wb3N0TWVzc2FnZSh0cnVlKTtcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYucG9zdE1lc3NhZ2UoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGNvZGUgPSBidG9hKFwiKFwiLmNvbmNhdCh3b3JrZXJQYXlsb2FkLnRvU3RyaW5nKCksIFwiKShzZWxmKTtcIikpO1xuICAgIHZhciB3ID0gbmV3IFdvcmtlcihcImRhdGE6dGV4dC9qYXZhc2NyaXB0O2Jhc2U2NCxcIi5jb25jYXQoY29kZSkpO1xuXG4gICAgdy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKGV2LmRhdGEpO1xuICAgIH07XG5cbiAgICB3Lm9uZXJyb3IgPSByZWplY3Q7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufTsgLy8gQ2hlY2sgaWYgY2FudmFzLmdldENvbnRleHQoJzJkJykuZ2V0SW1hZ2VEYXRhIGNhbiBiZSB1c2VkLFxuLy8gRmlyZUZveCByYW5kb21pemVzIHRoZSBvdXRwdXQgb2YgdGhhdCBmdW5jdGlvbiBpbiBgcHJpdmFjeS5yZXNpc3RGaW5nZXJwcmludGluZ2AgbW9kZVxuXG5cbm1vZHVsZS5leHBvcnRzLmNhbl91c2VfY2FudmFzID0gZnVuY3Rpb24gY2FuX3VzZV9jYW52YXMoY3JlYXRlQ2FudmFzKSB7XG4gIHZhciB1c2FibGUgPSBmYWxzZTtcblxuICB0cnkge1xuICAgIHZhciBjYW52YXMgPSBjcmVhdGVDYW52YXMoMiwgMSk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBkID0gY3R4LmNyZWF0ZUltYWdlRGF0YSgyLCAxKTtcbiAgICBkLmRhdGFbMF0gPSAxMjtcbiAgICBkLmRhdGFbMV0gPSAyMztcbiAgICBkLmRhdGFbMl0gPSAzNDtcbiAgICBkLmRhdGFbM10gPSAyNTU7XG4gICAgZC5kYXRhWzRdID0gNDU7XG4gICAgZC5kYXRhWzVdID0gNTY7XG4gICAgZC5kYXRhWzZdID0gNjc7XG4gICAgZC5kYXRhWzddID0gMjU1O1xuICAgIGN0eC5wdXRJbWFnZURhdGEoZCwgMCwgMCk7XG4gICAgZCA9IG51bGw7XG4gICAgZCA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMiwgMSk7XG5cbiAgICBpZiAoZC5kYXRhWzBdID09PSAxMiAmJiBkLmRhdGFbMV0gPT09IDIzICYmIGQuZGF0YVsyXSA9PT0gMzQgJiYgZC5kYXRhWzNdID09PSAyNTUgJiYgZC5kYXRhWzRdID09PSA0NSAmJiBkLmRhdGFbNV0gPT09IDU2ICYmIGQuZGF0YVs2XSA9PT0gNjcgJiYgZC5kYXRhWzddID09PSAyNTUpIHtcbiAgICAgIHVzYWJsZSA9IHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgcmV0dXJuIHVzYWJsZTtcbn07IC8vIENoZWNrIGlmIGNyZWF0ZUltYWdlQml0bWFwKGltZywgc3gsIHN5LCBzdywgc2gpIHNpZ25hdHVyZSB3b3JrcyBjb3JyZWN0bHlcbi8vIHdpdGggSlBFRyBpbWFnZXMgb3JpZW50ZWQgd2l0aCBFeGlmO1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTIyMDY3MVxuLy8gVE9ETzogcmVtb3ZlIGFmdGVyIGl0J3MgZml4ZWQgaW4gY2hyb21lIGZvciBhdCBsZWFzdCAyIHJlbGVhc2VzXG5cblxubW9kdWxlLmV4cG9ydHMuY2liX2Nhbl91c2VfcmVnaW9uID0gZnVuY3Rpb24gY2liX2Nhbl91c2VfcmVnaW9uKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAvLyBgSW1hZ2VgIGNoZWNrIHJlcXVpcmVkIGZvciB1c2UgaW4gYFNlcnZpY2VXb3JrZXJgXG4gICAgaWYgKHR5cGVvZiBJbWFnZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgaW1hZ2Uuc3JjID0gJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsJyArICcvOWovNFFCaVJYaHBaZ0FBVFUwQUtnQUFBQWdBQlFFU0FBTUFBQUFCQUFZQUFBRWFBQVVBQUFBQkFBQUFTZ0ViQUFVQUEnICsgJ0FBQkFBQUFVZ0VvQUFNQUFBQUJBQUlBQUFJVEFBTUFBQUFCQUFFQUFBQUFBQUFBQUFCSUFBQUFBUUFBQUVnQUFBQUIvOScgKyAnc0FRd0FFQXdNRUF3TUVCQU1FQlFRRUJRWUtCd1lHQmdZTkNRb0lDZzhORUJBUERROE9FUk1ZRkJFU0Z4SU9EeFVjRlJjJyArICdaR1JzYkd4QVVIUjhkR2g4WUdoc2EvOXNBUXdFRUJRVUdCUVlNQndjTUdoRVBFUm9hR2hvYUdob2FHaG9hR2hvYUdob2EnICsgJ0dob2FHaG9hR2hvYUdob2FHaG9hR2hvYUdob2FHaG9hR2hvYUdob2FHaG9hLzhJQUVRZ0FBUUFDQXdFUkFBSVJBUU1SQScgKyAnZi9FQUJRQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFmL3hBQVVBUUVBQUFBQUFBQUFBQUFBQUFBQUFBQUEvOW9BREFNQkFBJyArICdJUUF4QUFBQUYvUC8vRUFCUVFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBRC8yZ0FJQVFFQUFRVUNmLy9FQUJRUkFRQUFBQUEnICsgJ0FBQUFBQUFBQUFBQUFBQUQvMmdBSUFRTUJBVDhCZi8vRUFCUVJBUUFBQUFBQUFBQUFBQUFBQUFBQUFBRC8yZ0FJQVFJQicgKyAnQVQ4QmYvL0VBQlFRQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUQvMmdBSUFRRUFCajhDZi8vRUFCUVFBUUFBQUFBQUFBQUFBJyArICdBQUFBQUFBQUFELzJnQUlBUUVBQVQ4aGYvL2FBQXdEQVFBQ0FBTUFBQUFRSC8vRUFCUVJBUUFBQUFBQUFBQUFBQUFBQUEnICsgJ0FBQUFELzJnQUlBUU1CQVQ4UWYvL0VBQlFSQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUQvMmdBSUFRSUJBVDhRZi8vRUFCUScgKyAnUUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFELzJnQUlBUUVBQVQ4UWYvL1onO1xuXG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpLnRoZW4oZnVuY3Rpb24gKGJpdG1hcCkge1xuICAgICAgICBpZiAoYml0bWFwLndpZHRoID09PSBpbWFnZS53aWR0aCAmJiBiaXRtYXAuaGVpZ2h0ID09PSBpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmUoZmFsc2UpO1xuICAgIH07XG4gIH0pO1xufTtcblxufSx7fV0sMTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gV2ViIFdvcmtlciB3cmFwcGVyIGZvciBpbWFnZSByZXNpemUgZnVuY3Rpb25cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBNYXRoTGliID0gX2RlcmVxXygnLi9tYXRobGliJyk7XG5cbiAgdmFyIG1hdGhMaWI7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5cbiAgb25tZXNzYWdlID0gZnVuY3Rpb24gb25tZXNzYWdlKGV2KSB7XG4gICAgdmFyIHRpbGVPcHRzID0gZXYuZGF0YS5vcHRzO1xuICAgIHZhciByZXR1cm5CaXRtYXAgPSBmYWxzZTtcblxuICAgIGlmICghdGlsZU9wdHMuc3JjICYmIHRpbGVPcHRzLnNyY0JpdG1hcCkge1xuICAgICAgdmFyIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXModGlsZU9wdHMud2lkdGgsIHRpbGVPcHRzLmhlaWdodCk7XG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguZHJhd0ltYWdlKHRpbGVPcHRzLnNyY0JpdG1hcCwgMCwgMCk7XG4gICAgICB0aWxlT3B0cy5zcmMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRpbGVPcHRzLndpZHRoLCB0aWxlT3B0cy5oZWlnaHQpLmRhdGE7XG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgIGNhbnZhcyA9IG51bGw7XG4gICAgICB0aWxlT3B0cy5zcmNCaXRtYXAuY2xvc2UoKTtcbiAgICAgIHRpbGVPcHRzLnNyY0JpdG1hcCA9IG51bGw7IC8vIFRlbXBvcmFyeSBmb3JjZSBvdXQgZGF0YSB0byB0eXBlZCBhcnJheSwgYmVjYXVzZSBDaHJvbWUgaGF2ZSBhcnRlZmFjdHNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGljYS9pc3N1ZXMvMjIzXG4gICAgICAvLyByZXR1cm5CaXRtYXAgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghbWF0aExpYikgbWF0aExpYiA9IG5ldyBNYXRoTGliKGV2LmRhdGEuZmVhdHVyZXMpOyAvLyBVc2UgbXVsdGltYXRoJ3Mgc3luYyBhdXRvLWluaXQuIEF2b2lkIFByb21pc2UgdXNlIGluIG9sZCBicm93c2VycyxcbiAgICAvLyBiZWNhdXNlIHBvbHlmaWxscyBhcmUgbm90IHByb3BhZ2F0ZWQgdG8gd2Vid29ya2VyLlxuXG4gICAgdmFyIGRhdGEgPSBtYXRoTGliLnJlc2l6ZUFuZFVuc2hhcnAodGlsZU9wdHMpO1xuXG4gICAgaWYgKHJldHVybkJpdG1hcCkge1xuICAgICAgdmFyIHRvSW1hZ2VEYXRhID0gbmV3IEltYWdlRGF0YShuZXcgVWludDhDbGFtcGVkQXJyYXkoZGF0YSksIHRpbGVPcHRzLnRvV2lkdGgsIHRpbGVPcHRzLnRvSGVpZ2h0KTtcblxuICAgICAgdmFyIF9jYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHRpbGVPcHRzLnRvV2lkdGgsIHRpbGVPcHRzLnRvSGVpZ2h0KTtcblxuICAgICAgdmFyIF9jdHggPSBfY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIF9jdHgucHV0SW1hZ2VEYXRhKHRvSW1hZ2VEYXRhLCAwLCAwKTtcblxuICAgICAgY3JlYXRlSW1hZ2VCaXRtYXAoX2NhbnZhcykudGhlbihmdW5jdGlvbiAoYml0bWFwKSB7XG4gICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBiaXRtYXA6IGJpdG1hcFxuICAgICAgICB9LCBbYml0bWFwXSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9LCBbZGF0YS5idWZmZXJdKTtcbiAgICB9XG4gIH07XG59O1xuXG59LHtcIi4vbWF0aGxpYlwiOjF9XSwxODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDYWxjdWxhdGUgR2F1c3NpYW4gYmx1ciBvZiBhbiBpbWFnZSB1c2luZyBJSVIgZmlsdGVyXG4vLyBUaGUgbWV0aG9kIGlzIHRha2VuIGZyb20gSW50ZWwncyB3aGl0ZSBwYXBlciBhbmQgY29kZSBleGFtcGxlIGF0dGFjaGVkIHRvIGl0OlxuLy8gaHR0cHM6Ly9zb2Z0d2FyZS5pbnRlbC5jb20vZW4tdXMvYXJ0aWNsZXMvaWlyLWdhdXNzaWFuLWJsdXItZmlsdGVyXG4vLyAtaW1wbGVtZW50YXRpb24tdXNpbmctaW50ZWwtYWR2YW5jZWQtdmVjdG9yLWV4dGVuc2lvbnNcblxudmFyIGEwLCBhMSwgYTIsIGEzLCBiMSwgYjIsIGxlZnRfY29ybmVyLCByaWdodF9jb3JuZXI7XG5cbmZ1bmN0aW9uIGdhdXNzQ29lZihzaWdtYSkge1xuICBpZiAoc2lnbWEgPCAwLjUpIHtcbiAgICBzaWdtYSA9IDAuNTtcbiAgfVxuXG4gIHZhciBhID0gTWF0aC5leHAoMC43MjYgKiAwLjcyNikgLyBzaWdtYSxcbiAgICAgIGcxID0gTWF0aC5leHAoLWEpLFxuICAgICAgZzIgPSBNYXRoLmV4cCgtMiAqIGEpLFxuICAgICAgayA9ICgxIC0gZzEpICogKDEgLSBnMSkgLyAoMSArIDIgKiBhICogZzEgLSBnMik7XG5cbiAgYTAgPSBrO1xuICBhMSA9IGsgKiAoYSAtIDEpICogZzE7XG4gIGEyID0gayAqIChhICsgMSkgKiBnMTtcbiAgYTMgPSAtayAqIGcyO1xuICBiMSA9IDIgKiBnMTtcbiAgYjIgPSAtZzI7XG4gIGxlZnRfY29ybmVyID0gKGEwICsgYTEpIC8gKDEgLSBiMSAtIGIyKTtcbiAgcmlnaHRfY29ybmVyID0gKGEyICsgYTMpIC8gKDEgLSBiMSAtIGIyKTtcblxuICAvLyBBdHRlbXB0IHRvIGZvcmNlIHR5cGUgdG8gRlAzMi5cbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWyBhMCwgYTEsIGEyLCBhMywgYjEsIGIyLCBsZWZ0X2Nvcm5lciwgcmlnaHRfY29ybmVyIF0pO1xufVxuXG5mdW5jdGlvbiBjb252b2x2ZU1vbm8xNihzcmMsIG91dCwgbGluZSwgY29lZmYsIHdpZHRoLCBoZWlnaHQpIHtcbiAgLy8gdGFrZXMgc3JjIGltYWdlIGFuZCB3cml0ZXMgdGhlIGJsdXJyZWQgYW5kIHRyYW5zcG9zZWQgcmVzdWx0IGludG8gb3V0XG5cbiAgdmFyIHByZXZfc3JjLCBjdXJyX3NyYywgY3Vycl9vdXQsIHByZXZfb3V0LCBwcmV2X3ByZXZfb3V0O1xuICB2YXIgc3JjX2luZGV4LCBvdXRfaW5kZXgsIGxpbmVfaW5kZXg7XG4gIHZhciBpLCBqO1xuICB2YXIgY29lZmZfYTAsIGNvZWZmX2ExLCBjb2VmZl9iMSwgY29lZmZfYjI7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgc3JjX2luZGV4ID0gaSAqIHdpZHRoO1xuICAgIG91dF9pbmRleCA9IGk7XG4gICAgbGluZV9pbmRleCA9IDA7XG5cbiAgICAvLyBsZWZ0IHRvIHJpZ2h0XG4gICAgcHJldl9zcmMgPSBzcmNbc3JjX2luZGV4XTtcbiAgICBwcmV2X3ByZXZfb3V0ID0gcHJldl9zcmMgKiBjb2VmZls2XTtcbiAgICBwcmV2X291dCA9IHByZXZfcHJldl9vdXQ7XG5cbiAgICBjb2VmZl9hMCA9IGNvZWZmWzBdO1xuICAgIGNvZWZmX2ExID0gY29lZmZbMV07XG4gICAgY29lZmZfYjEgPSBjb2VmZls0XTtcbiAgICBjb2VmZl9iMiA9IGNvZWZmWzVdO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgIGN1cnJfc3JjID0gc3JjW3NyY19pbmRleF07XG5cbiAgICAgIGN1cnJfb3V0ID0gY3Vycl9zcmMgKiBjb2VmZl9hMCArXG4gICAgICAgICAgICAgICAgIHByZXZfc3JjICogY29lZmZfYTEgK1xuICAgICAgICAgICAgICAgICBwcmV2X291dCAqIGNvZWZmX2IxICtcbiAgICAgICAgICAgICAgICAgcHJldl9wcmV2X291dCAqIGNvZWZmX2IyO1xuXG4gICAgICBwcmV2X3ByZXZfb3V0ID0gcHJldl9vdXQ7XG4gICAgICBwcmV2X291dCA9IGN1cnJfb3V0O1xuICAgICAgcHJldl9zcmMgPSBjdXJyX3NyYztcblxuICAgICAgbGluZVtsaW5lX2luZGV4XSA9IHByZXZfb3V0O1xuICAgICAgbGluZV9pbmRleCsrO1xuICAgICAgc3JjX2luZGV4Kys7XG4gICAgfVxuXG4gICAgc3JjX2luZGV4LS07XG4gICAgbGluZV9pbmRleC0tO1xuICAgIG91dF9pbmRleCArPSBoZWlnaHQgKiAod2lkdGggLSAxKTtcblxuICAgIC8vIHJpZ2h0IHRvIGxlZnRcbiAgICBwcmV2X3NyYyA9IHNyY1tzcmNfaW5kZXhdO1xuICAgIHByZXZfcHJldl9vdXQgPSBwcmV2X3NyYyAqIGNvZWZmWzddO1xuICAgIHByZXZfb3V0ID0gcHJldl9wcmV2X291dDtcbiAgICBjdXJyX3NyYyA9IHByZXZfc3JjO1xuXG4gICAgY29lZmZfYTAgPSBjb2VmZlsyXTtcbiAgICBjb2VmZl9hMSA9IGNvZWZmWzNdO1xuXG4gICAgZm9yIChqID0gd2lkdGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgY3Vycl9vdXQgPSBjdXJyX3NyYyAqIGNvZWZmX2EwICtcbiAgICAgICAgICAgICAgICAgcHJldl9zcmMgKiBjb2VmZl9hMSArXG4gICAgICAgICAgICAgICAgIHByZXZfb3V0ICogY29lZmZfYjEgK1xuICAgICAgICAgICAgICAgICBwcmV2X3ByZXZfb3V0ICogY29lZmZfYjI7XG5cbiAgICAgIHByZXZfcHJldl9vdXQgPSBwcmV2X291dDtcbiAgICAgIHByZXZfb3V0ID0gY3Vycl9vdXQ7XG5cbiAgICAgIHByZXZfc3JjID0gY3Vycl9zcmM7XG4gICAgICBjdXJyX3NyYyA9IHNyY1tzcmNfaW5kZXhdO1xuXG4gICAgICBvdXRbb3V0X2luZGV4XSA9IGxpbmVbbGluZV9pbmRleF0gKyBwcmV2X291dDtcblxuICAgICAgc3JjX2luZGV4LS07XG4gICAgICBsaW5lX2luZGV4LS07XG4gICAgICBvdXRfaW5kZXggLT0gaGVpZ2h0O1xuICAgIH1cbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGJsdXJNb25vMTYoc3JjLCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgLy8gUXVpY2sgZXhpdCBvbiB6ZXJvIHJhZGl1c1xuICBpZiAoIXJhZGl1cykgeyByZXR1cm47IH1cblxuICB2YXIgb3V0ICAgICAgPSBuZXcgVWludDE2QXJyYXkoc3JjLmxlbmd0aCksXG4gICAgICB0bXBfbGluZSA9IG5ldyBGbG9hdDMyQXJyYXkoTWF0aC5tYXgod2lkdGgsIGhlaWdodCkpO1xuXG4gIHZhciBjb2VmZiA9IGdhdXNzQ29lZihyYWRpdXMpO1xuXG4gIGNvbnZvbHZlTW9ubzE2KHNyYywgb3V0LCB0bXBfbGluZSwgY29lZmYsIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyk7XG4gIGNvbnZvbHZlTW9ubzE2KG91dCwgc3JjLCB0bXBfbGluZSwgY29lZmYsIGhlaWdodCwgd2lkdGgsIHJhZGl1cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmx1ck1vbm8xNjtcblxufSx7fV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhc3NpZ24gICAgICAgICA9IF9kZXJlcV8oJ29iamVjdC1hc3NpZ24nKTtcbnZhciBiYXNlNjRkZWNvZGUgICA9IF9kZXJlcV8oJy4vbGliL2Jhc2U2NGRlY29kZScpO1xudmFyIGhhc1dlYkFzc2VtYmx5ID0gX2RlcmVxXygnLi9saWIvd2FfZGV0ZWN0Jyk7XG5cblxudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAganM6IHRydWUsXG4gIHdhc206IHRydWVcbn07XG5cblxuZnVuY3Rpb24gTXVsdGlNYXRoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE11bHRpTWF0aCkpIHJldHVybiBuZXcgTXVsdGlNYXRoKG9wdGlvbnMpO1xuXG4gIHZhciBvcHRzID0gYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMgfHwge30pO1xuXG4gIHRoaXMub3B0aW9ucyAgICAgICAgID0gb3B0cztcblxuICB0aGlzLl9fY2FjaGUgICAgICAgICA9IHt9O1xuXG4gIHRoaXMuX19pbml0X3Byb21pc2UgID0gbnVsbDtcbiAgdGhpcy5fX21vZHVsZXMgICAgICAgPSBvcHRzLm1vZHVsZXMgfHwge307XG4gIHRoaXMuX19tZW1vcnkgICAgICAgID0gbnVsbDtcbiAgdGhpcy5fX3dhc20gICAgICAgICAgPSB7fTtcblxuICB0aGlzLl9faXNMRSA9ICgobmV3IFVpbnQzMkFycmF5KChuZXcgVWludDhBcnJheShbIDEsIDAsIDAsIDAgXSkpLmJ1ZmZlcikpWzBdID09PSAxKTtcblxuICBpZiAoIXRoaXMub3B0aW9ucy5qcyAmJiAhdGhpcy5vcHRpb25zLndhc20pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21hdGhsaWI6IGF0IGxlYXN0IFwianNcIiBvciBcIndhc21cIiBzaG91bGQgYmUgZW5hYmxlZCcpO1xuICB9XG59XG5cblxuTXVsdGlNYXRoLnByb3RvdHlwZS5oYXNfd2FzbSA9IGhhc1dlYkFzc2VtYmx5O1xuXG5cbk11bHRpTWF0aC5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKG1vZHVsZSkge1xuICB0aGlzLl9fbW9kdWxlc1ttb2R1bGUubmFtZV0gPSBtb2R1bGU7XG5cbiAgLy8gUGluIHRoZSBiZXN0IHBvc3NpYmxlIGltcGxlbWVudGF0aW9uXG4gIGlmICh0aGlzLm9wdGlvbnMud2FzbSAmJiB0aGlzLmhhc193YXNtKCkgJiYgbW9kdWxlLndhc21fZm4pIHtcbiAgICB0aGlzW21vZHVsZS5uYW1lXSA9IG1vZHVsZS53YXNtX2ZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXNbbW9kdWxlLm5hbWVdID0gbW9kdWxlLmZuO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbk11bHRpTWF0aC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX19pbml0X3Byb21pc2UpIHJldHVybiB0aGlzLl9faW5pdF9wcm9taXNlO1xuXG4gIGlmICghdGhpcy5vcHRpb25zLmpzICYmIHRoaXMub3B0aW9ucy53YXNtICYmICF0aGlzLmhhc193YXNtKCkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdtYXRobGliOiBvbmx5IFwid2FzbVwiIHdhcyBlbmFibGVkLCBidXQgaXRcXCdzIG5vdCBzdXBwb3J0ZWQnKSk7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5fX2luaXRfcHJvbWlzZSA9IFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHNlbGYuX19tb2R1bGVzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgbW9kdWxlID0gc2VsZi5fX21vZHVsZXNbbmFtZV07XG5cbiAgICBpZiAoIXNlbGYub3B0aW9ucy53YXNtIHx8ICFzZWxmLmhhc193YXNtKCkgfHwgIW1vZHVsZS53YXNtX2ZuKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIElmIGFscmVhZHkgY29tcGlsZWQgLSBleGl0XG4gICAgaWYgKHNlbGYuX193YXNtW25hbWVdKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIENvbXBpbGUgd2FzbSBzb3VyY2VcbiAgICByZXR1cm4gV2ViQXNzZW1ibHkuY29tcGlsZShzZWxmLl9fYmFzZTY0ZGVjb2RlKG1vZHVsZS53YXNtX3NyYykpXG4gICAgICAudGhlbihmdW5jdGlvbiAobSkgeyBzZWxmLl9fd2FzbVtuYW1lXSA9IG07IH0pO1xuICB9KSlcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmOyB9KTtcblxuICByZXR1cm4gdGhpcy5fX2luaXRfcHJvbWlzZTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE1ldGhvZHMgYmVsb3cgYXJlIGZvciBpbnRlcm5hbCB1c2UgZnJvbSBwbHVnaW5zXG5cblxuLy8gU2ltcGxlIGRlY29kZSBiYXNlNjQgdG8gdHlwZWQgYXJyYXkuIFVzZWZ1bCB0byBsb2FkIGVtYmVkZGVkIHdlYmFzc2VtYmx5XG4vLyBjb2RlLiBZb3UgcHJvYmFibHkgZG9uJ3QgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kIGRpcmVjdGx5LlxuLy9cbk11bHRpTWF0aC5wcm90b3R5cGUuX19iYXNlNjRkZWNvZGUgPSBiYXNlNjRkZWNvZGU7XG5cblxuLy8gSW5jcmVhc2UgY3VycmVudCBtZW1vcnkgdG8gaW5jbHVkZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzLiBEbyBub3RoaW5nIGlmXG4vLyBzaXplIGlzIGFscmVhZHkgb2suIFlvdSBwcm9iYWJseSBkb24ndCBuZWVkIHRvIGNhbGwgdGhpcyBtZXRob2QgZGlyZWN0bHksXG4vLyBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCBmcm9tIGAuX19pbnN0YW5jZSgpYC5cbi8vXG5NdWx0aU1hdGgucHJvdG90eXBlLl9fcmVhbGxvY2F0ZSA9IGZ1bmN0aW9uIG1lbV9ncm93X3RvKGJ5dGVzKSB7XG4gIGlmICghdGhpcy5fX21lbW9yeSkge1xuICAgIHRoaXMuX19tZW1vcnkgPSBuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtcbiAgICAgIGluaXRpYWw6IE1hdGguY2VpbChieXRlcyAvICg2NCAqIDEwMjQpKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9fbWVtb3J5O1xuICB9XG5cbiAgdmFyIG1lbV9zaXplID0gdGhpcy5fX21lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aDtcblxuICBpZiAobWVtX3NpemUgPCBieXRlcykge1xuICAgIHRoaXMuX19tZW1vcnkuZ3JvdyhNYXRoLmNlaWwoKGJ5dGVzIC0gbWVtX3NpemUpIC8gKDY0ICogMTAyNCkpKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9fbWVtb3J5O1xufTtcblxuXG4vLyBSZXR1cm5zIGluc3RhbnRpbmF0ZWQgd2ViYXNzZW1ibHkgaXRlbSBieSBuYW1lLCB3aXRoIHNwZWNpZmllZCBtZW1vcnkgc2l6ZVxuLy8gYW5kIGVudmlyb25tZW50LlxuLy8gLSB1c2UgY2FjaGUgaWYgYXZhaWxhYmxlXG4vLyAtIGRvIHN5bmMgbW9kdWxlIGluaXQsIGlmIGFzeW5jIGluaXQgd2FzIG5vdCBjYWxsZWQgZWFybGllclxuLy8gLSBhbGxvY2F0ZSBtZW1vcnkgaWYgbm90IGVub3VndGhcbi8vIC0gY2FuIGV4cG9ydCBmdW5jdGlvbnMgdG8gd2ViYXNzZW1ibHkgdmlhIFwiZW52X2V4dHJhXCIsXG4vLyAgIGZvciBleGFtcGxlLCB7IGV4cDogTWF0aC5leHAgfVxuLy9cbk11bHRpTWF0aC5wcm90b3R5cGUuX19pbnN0YW5jZSA9IGZ1bmN0aW9uIGluc3RhbmNlKG5hbWUsIG1lbXNpemUsIGVudl9leHRyYSkge1xuICBpZiAobWVtc2l6ZSkgdGhpcy5fX3JlYWxsb2NhdGUobWVtc2l6ZSk7XG5cbiAgLy8gSWYgLmluaXQoKSB3YXMgbm90IGNhbGxlZCwgZG8gc3luYyBjb21waWxlXG4gIGlmICghdGhpcy5fX3dhc21bbmFtZV0pIHtcbiAgICB2YXIgbW9kdWxlID0gdGhpcy5fX21vZHVsZXNbbmFtZV07XG4gICAgdGhpcy5fX3dhc21bbmFtZV0gPSBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKHRoaXMuX19iYXNlNjRkZWNvZGUobW9kdWxlLndhc21fc3JjKSk7XG4gIH1cblxuICBpZiAoIXRoaXMuX19jYWNoZVtuYW1lXSkge1xuICAgIHZhciBlbnZfYmFzZSA9IHtcbiAgICAgIG1lbW9yeUJhc2U6IDAsXG4gICAgICBtZW1vcnk6IHRoaXMuX19tZW1vcnksXG4gICAgICB0YWJsZUJhc2U6IDAsXG4gICAgICB0YWJsZTogbmV3IFdlYkFzc2VtYmx5LlRhYmxlKHsgaW5pdGlhbDogMCwgZWxlbWVudDogJ2FueWZ1bmMnIH0pXG4gICAgfTtcblxuICAgIHRoaXMuX19jYWNoZVtuYW1lXSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZSh0aGlzLl9fd2FzbVtuYW1lXSwge1xuICAgICAgZW52OiBhc3NpZ24oZW52X2Jhc2UsIGVudl9leHRyYSB8fCB7fSlcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9fY2FjaGVbbmFtZV07XG59O1xuXG5cbi8vIEhlbHBlciB0byBjYWxjdWxhdGUgbWVtb3J5IGFsaWdoIGZvciBwb2ludGVycy4gV2ViYXNzZW1ibHkgZG9lcyBub3QgcmVxdWlyZVxuLy8gdGhpcywgYnV0IHlvdSBtYXkgd2lzaCB0byBleHBlcmltZW50LiBEZWZhdWx0IGJhc2UgPSA4O1xuLy9cbk11bHRpTWF0aC5wcm90b3R5cGUuX19hbGlnbiA9IGZ1bmN0aW9uIGFsaWduKG51bWJlciwgYmFzZSkge1xuICBiYXNlID0gYmFzZSB8fCA4O1xuICB2YXIgcmVtaW5kZXIgPSBudW1iZXIgJSBiYXNlO1xuICByZXR1cm4gbnVtYmVyICsgKHJlbWluZGVyID8gYmFzZSAtIHJlbWluZGVyIDogMCk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTXVsdGlNYXRoO1xuXG59LHtcIi4vbGliL2Jhc2U2NGRlY29kZVwiOjIwLFwiLi9saWIvd2FfZGV0ZWN0XCI6MjEsXCJvYmplY3QtYXNzaWduXCI6MjJ9XSwyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBiYXNlNjQgZGVjb2RlIHN0ciAtPiBVaW50OEFycmF5LCB0byBsb2FkIFdBIG1vZHVsZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIEJBU0U2NF9NQVAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYXNlNjRkZWNvZGUoc3RyKSB7XG4gIHZhciBpbnB1dCA9IHN0ci5yZXBsYWNlKC9bXFxyXFxuPV0vZywgJycpLCAvLyByZW1vdmUgQ1IvTEYgJiBwYWRkaW5nIHRvIHNpbXBsaWZ5IHNjYW5cbiAgICAgIG1heCAgID0gaW5wdXQubGVuZ3RoO1xuXG4gIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSgobWF4ICogMykgPj4gMik7XG5cbiAgLy8gQ29sbGVjdCBieSA2KjQgYml0cyAoMyBieXRlcylcblxuICB2YXIgYml0cyA9IDA7XG4gIHZhciBwdHIgID0gMDtcblxuICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSA0ID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIG91dFtwdHIrK10gPSAoYml0cyA+PiAxNikgJiAweEZGO1xuICAgICAgb3V0W3B0cisrXSA9IChiaXRzID4+IDgpICYgMHhGRjtcbiAgICAgIG91dFtwdHIrK10gPSBiaXRzICYgMHhGRjtcbiAgICB9XG5cbiAgICBiaXRzID0gKGJpdHMgPDwgNikgfCBCQVNFNjRfTUFQLmluZGV4T2YoaW5wdXQuY2hhckF0KGlkeCkpO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdmFyIHRhaWxiaXRzID0gKG1heCAlIDQpICogNjtcblxuICBpZiAodGFpbGJpdHMgPT09IDApIHtcbiAgICBvdXRbcHRyKytdID0gKGJpdHMgPj4gMTYpICYgMHhGRjtcbiAgICBvdXRbcHRyKytdID0gKGJpdHMgPj4gOCkgJiAweEZGO1xuICAgIG91dFtwdHIrK10gPSBiaXRzICYgMHhGRjtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTgpIHtcbiAgICBvdXRbcHRyKytdID0gKGJpdHMgPj4gMTApICYgMHhGRjtcbiAgICBvdXRbcHRyKytdID0gKGJpdHMgPj4gMikgJiAweEZGO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxMikge1xuICAgIG91dFtwdHIrK10gPSAoYml0cyA+PiA0KSAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxufSx7fV0sMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gRGV0ZWN0IFdlYkFzc2VtYmx5IHN1cHBvcnQuXG4vLyAtIENoZWNrIGdsb2JhbCBXZWJBc3NlbWJseSBvYmplY3Rcbi8vIC0gVHJ5IHRvIGxvYWQgc2ltcGxlIG1vZHVsZSAoY2FuIGJlIGRpc2FibGVkIHZpYSBDU1ApXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB3YTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1dlYkFzc2VtYmx5KCkge1xuICAvLyB1c2UgY2FjaGUgaWYgY2FsbGVkIGJlZm9yZTtcbiAgaWYgKHR5cGVvZiB3YSAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiB3YTtcblxuICB3YSA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gd2E7XG5cbiAgLy8gSWYgV2ViQXNzZW5ibHkgaXMgZGlzYWJsZWQsIGNvZGUgY2FuIHRocm93IG9uIGNvbXBpbGVcbiAgdHJ5IHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYnJpb24vbWluLXdhc20tZmFpbC9ibG9iL21hc3Rlci9taW4td2FzbS1mYWlsLmluLmpzXG4gICAgLy8gQWRkaXRpb25hbCBjaGVjayB0aGF0IFdBIGludGVybmFscyBhcmUgY29ycmVjdFxuXG4gICAgLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZywgbWF4LWxlbiAqL1xuICAgIHZhciBiaW4gICAgICA9IG5ldyBVaW50OEFycmF5KFsgMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw2LDEsOTYsMSwxMjcsMSwxMjcsMywyLDEsMCw1LDMsMSwwLDEsNyw4LDEsNCwxMTYsMTAxLDExNSwxMTYsMCwwLDEwLDE2LDEsMTQsMCwzMiwwLDY1LDEsNTQsMiwwLDMyLDAsNDAsMiwwLDExIF0pO1xuICAgIHZhciBtb2R1bGUgICA9IG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUoYmluKTtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobW9kdWxlLCB7fSk7XG5cbiAgICAvLyB0ZXN0IHN0b3JpbmcgdG8gYW5kIGxvYWRpbmcgZnJvbSBhIG5vbi16ZXJvIGxvY2F0aW9uIHZpYSBhIHBhcmFtZXRlci5cbiAgICAvLyBTYWZhcmkgb24gaU9TIDExLjIuNSByZXR1cm5zIDAgdW5leHBlY3RlZGx5IGF0IG5vbi16ZXJvIGxvY2F0aW9uc1xuICAgIGlmIChpbnN0YW5jZS5leHBvcnRzLnRlc3QoNCkgIT09IDApIHdhID0gdHJ1ZTtcblxuICAgIHJldHVybiB3YTtcbiAgfSBjYXRjaCAoX18pIHt9XG5cbiAgcmV0dXJuIHdhO1xufTtcblxufSx7fV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxufSx7fV0sMjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGJ1bmRsZUZuID0gYXJndW1lbnRzWzNdO1xudmFyIHNvdXJjZXMgPSBhcmd1bWVudHNbNF07XG52YXIgY2FjaGUgPSBhcmd1bWVudHNbNV07XG5cbnZhciBzdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICB2YXIgd2tleTtcbiAgICB2YXIgY2FjaGVLZXlzID0gT2JqZWN0LmtleXMoY2FjaGUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYWNoZUtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBjYWNoZUtleXNbaV07XG4gICAgICAgIHZhciBleHAgPSBjYWNoZVtrZXldLmV4cG9ydHM7XG4gICAgICAgIC8vIFVzaW5nIGJhYmVsIGFzIGEgdHJhbnNwaWxlciB0byB1c2UgZXNtb2R1bGUsIHRoZSBleHBvcnQgd2lsbCBhbHdheXNcbiAgICAgICAgLy8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGRlZmF1bHQgZXhwb3J0IGFzIGEgcHJvcGVydHkgb2YgaXQuIFRvIGVuc3VyZVxuICAgICAgICAvLyB0aGUgZXhpc3RpbmcgYXBpIGFuZCBiYWJlbCBlc21vZHVsZSBleHBvcnRzIGFyZSBib3RoIHN1cHBvcnRlZCB3ZVxuICAgICAgICAvLyBjaGVjayBmb3IgYm90aFxuICAgICAgICBpZiAoZXhwID09PSBmbiB8fCBleHAgJiYgZXhwLmRlZmF1bHQgPT09IGZuKSB7XG4gICAgICAgICAgICB3a2V5ID0ga2V5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXdrZXkpIHtcbiAgICAgICAgd2tleSA9IE1hdGguZmxvb3IoTWF0aC5wb3coMTYsIDgpICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO1xuICAgICAgICB2YXIgd2NhY2hlID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FjaGVLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGNhY2hlS2V5c1tpXTtcbiAgICAgICAgICAgIHdjYWNoZVtrZXldID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZXNbd2tleV0gPSBbXG4gICAgICAgICAgICAnZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7JyArIGZuICsgJyhzZWxmKTsgfScsXG4gICAgICAgICAgICB3Y2FjaGVcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFyIHNrZXkgPSBNYXRoLmZsb29yKE1hdGgucG93KDE2LCA4KSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcblxuICAgIHZhciBzY2FjaGUgPSB7fTsgc2NhY2hlW3drZXldID0gd2tleTtcbiAgICBzb3VyY2VzW3NrZXldID0gW1xuICAgICAgICAnZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7JyArXG4gICAgICAgICAgICAvLyB0cnkgdG8gY2FsbCBkZWZhdWx0IGlmIGRlZmluZWQgdG8gYWxzbyBzdXBwb3J0IGJhYmVsIGVzbW9kdWxlIGV4cG9ydHNcbiAgICAgICAgICAgICd2YXIgZiA9IHJlcXVpcmUoJyArIHN0cmluZ2lmeSh3a2V5KSArICcpOycgK1xuICAgICAgICAgICAgJyhmLmRlZmF1bHQgPyBmLmRlZmF1bHQgOiBmKShzZWxmKTsnICtcbiAgICAgICAgJ30nLFxuICAgICAgICBzY2FjaGVcbiAgICBdO1xuXG4gICAgdmFyIHdvcmtlclNvdXJjZXMgPSB7fTtcbiAgICByZXNvbHZlU291cmNlcyhza2V5KTtcblxuICAgIGZ1bmN0aW9uIHJlc29sdmVTb3VyY2VzKGtleSkge1xuICAgICAgICB3b3JrZXJTb3VyY2VzW2tleV0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGRlcFBhdGggaW4gc291cmNlc1trZXldWzFdKSB7XG4gICAgICAgICAgICB2YXIgZGVwS2V5ID0gc291cmNlc1trZXldWzFdW2RlcFBhdGhdO1xuICAgICAgICAgICAgaWYgKCF3b3JrZXJTb3VyY2VzW2RlcEtleV0pIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlU291cmNlcyhkZXBLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNyYyA9ICcoJyArIGJ1bmRsZUZuICsgJykoeydcbiAgICAgICAgKyBPYmplY3Qua2V5cyh3b3JrZXJTb3VyY2VzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShrZXkpICsgJzpbJ1xuICAgICAgICAgICAgICAgICsgc291cmNlc1trZXldWzBdXG4gICAgICAgICAgICAgICAgKyAnLCcgKyBzdHJpbmdpZnkoc291cmNlc1trZXldWzFdKSArICddJ1xuICAgICAgICAgICAgO1xuICAgICAgICB9KS5qb2luKCcsJylcbiAgICAgICAgKyAnfSx7fSxbJyArIHN0cmluZ2lmeShza2V5KSArICddKSdcbiAgICA7XG5cbiAgICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMO1xuXG4gICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbc3JjXSwgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmJhcmUpIHsgcmV0dXJuIGJsb2I7IH1cbiAgICB2YXIgd29ya2VyVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVcmwpO1xuICAgIHdvcmtlci5vYmplY3RVUkwgPSB3b3JrZXJVcmw7XG4gICAgcmV0dXJuIHdvcmtlcjtcbn07XG5cbn0se31dLFwiL2luZGV4LmpzXCI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbnZhciBhc3NpZ24gPSBfZGVyZXFfKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciB3ZWJ3b3JraWZ5ID0gX2RlcmVxXygnd2Vid29ya2lmeScpO1xuXG52YXIgTWF0aExpYiA9IF9kZXJlcV8oJy4vbGliL21hdGhsaWInKTtcblxudmFyIFBvb2wgPSBfZGVyZXFfKCcuL2xpYi9wb29sJyk7XG5cbnZhciB1dGlscyA9IF9kZXJlcV8oJy4vbGliL3V0aWxzJyk7XG5cbnZhciB3b3JrZXIgPSBfZGVyZXFfKCcuL2xpYi93b3JrZXInKTtcblxudmFyIGNyZWF0ZVN0YWdlcyA9IF9kZXJlcV8oJy4vbGliL3N0ZXBwZXInKTtcblxudmFyIGNyZWF0ZVJlZ2lvbnMgPSBfZGVyZXFfKCcuL2xpYi90aWxlcicpO1xuXG52YXIgZmlsdGVyX2luZm8gPSBfZGVyZXFfKCcuL2xpYi9tbV9yZXNpemUvcmVzaXplX2ZpbHRlcl9pbmZvJyk7IC8vIERlZHVwbGljYXRlIHBvb2xzICYgbGltaXRlcnMgd2l0aCB0aGUgc2FtZSBjb25maWdzXG4vLyB3aGVuIHVzZXIgY3JlYXRlcyBtdWx0aXBsZSBwaWNhIGluc3RhbmNlcy5cblxuXG52YXIgc2luZ2xldG9uZXMgPSB7fTtcbnZhciBORUVEX1NBRkFSSV9GSVggPSBmYWxzZTtcblxudHJ5IHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQpIHtcbiAgICBORUVEX1NBRkFSSV9GSVggPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1NhZmFyaScpID49IDA7XG4gIH1cbn0gY2F0Y2ggKGUpIHt9XG5cbnZhciBjb25jdXJyZW5jeSA9IDE7XG5cbmlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICBjb25jdXJyZW5jeSA9IE1hdGgubWluKG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5IHx8IDEsIDQpO1xufVxuXG52YXIgREVGQVVMVF9QSUNBX09QVFMgPSB7XG4gIHRpbGU6IDEwMjQsXG4gIGNvbmN1cnJlbmN5OiBjb25jdXJyZW5jeSxcbiAgZmVhdHVyZXM6IFsnanMnLCAnd2FzbScsICd3dyddLFxuICBpZGxlOiAyMDAwLFxuICBjcmVhdGVDYW52YXM6IGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHRtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRtcENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIHRtcENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHRtcENhbnZhcztcbiAgfVxufTtcbnZhciBERUZBVUxUX1JFU0laRV9PUFRTID0ge1xuICBmaWx0ZXI6ICdta3MyMDEzJyxcbiAgdW5zaGFycEFtb3VudDogMCxcbiAgdW5zaGFycFJhZGl1czogMC4wLFxuICB1bnNoYXJwVGhyZXNob2xkOiAwXG59O1xudmFyIENBTl9ORVdfSU1BR0VfREFUQSA9IGZhbHNlO1xudmFyIENBTl9DUkVBVEVfSU1BR0VfQklUTUFQID0gZmFsc2U7XG52YXIgQ0FOX1VTRV9DQU5WQVNfR0VUX0lNQUdFX0RBVEEgPSBmYWxzZTtcbnZhciBDQU5fVVNFX09GRlNDUkVFTl9DQU5WQVMgPSBmYWxzZTtcbnZhciBDQU5fVVNFX0NJQl9SRUdJT05fRk9SX0lNQUdFID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHdvcmtlckZhYnJpYygpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogd2Vid29ya2lmeSh3b3JrZXIpLFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnZhbHVlLnRlcm1pbmF0ZSgpO1xuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIHVybCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCB8fCB3aW5kb3cubW96VVJMIHx8IHdpbmRvdy5tc1VSTDtcblxuICAgICAgICBpZiAodXJsICYmIHVybC5yZXZva2VPYmplY3RVUkwgJiYgdGhpcy52YWx1ZS5vYmplY3RVUkwpIHtcbiAgICAgICAgICB1cmwucmV2b2tlT2JqZWN0VVJMKHRoaXMudmFsdWUub2JqZWN0VVJMKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEFQSSBtZXRob2RzXG5cblxuZnVuY3Rpb24gUGljYShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQaWNhKSkgcmV0dXJuIG5ldyBQaWNhKG9wdGlvbnMpO1xuICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIERFRkFVTFRfUElDQV9PUFRTLCBvcHRpb25zIHx8IHt9KTtcbiAgdmFyIGxpbWl0ZXJfa2V5ID0gXCJsa19cIi5jb25jYXQodGhpcy5vcHRpb25zLmNvbmN1cnJlbmN5KTsgLy8gU2hhcmUgbGltaXRlcnMgdG8gYXZvaWQgbXVsdGlwbGUgcGFyYWxsZWwgd29ya2VycyB3aGVuIHVzZXIgY3JlYXRlc1xuICAvLyBtdWx0aXBsZSBwaWNhIGluc3RhbmNlcy5cblxuICB0aGlzLl9fbGltaXQgPSBzaW5nbGV0b25lc1tsaW1pdGVyX2tleV0gfHwgdXRpbHMubGltaXRlcih0aGlzLm9wdGlvbnMuY29uY3VycmVuY3kpO1xuICBpZiAoIXNpbmdsZXRvbmVzW2xpbWl0ZXJfa2V5XSkgc2luZ2xldG9uZXNbbGltaXRlcl9rZXldID0gdGhpcy5fX2xpbWl0OyAvLyBMaXN0IG9mIHN1cHBvcnRlZCBmZWF0dXJlcywgYWNjb3JkaW5nIHRvIG9wdGlvbnMgJiBicm93c2VyL25vZGUuanNcblxuICB0aGlzLmZlYXR1cmVzID0ge1xuICAgIGpzOiBmYWxzZSxcbiAgICAvLyBwdXJlIEpTIGltcGxlbWVudGF0aW9uLCBjYW4gYmUgZGlzYWJsZWQgZm9yIHRlc3RpbmdcbiAgICB3YXNtOiBmYWxzZSxcbiAgICAvLyB3ZWJhc3NlbWJseSBpbXBsZW1lbnRhdGlvbiBmb3IgaGVhdnkgZnVuY3Rpb25zXG4gICAgY2liOiBmYWxzZSxcbiAgICAvLyByZXNpemUgdmlhIGNyZWF0ZUltYWdlQml0bWFwIChvbmx5IEZGIGF0IHRoaXMgbW9tZW50KVxuICAgIHd3OiBmYWxzZSAvLyB3ZWJ3b3JrZXJzXG5cbiAgfTtcbiAgdGhpcy5fX3dvcmtlcnNQb29sID0gbnVsbDsgLy8gU3RvcmUgcmVxdWVzdGVkIGZlYXR1cmVzIGZvciB3ZWJ3b3JrZXJzXG5cbiAgdGhpcy5fX3JlcXVlc3RlZF9mZWF0dXJlcyA9IFtdO1xuICB0aGlzLl9fbWF0aGxpYiA9IG51bGw7XG59XG5cblBpY2EucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuX19pbml0UHJvbWlzZSkgcmV0dXJuIHRoaXMuX19pbml0UHJvbWlzZTsgLy8gVGVzdCBpZiB3ZSBjYW4gY3JlYXRlIEltYWdlRGF0YSB3aXRob3V0IGNhbnZhcyBhbmQgbWVtb3J5IGNvcHlcblxuICBpZiAodHlwZW9mIEltYWdlRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cbiAgICAgIG5ldyBJbWFnZURhdGEobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDQwMCksIDEwLCAxMCk7XG4gICAgICBDQU5fTkVXX0lNQUdFX0RBVEEgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKF9fKSB7fVxuICB9IC8vIEltYWdlQml0bWFwIGNhbiBiZSBlZmZlY3RpdmUgaW4gMiBwbGFjZXM6XG4gIC8vXG4gIC8vIDEuIFRocmVhZGVkIGpwZWcgdW5wYWNrIChiYXNpYylcbiAgLy8gMi4gQnVpbHQtaW4gcmVzaXplIChibG9ja2VkIGR1ZSBwcm9ibGVtIGluIGNocm9tZSwgc2VlIGlzc3VlICM4OSlcbiAgLy9cbiAgLy8gRm9yIGJhc2ljIHVzZSB3ZSBhbHNvIG5lZWQgSW1hZ2VCaXRtYXAgd28gc3VwcG9ydCAuY2xvc2UoKSBtZXRob2QsXG4gIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9ydS9kb2NzL1dlYi9BUEkvSW1hZ2VCaXRtYXBcblxuXG4gIGlmICh0eXBlb2YgSW1hZ2VCaXRtYXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEltYWdlQml0bWFwLnByb3RvdHlwZSAmJiBJbWFnZUJpdG1hcC5wcm90b3R5cGUuY2xvc2UpIHtcbiAgICAgIENBTl9DUkVBVEVfSU1BR0VfQklUTUFQID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWJ1ZygnSW1hZ2VCaXRtYXAgZG9lcyBub3Qgc3VwcG9ydCAuY2xvc2UoKSwgZGlzYWJsZWQnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmVhdHVyZXMgPSB0aGlzLm9wdGlvbnMuZmVhdHVyZXMuc2xpY2UoKTtcblxuICBpZiAoZmVhdHVyZXMuaW5kZXhPZignYWxsJykgPj0gMCkge1xuICAgIGZlYXR1cmVzID0gWydjaWInLCAnd2FzbScsICdqcycsICd3dyddO1xuICB9XG5cbiAgdGhpcy5fX3JlcXVlc3RlZF9mZWF0dXJlcyA9IGZlYXR1cmVzO1xuICB0aGlzLl9fbWF0aGxpYiA9IG5ldyBNYXRoTGliKGZlYXR1cmVzKTsgLy8gQ2hlY2sgV2ViV29ya2VyIHN1cHBvcnQgaWYgcmVxdWVzdGVkXG5cbiAgaWYgKGZlYXR1cmVzLmluZGV4T2YoJ3d3JykgPj0gMCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnV29ya2VyJyBpbiB3aW5kb3cpIHtcbiAgICAgIC8vIElFIDw9IDExIGRvbid0IGFsbG93IHRvIGNyZWF0ZSB3ZWJ3b3JrZXJzIGZyb20gc3RyaW5nLiBXZSBzaG91bGQgY2hlY2sgaXQuXG4gICAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzgwMTgxMC93ZWItd29ya2Vycy1mcm9tLWJsb2ItdXJscy1pbi1pZS0xMC1hbmQtMTFcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB3a3IgPSBfZGVyZXFfKCd3ZWJ3b3JraWZ5JykoZnVuY3Rpb24gKCkge30pO1xuXG4gICAgICAgIHdrci50ZXJtaW5hdGUoKTtcbiAgICAgICAgdGhpcy5mZWF0dXJlcy53dyA9IHRydWU7IC8vIHBvb2wgdW5pcXVlbmVzcyBkZXBlbmRzIG9uIHBvb2wgY29uZmlnICsgd2Vid29ya2VyIGNvbmZpZ1xuXG4gICAgICAgIHZhciB3cG9vbF9rZXkgPSBcIndwX1wiLmNvbmNhdChKU09OLnN0cmluZ2lmeSh0aGlzLm9wdGlvbnMpKTtcblxuICAgICAgICBpZiAoc2luZ2xldG9uZXNbd3Bvb2xfa2V5XSkge1xuICAgICAgICAgIHRoaXMuX193b3JrZXJzUG9vbCA9IHNpbmdsZXRvbmVzW3dwb29sX2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX3dvcmtlcnNQb29sID0gbmV3IFBvb2wod29ya2VyRmFicmljLCB0aGlzLm9wdGlvbnMuaWRsZSk7XG4gICAgICAgICAgc2luZ2xldG9uZXNbd3Bvb2xfa2V5XSA9IHRoaXMuX193b3JrZXJzUG9vbDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoX18pIHt9XG4gICAgfVxuICB9XG5cbiAgdmFyIGluaXRNYXRoID0gdGhpcy5fX21hdGhsaWIuaW5pdCgpLnRoZW4oZnVuY3Rpb24gKG1hdGhsaWIpIHtcbiAgICAvLyBDb3B5IGRldGVjdGVkIGZlYXR1cmVzXG4gICAgYXNzaWduKF90aGlzLmZlYXR1cmVzLCBtYXRobGliLmZlYXR1cmVzKTtcbiAgfSk7XG5cbiAgdmFyIGNoZWNrQ2liUmVzaXplO1xuXG4gIGlmICghQ0FOX0NSRUFURV9JTUFHRV9CSVRNQVApIHtcbiAgICBjaGVja0NpYlJlc2l6ZSA9IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgY2hlY2tDaWJSZXNpemUgPSB1dGlscy5jaWJfc3VwcG9ydCh0aGlzLm9wdGlvbnMuY3JlYXRlQ2FudmFzKS50aGVuKGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgIGlmIChfdGhpcy5mZWF0dXJlcy5jaWIgJiYgZmVhdHVyZXMuaW5kZXhPZignY2liJykgPCAwKSB7XG4gICAgICAgIF90aGlzLmRlYnVnKCdjcmVhdGVJbWFnZUJpdG1hcCgpIHJlc2l6ZSBzdXBwb3J0ZWQsIGJ1dCBkaXNhYmxlZCBieSBjb25maWcnKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChmZWF0dXJlcy5pbmRleE9mKCdjaWInKSA+PSAwKSBfdGhpcy5mZWF0dXJlcy5jaWIgPSBzdGF0dXM7XG4gICAgfSk7XG4gIH1cblxuICBDQU5fVVNFX0NBTlZBU19HRVRfSU1BR0VfREFUQSA9IHV0aWxzLmNhbl91c2VfY2FudmFzKHRoaXMub3B0aW9ucy5jcmVhdGVDYW52YXMpO1xuICB2YXIgY2hlY2tPZmZzY3JlZW5DYW52YXM7XG5cbiAgaWYgKENBTl9DUkVBVEVfSU1BR0VfQklUTUFQICYmIENBTl9ORVdfSU1BR0VfREFUQSAmJiBmZWF0dXJlcy5pbmRleE9mKCd3dycpICE9PSAtMSkge1xuICAgIGNoZWNrT2Zmc2NyZWVuQ2FudmFzID0gdXRpbHMud29ya2VyX29mZnNjcmVlbl9jYW52YXNfc3VwcG9ydCgpO1xuICB9IGVsc2Uge1xuICAgIGNoZWNrT2Zmc2NyZWVuQ2FudmFzID0gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgfVxuXG4gIGNoZWNrT2Zmc2NyZWVuQ2FudmFzID0gY2hlY2tPZmZzY3JlZW5DYW52YXMudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgQ0FOX1VTRV9PRkZTQ1JFRU5fQ0FOVkFTID0gcmVzdWx0O1xuICB9KTsgLy8gd2UgdXNlIGNyZWF0ZUltYWdlQml0bWFwIHRvIGNyb3AgaW1hZ2UgZGF0YSBhbmQgcGFzcyBpdCB0byB3b3JrZXJzLFxuICAvLyBzbyBuZWVkIHRvIGNoZWNrIHdoZXRoZXIgZnVuY3Rpb24gd29ya3MgY29ycmVjdGx5O1xuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMjIwNjcxXG5cbiAgdmFyIGNoZWNrQ2liUmVnaW9uID0gdXRpbHMuY2liX2Nhbl91c2VfcmVnaW9uKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgQ0FOX1VTRV9DSUJfUkVHSU9OX0ZPUl9JTUFHRSA9IHJlc3VsdDtcbiAgfSk7IC8vIEluaXQgbWF0aCBsaWIuIFRoYXQncyBhc3luYyBiZWNhdXNlIGNhbiBsb2FkIHNvbWVcblxuICB0aGlzLl9faW5pdFByb21pc2UgPSBQcm9taXNlLmFsbChbaW5pdE1hdGgsIGNoZWNrQ2liUmVzaXplLCBjaGVja09mZnNjcmVlbkNhbnZhcywgY2hlY2tDaWJSZWdpb25dKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH0pO1xuICByZXR1cm4gdGhpcy5fX2luaXRQcm9taXNlO1xufTsgLy8gQ2FsbCByZXNpemVyIGluIHdlYndvcmtlciBvciBsb2NhbGx5LCBkZXBlbmRpbmcgb24gY29uZmlnXG5cblxuUGljYS5wcm90b3R5cGUuX19pbnZva2VSZXNpemUgPSBmdW5jdGlvbiAodGlsZU9wdHMsIG9wdHMpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgLy8gU2hhcmUgY2FjaGUgYmV0d2VlbiBjYWxsczpcbiAgLy9cbiAgLy8gLSB3YXNtIGluc3RhbmNlXG4gIC8vIC0gd2FzbSBtZW1vcnkgb2JqZWN0XG4gIC8vXG4gIG9wdHMuX19tYXRoQ2FjaGUgPSBvcHRzLl9fbWF0aENhY2hlIHx8IHt9O1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFfdGhpczIuZmVhdHVyZXMud3cpIHtcbiAgICAgIC8vIG5vdCBwb3NzaWJsZSB0byBoYXZlIEltYWdlQml0bWFwIGhlcmUgaWYgdXNlciBkaXNhYmxlZCBXV1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogX3RoaXMyLl9fbWF0aGxpYi5yZXNpemVBbmRVbnNoYXJwKHRpbGVPcHRzLCBvcHRzLl9fbWF0aENhY2hlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHcgPSBfdGhpczIuX193b3JrZXJzUG9vbC5hY3F1aXJlKCk7XG5cbiAgICAgIGlmIChvcHRzLmNhbmNlbFRva2VuKSBvcHRzLmNhbmNlbFRva2VuW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9KTtcblxuICAgICAgdy52YWx1ZS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdy5yZWxlYXNlKCk7XG4gICAgICAgIGlmIChldi5kYXRhLmVycikgcmVqZWN0KGV2LmRhdGEuZXJyKTtlbHNlIHJlc29sdmUoZXYuZGF0YSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgdHJhbnNmZXIgPSBbXTtcbiAgICAgIGlmICh0aWxlT3B0cy5zcmMpIHRyYW5zZmVyLnB1c2godGlsZU9wdHMuc3JjLmJ1ZmZlcik7XG4gICAgICBpZiAodGlsZU9wdHMuc3JjQml0bWFwKSB0cmFuc2Zlci5wdXNoKHRpbGVPcHRzLnNyY0JpdG1hcCk7XG4gICAgICB3LnZhbHVlLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgb3B0czogdGlsZU9wdHMsXG4gICAgICAgIGZlYXR1cmVzOiBfdGhpczIuX19yZXF1ZXN0ZWRfZmVhdHVyZXMsXG4gICAgICAgIHByZWxvYWQ6IHtcbiAgICAgICAgICB3YXNtX25vZHVsZTogX3RoaXMyLl9fbWF0aGxpYi5fX1xuICAgICAgICB9XG4gICAgICB9LCB0cmFuc2Zlcik7XG4gICAgfSk7XG4gIH0pO1xufTsgLy8gdGhpcyBmdW5jdGlvbiBjYW4gcmV0dXJuIHByb21pc2UgaWYgY3JlYXRlSW1hZ2VCaXRtYXAgaXMgdXNlZFxuXG5cblBpY2EucHJvdG90eXBlLl9fZXh0cmFjdFRpbGVEYXRhID0gZnVuY3Rpb24gKHRpbGUsIGZyb20sIG9wdHMsIHN0YWdlRW52LCBleHRyYWN0VG8pIHtcbiAgaWYgKHRoaXMuZmVhdHVyZXMud3cgJiYgQ0FOX1VTRV9PRkZTQ1JFRU5fQ0FOVkFTICYmICggLy8gY3JlYXRlSW1hZ2VCaXRtYXAgZG9lc24ndCB3b3JrIGZvciBpbWFnZXMgKEltYWdlLCBJbWFnZUJpdG1hcCkgd2l0aCBFeGlmIG9yaWVudGF0aW9uIGluIENocm9tZSxcbiAgLy8gY2FuIHVzZSBjYW52YXMgYmVjYXVzZSBjYW52YXMgZG9lc24ndCBoYXZlIG9yaWVudGF0aW9uO1xuICAvLyBzZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTIyMDY3MVxuICB1dGlscy5pc0NhbnZhcyhmcm9tKSB8fCBDQU5fVVNFX0NJQl9SRUdJT05fRk9SX0lNQUdFKSkge1xuICAgIHRoaXMuZGVidWcoJ0NyZWF0ZSB0aWxlIGZvciBPZmZzY3JlZW5DYW52YXMnKTtcbiAgICByZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAoc3RhZ2VFbnYuc3JjSW1hZ2VCaXRtYXAgfHwgZnJvbSwgdGlsZS54LCB0aWxlLnksIHRpbGUud2lkdGgsIHRpbGUuaGVpZ2h0KS50aGVuKGZ1bmN0aW9uIChiaXRtYXApIHtcbiAgICAgIGV4dHJhY3RUby5zcmNCaXRtYXAgPSBiaXRtYXA7XG4gICAgICByZXR1cm4gZXh0cmFjdFRvO1xuICAgIH0pO1xuICB9IC8vIEV4dHJhY3QgdGlsZSBSR0JBIGJ1ZmZlciwgZGVwZW5kaW5nIG9uIGlucHV0IHR5cGVcblxuXG4gIGlmICh1dGlscy5pc0NhbnZhcyhmcm9tKSkge1xuICAgIGlmICghc3RhZ2VFbnYuc3JjQ3R4KSBzdGFnZUVudi5zcmNDdHggPSBmcm9tLmdldENvbnRleHQoJzJkJyk7IC8vIElmIGlucHV0IGlzIENhbnZhcyAtIGV4dHJhY3QgcmVnaW9uIGRhdGEgZGlyZWN0bHlcblxuICAgIHRoaXMuZGVidWcoJ0dldCB0aWxlIHBpeGVsIGRhdGEnKTtcbiAgICBleHRyYWN0VG8uc3JjID0gc3RhZ2VFbnYuc3JjQ3R4LmdldEltYWdlRGF0YSh0aWxlLngsIHRpbGUueSwgdGlsZS53aWR0aCwgdGlsZS5oZWlnaHQpLmRhdGE7XG4gICAgcmV0dXJuIGV4dHJhY3RUbztcbiAgfSAvLyBJZiBpbnB1dCBpcyBJbWFnZSBvciBkZWNvZGVkIHRvIEltYWdlQml0bWFwLFxuICAvLyBkcmF3IHJlZ2lvbiB0byB0ZW1wb3JhcnkgY2FudmFzIGFuZCBleHRyYWN0IGRhdGEgZnJvbSBpdFxuICAvL1xuICAvLyBOb3RlISBBdHRlbXB0IHRvIHJldXNlIHRoaXMgY2FudmFzIGNhdXNlcyBzaWduaWZpY2FudCBzbG93ZG93biBpbiBjaHJvbWVcbiAgLy9cblxuXG4gIHRoaXMuZGVidWcoJ0RyYXcgdGlsZSBpbWFnZUJpdG1hcC9pbWFnZSB0byB0ZW1wb3JhcnkgY2FudmFzJyk7XG4gIHZhciB0bXBDYW52YXMgPSB0aGlzLm9wdGlvbnMuY3JlYXRlQ2FudmFzKHRpbGUud2lkdGgsIHRpbGUuaGVpZ2h0KTtcbiAgdmFyIHRtcEN0eCA9IHRtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICB0bXBDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICB0bXBDdHguZHJhd0ltYWdlKHN0YWdlRW52LnNyY0ltYWdlQml0bWFwIHx8IGZyb20sIHRpbGUueCwgdGlsZS55LCB0aWxlLndpZHRoLCB0aWxlLmhlaWdodCwgMCwgMCwgdGlsZS53aWR0aCwgdGlsZS5oZWlnaHQpO1xuICB0aGlzLmRlYnVnKCdHZXQgdGlsZSBwaXhlbCBkYXRhJyk7XG4gIGV4dHJhY3RUby5zcmMgPSB0bXBDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRpbGUud2lkdGgsIHRpbGUuaGVpZ2h0KS5kYXRhOyAvLyBTYWZhcmkgMTIgd29ya2Fyb3VuZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3BpY2EvaXNzdWVzLzE5OVxuXG4gIHRtcENhbnZhcy53aWR0aCA9IHRtcENhbnZhcy5oZWlnaHQgPSAwO1xuICByZXR1cm4gZXh0cmFjdFRvO1xufTtcblxuUGljYS5wcm90b3R5cGUuX19sYW5kVGlsZURhdGEgPSBmdW5jdGlvbiAodGlsZSwgcmVzdWx0LCBzdGFnZUVudikge1xuICB2YXIgdG9JbWFnZURhdGE7XG4gIHRoaXMuZGVidWcoJ0NvbnZlcnQgcmF3IHJnYmEgdGlsZSByZXN1bHQgdG8gSW1hZ2VEYXRhJyk7XG5cbiAgaWYgKHJlc3VsdC5iaXRtYXApIHtcbiAgICBzdGFnZUVudi50b0N0eC5kcmF3SW1hZ2UocmVzdWx0LmJpdG1hcCwgdGlsZS50b1gsIHRpbGUudG9ZKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChDQU5fTkVXX0lNQUdFX0RBVEEpIHtcbiAgICAvLyB0aGlzIGJyYW5jaCBpcyBmb3IgbW9kZXJuIGJyb3dzZXJzXG4gICAgLy8gSWYgYG5ldyBJbWFnZURhdGEoKWAgJiBVaW50OENsYW1wZWRBcnJheSBzdXBvcnRlZFxuICAgIHRvSW1hZ2VEYXRhID0gbmV3IEltYWdlRGF0YShuZXcgVWludDhDbGFtcGVkQXJyYXkocmVzdWx0LmRhdGEpLCB0aWxlLnRvV2lkdGgsIHRpbGUudG9IZWlnaHQpO1xuICB9IGVsc2Uge1xuICAgIC8vIGZhbGxiYWNrIGZvciBgbm9kZS1jYW52YXNgIGFuZCBvbGQgYnJvd3NlcnNcbiAgICAvLyAoSUUxMSBoYXMgSW1hZ2VEYXRhIGJ1dCBkb2VzIG5vdCBzdXBwb3J0IGBuZXcgSW1hZ2VEYXRhKClgKVxuICAgIHRvSW1hZ2VEYXRhID0gc3RhZ2VFbnYudG9DdHguY3JlYXRlSW1hZ2VEYXRhKHRpbGUudG9XaWR0aCwgdGlsZS50b0hlaWdodCk7XG5cbiAgICBpZiAodG9JbWFnZURhdGEuZGF0YS5zZXQpIHtcbiAgICAgIHRvSW1hZ2VEYXRhLmRhdGEuc2V0KHJlc3VsdC5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSUU5IGRvbid0IGhhdmUgYC5zZXQoKWBcbiAgICAgIGZvciAodmFyIGkgPSB0b0ltYWdlRGF0YS5kYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRvSW1hZ2VEYXRhLmRhdGFbaV0gPSByZXN1bHQuZGF0YVtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmRlYnVnKCdEcmF3IHRpbGUnKTtcblxuICBpZiAoTkVFRF9TQUZBUklfRklYKSB7XG4gICAgLy8gU2FmYXJpIGRyYXdzIHRoaW4gd2hpdGUgc3RyaXBlcyBiZXR3ZWVuIHRpbGVzIHdpdGhvdXQgdGhpcyBmaXhcbiAgICBzdGFnZUVudi50b0N0eC5wdXRJbWFnZURhdGEodG9JbWFnZURhdGEsIHRpbGUudG9YLCB0aWxlLnRvWSwgdGlsZS50b0lubmVyWCAtIHRpbGUudG9YLCB0aWxlLnRvSW5uZXJZIC0gdGlsZS50b1ksIHRpbGUudG9Jbm5lcldpZHRoICsgMWUtNSwgdGlsZS50b0lubmVySGVpZ2h0ICsgMWUtNSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhZ2VFbnYudG9DdHgucHV0SW1hZ2VEYXRhKHRvSW1hZ2VEYXRhLCB0aWxlLnRvWCwgdGlsZS50b1ksIHRpbGUudG9Jbm5lclggLSB0aWxlLnRvWCwgdGlsZS50b0lubmVyWSAtIHRpbGUudG9ZLCB0aWxlLnRvSW5uZXJXaWR0aCwgdGlsZS50b0lubmVySGVpZ2h0KTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuUGljYS5wcm90b3R5cGUuX190aWxlQW5kUmVzaXplID0gZnVuY3Rpb24gKGZyb20sIHRvLCBvcHRzKSB7XG4gIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gIHZhciBzdGFnZUVudiA9IHtcbiAgICBzcmNDdHg6IG51bGwsXG4gICAgc3JjSW1hZ2VCaXRtYXA6IG51bGwsXG4gICAgaXNJbWFnZUJpdG1hcFJldXNlZDogZmFsc2UsXG4gICAgdG9DdHg6IG51bGxcbiAgfTtcblxuICB2YXIgcHJvY2Vzc1RpbGUgPSBmdW5jdGlvbiBwcm9jZXNzVGlsZSh0aWxlKSB7XG4gICAgcmV0dXJuIF90aGlzMy5fX2xpbWl0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvcHRzLmNhbmNlbGVkKSByZXR1cm4gb3B0cy5jYW5jZWxUb2tlbjtcbiAgICAgIHZhciB0aWxlT3B0cyA9IHtcbiAgICAgICAgd2lkdGg6IHRpbGUud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGlsZS5oZWlnaHQsXG4gICAgICAgIHRvV2lkdGg6IHRpbGUudG9XaWR0aCxcbiAgICAgICAgdG9IZWlnaHQ6IHRpbGUudG9IZWlnaHQsXG4gICAgICAgIHNjYWxlWDogdGlsZS5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdGlsZS5zY2FsZVksXG4gICAgICAgIG9mZnNldFg6IHRpbGUub2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WTogdGlsZS5vZmZzZXRZLFxuICAgICAgICBmaWx0ZXI6IG9wdHMuZmlsdGVyLFxuICAgICAgICB1bnNoYXJwQW1vdW50OiBvcHRzLnVuc2hhcnBBbW91bnQsXG4gICAgICAgIHVuc2hhcnBSYWRpdXM6IG9wdHMudW5zaGFycFJhZGl1cyxcbiAgICAgICAgdW5zaGFycFRocmVzaG9sZDogb3B0cy51bnNoYXJwVGhyZXNob2xkXG4gICAgICB9O1xuXG4gICAgICBfdGhpczMuZGVidWcoJ0ludm9rZSByZXNpemUgbWF0aCcpO1xuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRpbGVPcHRzKS50aGVuKGZ1bmN0aW9uICh0aWxlT3B0cykge1xuICAgICAgICByZXR1cm4gX3RoaXMzLl9fZXh0cmFjdFRpbGVEYXRhKHRpbGUsIGZyb20sIG9wdHMsIHN0YWdlRW52LCB0aWxlT3B0cyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh0aWxlT3B0cykge1xuICAgICAgICBfdGhpczMuZGVidWcoJ0ludm9rZSByZXNpemUgbWF0aCcpO1xuXG4gICAgICAgIHJldHVybiBfdGhpczMuX19pbnZva2VSZXNpemUodGlsZU9wdHMsIG9wdHMpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChvcHRzLmNhbmNlbGVkKSByZXR1cm4gb3B0cy5jYW5jZWxUb2tlbjtcbiAgICAgICAgc3RhZ2VFbnYuc3JjSW1hZ2VEYXRhID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5fX2xhbmRUaWxlRGF0YSh0aWxlLCByZXN1bHQsIHN0YWdlRW52KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9OyAvLyBOZWVkIHRvIG5vcm1hbGl6ZSBkYXRhIHNvdXJjZSBmaXJzdC4gSXQgY2FuIGJlIGNhbnZhcyBvciBpbWFnZS5cbiAgLy8gSWYgaW1hZ2UgLSB0cnkgdG8gZGVjb2RlIGluIGJhY2tncm91bmQgaWYgcG9zc2libGVcblxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBzdGFnZUVudi50b0N0eCA9IHRvLmdldENvbnRleHQoJzJkJyk7XG4gICAgaWYgKHV0aWxzLmlzQ2FudmFzKGZyb20pKSByZXR1cm4gbnVsbDtcblxuICAgIGlmICh1dGlscy5pc0ltYWdlQml0bWFwKGZyb20pKSB7XG4gICAgICBzdGFnZUVudi5zcmNJbWFnZUJpdG1hcCA9IGZyb207XG4gICAgICBzdGFnZUVudi5pc0ltYWdlQml0bWFwUmV1c2VkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0ltYWdlKGZyb20pKSB7XG4gICAgICAvLyB0cnkgZG8gZGVjb2RlIGltYWdlIGluIGJhY2tncm91bmQgZm9yIGZhc3RlciBuZXh0IG9wZXJhdGlvbnM7XG4gICAgICAvLyBpZiB3ZSdyZSB1c2luZyBvZmZzY3JlZW4gY2FudmFzLCBjaWIgaXMgY2FsbGVkIHBlciB0aWxlLCBzbyBub3QgbmVlZGVkIGhlcmVcbiAgICAgIGlmICghQ0FOX0NSRUFURV9JTUFHRV9CSVRNQVApIHJldHVybiBudWxsO1xuXG4gICAgICBfdGhpczMuZGVidWcoJ0RlY29kZSBpbWFnZSB2aWEgY3JlYXRlSW1hZ2VCaXRtYXAnKTtcblxuICAgICAgcmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKGZyb20pLnRoZW4oZnVuY3Rpb24gKGltYWdlQml0bWFwKSB7XG4gICAgICAgIHN0YWdlRW52LnNyY0ltYWdlQml0bWFwID0gaW1hZ2VCaXRtYXA7XG4gICAgICB9KSAvLyBTdXBwcmVzcyBlcnJvciB0byB1c2UgZmFsbGJhY2ssIGlmIG1ldGhvZCBmYWlsc1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9waWNhL2lzc3Vlcy8xOTBcblxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgIFtcImNhdGNoXCJdKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQaWNhOiBcIi5mcm9tXCIgc2hvdWxkIGJlIEltYWdlLCBDYW52YXMgb3IgSW1hZ2VCaXRtYXAnKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG9wdHMuY2FuY2VsZWQpIHJldHVybiBvcHRzLmNhbmNlbFRva2VuO1xuXG4gICAgX3RoaXMzLmRlYnVnKCdDYWxjdWxhdGUgdGlsZXMnKTsgLy9cbiAgICAvLyBIZXJlIHdlIGFyZSB3aXRoIFwibm9ybWFsaXplZFwiIHNvdXJjZSxcbiAgICAvLyBmb2xsb3cgdG8gdGlsaW5nXG4gICAgLy9cblxuXG4gICAgdmFyIHJlZ2lvbnMgPSBjcmVhdGVSZWdpb25zKHtcbiAgICAgIHdpZHRoOiBvcHRzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBvcHRzLmhlaWdodCxcbiAgICAgIHNyY1RpbGVTaXplOiBfdGhpczMub3B0aW9ucy50aWxlLFxuICAgICAgdG9XaWR0aDogb3B0cy50b1dpZHRoLFxuICAgICAgdG9IZWlnaHQ6IG9wdHMudG9IZWlnaHQsXG4gICAgICBkZXN0VGlsZUJvcmRlcjogb3B0cy5fX2Rlc3RUaWxlQm9yZGVyXG4gICAgfSk7XG4gICAgdmFyIGpvYnMgPSByZWdpb25zLm1hcChmdW5jdGlvbiAodGlsZSkge1xuICAgICAgcmV0dXJuIHByb2Nlc3NUaWxlKHRpbGUpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY2xlYW51cChzdGFnZUVudikge1xuICAgICAgaWYgKHN0YWdlRW52LnNyY0ltYWdlQml0bWFwKSB7XG4gICAgICAgIGlmICghc3RhZ2VFbnYuaXNJbWFnZUJpdG1hcFJldXNlZCkgc3RhZ2VFbnYuc3JjSW1hZ2VCaXRtYXAuY2xvc2UoKTtcbiAgICAgICAgc3RhZ2VFbnYuc3JjSW1hZ2VCaXRtYXAgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aGlzMy5kZWJ1ZygnUHJvY2VzcyB0aWxlcycpO1xuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGpvYnMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMzLmRlYnVnKCdGaW5pc2hlZCEnKTtcblxuICAgICAgY2xlYW51cChzdGFnZUVudik7XG4gICAgICByZXR1cm4gdG87XG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgY2xlYW51cChzdGFnZUVudik7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuUGljYS5wcm90b3R5cGUuX19wcm9jZXNzU3RhZ2VzID0gZnVuY3Rpb24gKHN0YWdlcywgZnJvbSwgdG8sIG9wdHMpIHtcbiAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgaWYgKG9wdHMuY2FuY2VsZWQpIHJldHVybiBvcHRzLmNhbmNlbFRva2VuO1xuXG4gIHZhciBfc3RhZ2VzJHNoaWZ0ID0gc3RhZ2VzLnNoaWZ0KCksXG4gICAgICBfc3RhZ2VzJHNoaWZ0MiA9IF9zbGljZWRUb0FycmF5KF9zdGFnZXMkc2hpZnQsIDIpLFxuICAgICAgdG9XaWR0aCA9IF9zdGFnZXMkc2hpZnQyWzBdLFxuICAgICAgdG9IZWlnaHQgPSBfc3RhZ2VzJHNoaWZ0MlsxXTtcblxuICB2YXIgaXNMYXN0U3RhZ2UgPSBzdGFnZXMubGVuZ3RoID09PSAwOyAvLyBPcHRpbWl6YXRpb24gZm9yIGxlZ2FjeSBmaWx0ZXJzIC1cbiAgLy8gb25seSB1c2UgdXNlci1kZWZpbmVkIHF1YWxpdHkgZm9yIHRoZSBsYXN0IHN0YWdlLFxuICAvLyB1c2Ugc2ltcGxlciAoSGFtbWluZykgZmlsdGVyIGZvciB0aGUgZmlyc3Qgc3RhZ2VzIHdoZXJlXG4gIC8vIHNjYWxlIGZhY3RvciBpcyBsYXJnZSBlbm91Z2ggKG1vcmUgdGhhbiAyLTMpXG4gIC8vXG4gIC8vIEZvciBhZHZhbmNlZCBmaWx0ZXJzIChta3MyMDEzIGFuZCBjdXN0b20pIC0gc2tpcCBvcHRpbWl6YXRpb24sXG4gIC8vIGJlY2F1c2UgbmVlZCB0byBhcHBseSBzaGFycGVuaW5nIGV2ZXJ5IHRpbWVcblxuICB2YXIgZmlsdGVyO1xuICBpZiAoaXNMYXN0U3RhZ2UgfHwgZmlsdGVyX2luZm8ucTJmLmluZGV4T2Yob3B0cy5maWx0ZXIpIDwgMCkgZmlsdGVyID0gb3B0cy5maWx0ZXI7ZWxzZSBpZiAob3B0cy5maWx0ZXIgPT09ICdib3gnKSBmaWx0ZXIgPSAnYm94JztlbHNlIGZpbHRlciA9ICdoYW1taW5nJztcbiAgb3B0cyA9IGFzc2lnbih7fSwgb3B0cywge1xuICAgIHRvV2lkdGg6IHRvV2lkdGgsXG4gICAgdG9IZWlnaHQ6IHRvSGVpZ2h0LFxuICAgIGZpbHRlcjogZmlsdGVyXG4gIH0pO1xuICB2YXIgdG1wQ2FudmFzO1xuXG4gIGlmICghaXNMYXN0U3RhZ2UpIHtcbiAgICAvLyBjcmVhdGUgdGVtcG9yYXJ5IGNhbnZhc1xuICAgIHRtcENhbnZhcyA9IHRoaXMub3B0aW9ucy5jcmVhdGVDYW52YXModG9XaWR0aCwgdG9IZWlnaHQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX190aWxlQW5kUmVzaXplKGZyb20sIGlzTGFzdFN0YWdlID8gdG8gOiB0bXBDYW52YXMsIG9wdHMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc0xhc3RTdGFnZSkgcmV0dXJuIHRvO1xuICAgIG9wdHMud2lkdGggPSB0b1dpZHRoO1xuICAgIG9wdHMuaGVpZ2h0ID0gdG9IZWlnaHQ7XG4gICAgcmV0dXJuIF90aGlzNC5fX3Byb2Nlc3NTdGFnZXMoc3RhZ2VzLCB0bXBDYW52YXMsIHRvLCBvcHRzKTtcbiAgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgaWYgKHRtcENhbnZhcykge1xuICAgICAgLy8gU2FmYXJpIDEyIHdvcmthcm91bmRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGljYS9pc3N1ZXMvMTk5XG4gICAgICB0bXBDYW52YXMud2lkdGggPSB0bXBDYW52YXMuaGVpZ2h0ID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9KTtcbn07XG5cblBpY2EucHJvdG90eXBlLl9fcmVzaXplVmlhQ3JlYXRlSW1hZ2VCaXRtYXAgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIG9wdHMpIHtcbiAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgdmFyIHRvQ3R4ID0gdG8uZ2V0Q29udGV4dCgnMmQnKTtcbiAgdGhpcy5kZWJ1ZygnUmVzaXplIHZpYSBjcmVhdGVJbWFnZUJpdG1hcCgpJyk7XG4gIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChmcm9tLCB7XG4gICAgcmVzaXplV2lkdGg6IG9wdHMudG9XaWR0aCxcbiAgICByZXNpemVIZWlnaHQ6IG9wdHMudG9IZWlnaHQsXG4gICAgcmVzaXplUXVhbGl0eTogdXRpbHMuY2liX3F1YWxpdHlfbmFtZShmaWx0ZXJfaW5mby5mMnFbb3B0cy5maWx0ZXJdKVxuICB9KS50aGVuKGZ1bmN0aW9uIChpbWFnZUJpdG1hcCkge1xuICAgIGlmIChvcHRzLmNhbmNlbGVkKSByZXR1cm4gb3B0cy5jYW5jZWxUb2tlbjsgLy8gaWYgbm8gdW5zaGFycCAtIGRyYXcgZGlyZWN0bHkgdG8gb3V0cHV0IGNhbnZhc1xuXG4gICAgaWYgKCFvcHRzLnVuc2hhcnBBbW91bnQpIHtcbiAgICAgIHRvQ3R4LmRyYXdJbWFnZShpbWFnZUJpdG1hcCwgMCwgMCk7XG4gICAgICBpbWFnZUJpdG1hcC5jbG9zZSgpO1xuICAgICAgdG9DdHggPSBudWxsO1xuXG4gICAgICBfdGhpczUuZGVidWcoJ0ZpbmlzaGVkIScpO1xuXG4gICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgX3RoaXM1LmRlYnVnKCdVbnNoYXJwIHJlc3VsdCcpO1xuXG4gICAgdmFyIHRtcENhbnZhcyA9IF90aGlzNS5vcHRpb25zLmNyZWF0ZUNhbnZhcyhvcHRzLnRvV2lkdGgsIG9wdHMudG9IZWlnaHQpO1xuXG4gICAgdmFyIHRtcEN0eCA9IHRtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRtcEN0eC5kcmF3SW1hZ2UoaW1hZ2VCaXRtYXAsIDAsIDApO1xuICAgIGltYWdlQml0bWFwLmNsb3NlKCk7XG4gICAgdmFyIGlEYXRhID0gdG1wQ3R4LmdldEltYWdlRGF0YSgwLCAwLCBvcHRzLnRvV2lkdGgsIG9wdHMudG9IZWlnaHQpO1xuXG4gICAgX3RoaXM1Ll9fbWF0aGxpYi51bnNoYXJwX21hc2soaURhdGEuZGF0YSwgb3B0cy50b1dpZHRoLCBvcHRzLnRvSGVpZ2h0LCBvcHRzLnVuc2hhcnBBbW91bnQsIG9wdHMudW5zaGFycFJhZGl1cywgb3B0cy51bnNoYXJwVGhyZXNob2xkKTtcblxuICAgIHRvQ3R4LnB1dEltYWdlRGF0YShpRGF0YSwgMCwgMCk7IC8vIFNhZmFyaSAxMiB3b3JrYXJvdW5kXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9waWNhL2lzc3Vlcy8xOTlcblxuICAgIHRtcENhbnZhcy53aWR0aCA9IHRtcENhbnZhcy5oZWlnaHQgPSAwO1xuICAgIGlEYXRhID0gdG1wQ3R4ID0gdG1wQ2FudmFzID0gdG9DdHggPSBudWxsO1xuXG4gICAgX3RoaXM1LmRlYnVnKCdGaW5pc2hlZCEnKTtcblxuICAgIHJldHVybiB0bztcbiAgfSk7XG59O1xuXG5QaWNhLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgdGhpcy5kZWJ1ZygnU3RhcnQgcmVzaXplLi4uJyk7XG4gIHZhciBvcHRzID0gYXNzaWduKHt9LCBERUZBVUxUX1JFU0laRV9PUFRTKTtcblxuICBpZiAoIWlzTmFOKG9wdGlvbnMpKSB7XG4gICAgb3B0cyA9IGFzc2lnbihvcHRzLCB7XG4gICAgICBxdWFsaXR5OiBvcHRpb25zXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucykge1xuICAgIG9wdHMgPSBhc3NpZ24ob3B0cywgb3B0aW9ucyk7XG4gIH1cblxuICBvcHRzLnRvV2lkdGggPSB0by53aWR0aDtcbiAgb3B0cy50b0hlaWdodCA9IHRvLmhlaWdodDtcbiAgb3B0cy53aWR0aCA9IGZyb20ubmF0dXJhbFdpZHRoIHx8IGZyb20ud2lkdGg7XG4gIG9wdHMuaGVpZ2h0ID0gZnJvbS5uYXR1cmFsSGVpZ2h0IHx8IGZyb20uaGVpZ2h0OyAvLyBMZWdhY3kgYC5xdWFsaXR5YCBvcHRpb25cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdHMsICdxdWFsaXR5JykpIHtcbiAgICBpZiAob3B0cy5xdWFsaXR5IDwgMCB8fCBvcHRzLnF1YWxpdHkgPiAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQaWNhOiAucXVhbGl0eSBzaG91bGQgYmUgWzAuLjNdLCBnb3QgXCIuY29uY2F0KG9wdHMucXVhbGl0eSkpO1xuICAgIH1cblxuICAgIG9wdHMuZmlsdGVyID0gZmlsdGVyX2luZm8ucTJmW29wdHMucXVhbGl0eV07XG4gIH0gLy8gUHJldmVudCBzdGVwcGVyIGZyb20gaW5maW5pdGUgbG9vcFxuXG5cbiAgaWYgKHRvLndpZHRoID09PSAwIHx8IHRvLmhlaWdodCA9PT0gMCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIG91dHB1dCBzaXplOiBcIi5jb25jYXQodG8ud2lkdGgsIFwieFwiKS5jb25jYXQodG8uaGVpZ2h0KSkpO1xuICB9XG5cbiAgaWYgKG9wdHMudW5zaGFycFJhZGl1cyA+IDIpIG9wdHMudW5zaGFycFJhZGl1cyA9IDI7XG4gIG9wdHMuY2FuY2VsZWQgPSBmYWxzZTtcblxuICBpZiAob3B0cy5jYW5jZWxUb2tlbikge1xuICAgIC8vIFdyYXAgY2FuY2VsVG9rZW4gdG8gYXZvaWQgc3VjY2Vzc2l2ZSByZXNvbHZlICYgc2V0IGZsYWdcbiAgICBvcHRzLmNhbmNlbFRva2VuID0gb3B0cy5jYW5jZWxUb2tlbi50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBvcHRzLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgIHRocm93IGRhdGE7XG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgb3B0cy5jYW5jZWxlZCA9IHRydWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgREVTVF9USUxFX0JPUkRFUiA9IDM7IC8vIE1heCBwb3NzaWJsZSBmaWx0ZXIgd2luZG93IHNpemVcblxuICBvcHRzLl9fZGVzdFRpbGVCb3JkZXIgPSBNYXRoLmNlaWwoTWF0aC5tYXgoREVTVF9USUxFX0JPUkRFUiwgMi41ICogb3B0cy51bnNoYXJwUmFkaXVzIHwgMCkpO1xuICByZXR1cm4gdGhpcy5pbml0KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG9wdHMuY2FuY2VsZWQpIHJldHVybiBvcHRzLmNhbmNlbFRva2VuOyAvLyBpZiBjcmVhdGVJbWFnZUJpdG1hcCBzdXBwb3J0cyByZXNpemUsIGp1c3QgZG8gaXQgYW5kIHJldHVyblxuXG4gICAgaWYgKF90aGlzNi5mZWF0dXJlcy5jaWIpIHtcbiAgICAgIGlmIChmaWx0ZXJfaW5mby5xMmYuaW5kZXhPZihvcHRzLmZpbHRlcikgPj0gMCkge1xuICAgICAgICByZXR1cm4gX3RoaXM2Ll9fcmVzaXplVmlhQ3JlYXRlSW1hZ2VCaXRtYXAoZnJvbSwgdG8sIG9wdHMpO1xuICAgICAgfVxuXG4gICAgICBfdGhpczYuZGVidWcoJ2NpYiBpcyBlbmFibGVkLCBidXQgbm90IHN1cHBvcnRzIHByb3ZpZGVkIGZpbHRlciwgZmFsbGJhY2sgdG8gbWFudWFsIG1hdGgnKTtcbiAgICB9XG5cbiAgICBpZiAoIUNBTl9VU0VfQ0FOVkFTX0dFVF9JTUFHRV9EQVRBKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdQaWNhOiBjYW5ub3QgdXNlIGdldEltYWdlRGF0YSBvbiBjYW52YXMsICcgKyBcIm1ha2Ugc3VyZSBmaW5nZXJwcmludGluZyBwcm90ZWN0aW9uIGlzbid0IGVuYWJsZWRcIik7XG4gICAgICBlcnIuY29kZSA9ICdFUlJfR0VUX0lNQUdFX0RBVEEnO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gLy9cbiAgICAvLyBObyBlYXN5IHdheSwgbGV0J3MgcmVzaXplIG1hbnVhbGx5IHZpYSBhcnJheXNcbiAgICAvL1xuXG5cbiAgICB2YXIgc3RhZ2VzID0gY3JlYXRlU3RhZ2VzKG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0LCBvcHRzLnRvV2lkdGgsIG9wdHMudG9IZWlnaHQsIF90aGlzNi5vcHRpb25zLnRpbGUsIG9wdHMuX19kZXN0VGlsZUJvcmRlcik7XG4gICAgcmV0dXJuIF90aGlzNi5fX3Byb2Nlc3NTdGFnZXMoc3RhZ2VzLCBmcm9tLCB0bywgb3B0cyk7XG4gIH0pO1xufTsgLy8gUkdCQSBidWZmZXIgcmVzaXplXG4vL1xuXG5cblBpY2EucHJvdG90eXBlLnJlc2l6ZUJ1ZmZlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gIHZhciBvcHRzID0gYXNzaWduKHt9LCBERUZBVUxUX1JFU0laRV9PUFRTLCBvcHRpb25zKTsgLy8gTGVnYWN5IGAucXVhbGl0eWAgb3B0aW9uXG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRzLCAncXVhbGl0eScpKSB7XG4gICAgaWYgKG9wdHMucXVhbGl0eSA8IDAgfHwgb3B0cy5xdWFsaXR5ID4gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGljYTogLnF1YWxpdHkgc2hvdWxkIGJlIFswLi4zXSwgZ290IFwiLmNvbmNhdChvcHRzLnF1YWxpdHkpKTtcbiAgICB9XG5cbiAgICBvcHRzLmZpbHRlciA9IGZpbHRlcl9pbmZvLnEyZltvcHRzLnF1YWxpdHldO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuaW5pdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGhpczcuX19tYXRobGliLnJlc2l6ZUFuZFVuc2hhcnAob3B0cyk7XG4gIH0pO1xufTtcblxuUGljYS5wcm90b3R5cGUudG9CbG9iID0gZnVuY3Rpb24gKGNhbnZhcywgbWltZVR5cGUsIHF1YWxpdHkpIHtcbiAgbWltZVR5cGUgPSBtaW1lVHlwZSB8fCAnaW1hZ2UvcG5nJztcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgaWYgKGNhbnZhcy50b0Jsb2IpIHtcbiAgICAgIGNhbnZhcy50b0Jsb2IoZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoYmxvYik7XG4gICAgICB9LCBtaW1lVHlwZSwgcXVhbGl0eSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNhbnZhcy5jb252ZXJ0VG9CbG9iKSB7XG4gICAgICByZXNvbHZlKGNhbnZhcy5jb252ZXJ0VG9CbG9iKHtcbiAgICAgICAgdHlwZTogbWltZVR5cGUsXG4gICAgICAgIHF1YWxpdHk6IHF1YWxpdHlcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZhbGxiYWNrIGZvciBvbGQgYnJvd3NlcnNcblxuXG4gICAgdmFyIGFzU3RyaW5nID0gYXRvYihjYW52YXMudG9EYXRhVVJMKG1pbWVUeXBlLCBxdWFsaXR5KS5zcGxpdCgnLCcpWzFdKTtcbiAgICB2YXIgbGVuID0gYXNTdHJpbmcubGVuZ3RoO1xuICAgIHZhciBhc0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KGxlbik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhc0J1ZmZlcltpXSA9IGFzU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuXG4gICAgcmVzb2x2ZShuZXcgQmxvYihbYXNCdWZmZXJdLCB7XG4gICAgICB0eXBlOiBtaW1lVHlwZVxuICAgIH0pKTtcbiAgfSk7XG59O1xuXG5QaWNhLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBpY2E7XG5cbn0se1wiLi9saWIvbWF0aGxpYlwiOjEsXCIuL2xpYi9tbV9yZXNpemUvcmVzaXplX2ZpbHRlcl9pbmZvXCI6NyxcIi4vbGliL3Bvb2xcIjoxMyxcIi4vbGliL3N0ZXBwZXJcIjoxNCxcIi4vbGliL3RpbGVyXCI6MTUsXCIuL2xpYi91dGlsc1wiOjE2LFwiLi9saWIvd29ya2VyXCI6MTcsXCJvYmplY3QtYXNzaWduXCI6MjIsXCJ3ZWJ3b3JraWZ5XCI6MjN9XX0se30sW10pKFwiL2luZGV4LmpzXCIpXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pica/dist/pica.js\n");

/***/ }),

/***/ "./src/glsl/copy.frag":
/*!****************************!*\
  !*** ./src/glsl/copy.frag ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"precision mediump float;\\r\\nuniform sampler2D texture;\\r\\nuniform vec2 screenSize;\\r\\nuniform vec2 u_offset;\\r\\n\\r\\nvoid main() {\\r\\n    gl_FragColor = texture2D(texture, (gl_FragCoord.xy + u_offset) / screenSize);\\r\\n}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZ2xzbC9jb3B5LmZyYWcuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLHlCQUF5Qiw4QkFBOEIsNEJBQTRCLDBCQUEwQixxQkFBcUIscUZBQXFGLEtBQUssQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9nbHNsL2NvcHkuZnJhZz84NmUxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXHJcXG51bmlmb3JtIHZlYzIgc2NyZWVuU2l6ZTtcXHJcXG51bmlmb3JtIHZlYzIgdV9vZmZzZXQ7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZSwgKGdsX0ZyYWdDb29yZC54eSArIHVfb2Zmc2V0KSAvIHNjcmVlblNpemUpO1xcclxcbn1cIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/glsl/copy.frag\n");

/***/ }),

/***/ "./src/glsl/copy.vert":
/*!****************************!*\
  !*** ./src/glsl/copy.vert ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"attribute vec2 a_position;\\r\\n\\r\\nvarying vec2 v_texCoord;\\r\\n\\r\\nvoid main() {\\r\\n  \\r\\n  v_texCoord = a_position;\\r\\n  gl_Position = vec4(a_position, 0.0, 1.0);\\r\\n}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZ2xzbC9jb3B5LnZlcnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLDJCQUEyQixnQ0FBZ0MscUJBQXFCLG9DQUFvQywrQ0FBK0MsS0FBSyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2dsc2wvY29weS52ZXJ0P2Y2NjIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG4gIFxcclxcbiAgdl90ZXhDb29yZCA9IGFfcG9zaXRpb247XFxyXFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQoYV9wb3NpdGlvbiwgMC4wLCAxLjApO1xcclxcbn1cIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/glsl/copy.vert\n");

/***/ }),

/***/ "./src/glsl/draw.frag":
/*!****************************!*\
  !*** ./src/glsl/draw.frag ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"precision mediump float;\\r\\nuniform sampler2D texture;\\r\\nuniform vec2 screenSize;\\r\\n\\r\\nuniform vec2 u_org;\\r\\nuniform vec2 u_end;\\r\\nuniform float u_rad;\\r\\nuniform vec4 u_col;\\r\\n\\r\\nuniform int u_mode;\\r\\n\\r\\n\\r\\nfloat d_1(vec2 o, vec2 e) {\\r\\n    vec2 delta = abs(e - o);\\r\\n    // if(delta.x > 0.5 * screenSize.x)\\r\\n    //     delta.x = screenSize.x - delta.x;\\r\\n\\r\\n    // if(delta.y > 0.5 * screenSize.y)\\r\\n    //     delta.y = screenSize.y - delta.y;\\r\\n\\r\\n    return delta.x + delta.y;\\r\\n}\\r\\n\\r\\n\\r\\nfloat d_2(vec2 o, vec2 e) {\\r\\n    vec2 delta = abs(e - o);\\r\\n    // if(delta.x > 0.5 * screenSize.x)\\r\\n    //     delta.x = screenSize.x - delta.x;\\r\\n\\r\\n    // if(delta.y > 0.5 * screenSize.y)\\r\\n    //     delta.y = screenSize.y - delta.y;\\r\\n\\r\\n    delta = delta * delta;\\r\\n    return sqrt(delta.x + delta.y);\\r\\n}\\r\\n\\r\\nfloat d_inf(vec2 o, vec2 e) {\\r\\n    vec2 delta = abs(e - o);\\r\\n    // if(delta.x > 0.5 * screenSize.x)\\r\\n    //     delta.x = screenSize.x - delta.x;\\r\\n\\r\\n    // if(delta.y > 0.5 * screenSize.y)\\r\\n    //     delta.y = screenSize.y - delta.y;\\r\\n\\r\\n    return max(delta.x, delta.y);\\r\\n}\\r\\n\\r\\nfloat dist(vec2 a, vec2 b) {\\r\\n    if(u_mode == 0)\\r\\n        return d_inf(a,b);\\r\\n\\r\\n    if(u_mode == 1)\\r\\n        return d_1(a,b);\\r\\n\\r\\n    return d_2(a,b);\\r\\n}\\r\\n\\r\\nfloat ldist_1(vec2 v, vec2 w, vec2 p) {\\r\\n    // we wanna solve for t \\r\\n    // v + t*(w-v) = (x,_)\\r\\n    // or\\r\\n    // v + t*(w-v) = (_,y)\\r\\n    // Coz shortest path in manhattan is a straight vertical or horizontal line\\r\\n\\r\\n    vec2 txy = (p - v) / (w - v);\\r\\n\\r\\n    txy = clamp(txy, vec2(0.0, 0.0), vec2(1.0, 1.0));\\r\\n    vec2 projection_x = v + txy.x * (w - v);  // Projection falls on the segment\\r\\n    vec2 projection_y = v + txy.y * (w - v);  // Projection falls on the segment\\r\\n    return min(dist(p, projection_x), dist(p, projection_y));\\r\\n}\\r\\n\\r\\nfloat ldist_inf(vec2 v, vec2 w, vec2 p) {\\r\\n    // we wanna solve for t \\r\\n    // v + t*(w-v) = p + _ * (1, -1)\\r\\n    // or\\r\\n    // v + t*(w-v) = p + _ * (1, -1)\\r\\n    // Coz shortest path in inf_norm is a straight diagonal line\\r\\n\\r\\n    float t_pp = (p.x - v.x + v.y - p.y) / (w.x - v.x - w.y + v.y);\\r\\n    float t_pm = (p.x - v.x - v.y + p.y) / (w.x - v.x + w.y - v.y);\\r\\n\\r\\n    t_pp = clamp(t_pp, 0.0, 1.0);\\r\\n    t_pm = clamp(t_pm, 0.0, 1.0);\\r\\n    vec2 projection_pp = v + t_pp * (w - v);  // Projection falls on the segment\\r\\n    vec2 projection_pm = v + t_pm * (w - v);  // Projection falls on the segment\\r\\n    return min(dist(p, projection_pp), dist(p, projection_pm));\\r\\n}\\r\\n\\r\\nfloat ldist_2(vec2 v, vec2 w, vec2 p) {\\r\\n    // Consider the line extending the segment, parameterized as v + t (w - v).\\r\\n    // We find projection of point p onto the line. \\r\\n    // It falls where t = [(p-v) . (w-v)] / |w-v|^2\\r\\n    // We clamp t from [0,1] to handle points outside the segment vw.\\r\\n    float t = clamp(dot(p - v, w - v) / dot(v - w, v - w), 0.0, 1.0);\\r\\n    vec2 projection = v + t * (w - v);  // Projection falls on the segment\\r\\n    return dist(p, projection);\\r\\n}\\r\\n\\r\\nfloat line_dist(vec2 v, vec2 w, vec2 p) {\\r\\n    // Return minimum distance between line segment vw and point p\\r\\n    float l2 = dot(v - w, v - w);  // i.e. |w-v|^2 -  avoid a sqrt\\r\\n    if (l2 < 1.0) return dist(p, v);   // v == w case\\r\\n    \\r\\n    if(u_mode == 0)\\r\\n        return ldist_inf(v,w,p);\\r\\n\\r\\n    if(u_mode == 1)\\r\\n        return ldist_1(v,w,p);\\r\\n\\r\\n    return ldist_2(v,w,p);\\r\\n}\\r\\n\\r\\nvoid main(){\\r\\n\\r\\n    gl_FragColor = texture2D(texture, gl_FragCoord.xy / screenSize);\\r\\n\\r\\n    if(line_dist(u_org, u_end, gl_FragCoord.xy) <= u_rad + 0.55)\\r\\n    {\\r\\n        gl_FragColor=u_col;\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    float dx = 0.0;\\r\\n    float dy = 0.0;\\r\\n    vec2 tempOrg = u_org;\\r\\n    vec2 tempEnd = u_end;\\r\\n\\r\\n    return;\\r\\n    // wrap for thick brushes\\r\\n    \\r\\n    if(gl_FragCoord.x <= u_rad)\\r\\n        dx = screenSize.x;\\r\\n    else if(gl_FragCoord.x >= screenSize.x - u_rad)\\r\\n        dx = -screenSize.x;\\r\\n\\r\\n    if(dx!=0.0 && line_dist(u_org, u_end, gl_FragCoord.xy + vec2(dx,0)) <= u_rad + 0.55)\\r\\n    {\\r\\n        gl_FragColor=u_col;\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    if(gl_FragCoord.y <= u_rad)\\r\\n        dy = screenSize.y;\\r\\n    else if(gl_FragCoord.y >= screenSize.y - u_rad)\\r\\n        dy = -screenSize.y;\\r\\n\\r\\n    if(dy!=0.0 && line_dist(u_org, u_end, gl_FragCoord.xy + vec2(0,dy)) <= u_rad + 0.55)\\r\\n    {\\r\\n        gl_FragColor=u_col;\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    if(dy!=0.0 && dx!=0.0 && line_dist(u_org, u_end, gl_FragCoord.xy + vec2(dx,dy)) <= u_rad + 0.55)\\r\\n    {\\r\\n        gl_FragColor=u_col;\\r\\n        return;\\r\\n    }\\r\\n}\\r\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZ2xzbC9kcmF3LmZyYWcuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLHlCQUF5Qiw4QkFBOEIsNEJBQTRCLDJCQUEyQix1QkFBdUIsd0JBQXdCLHVCQUF1QiwyQkFBMkIsdUNBQXVDLGdDQUFnQywyRkFBMkYsK0ZBQStGLHFDQUFxQyxLQUFLLHVDQUF1QyxnQ0FBZ0MsMkZBQTJGLCtGQUErRixrQ0FBa0MsdUNBQXVDLEtBQUsscUNBQXFDLGdDQUFnQywyRkFBMkYsK0ZBQStGLHlDQUF5QyxLQUFLLG9DQUFvQyxxREFBcUQsdURBQXVELDRCQUE0QixLQUFLLCtDQUErQyxxT0FBcU8sNkRBQTZELGtEQUFrRCxvRkFBb0YsbUdBQW1HLEtBQUssaURBQWlELDRRQUE0USx1RUFBdUUseUNBQXlDLHFDQUFxQyxrREFBa0Qsb0ZBQW9GLHFHQUFxRyxLQUFLLCtDQUErQyxvVkFBb1YsNENBQTRDLHFFQUFxRSxLQUFLLGlEQUFpRCw2R0FBNkcsMEVBQTBFLGlGQUFpRiw2REFBNkQsa0NBQWtDLEtBQUssb0JBQW9CLDRFQUE0RSxpRkFBaUYsK0JBQStCLG1CQUFtQixTQUFTLDJCQUEyQix1QkFBdUIsNkJBQTZCLDZCQUE2QixtQkFBbUIsMEdBQTBHLHNGQUFzRix5R0FBeUcsK0JBQStCLG1CQUFtQixTQUFTLHFFQUFxRSxzRkFBc0YseUdBQXlHLCtCQUErQixtQkFBbUIsU0FBUyxxSEFBcUgsK0JBQStCLG1CQUFtQixTQUFTLEtBQUssS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9nbHNsL2RyYXcuZnJhZz8yYmZhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXHJcXG51bmlmb3JtIHZlYzIgc2NyZWVuU2l6ZTtcXHJcXG5cXHJcXG51bmlmb3JtIHZlYzIgdV9vcmc7XFxyXFxudW5pZm9ybSB2ZWMyIHVfZW5kO1xcclxcbnVuaWZvcm0gZmxvYXQgdV9yYWQ7XFxyXFxudW5pZm9ybSB2ZWM0IHVfY29sO1xcclxcblxcclxcbnVuaWZvcm0gaW50IHVfbW9kZTtcXHJcXG5cXHJcXG5cXHJcXG5mbG9hdCBkXzEodmVjMiBvLCB2ZWMyIGUpIHtcXHJcXG4gICAgdmVjMiBkZWx0YSA9IGFicyhlIC0gbyk7XFxyXFxuICAgIC8vIGlmKGRlbHRhLnggPiAwLjUgKiBzY3JlZW5TaXplLngpXFxyXFxuICAgIC8vICAgICBkZWx0YS54ID0gc2NyZWVuU2l6ZS54IC0gZGVsdGEueDtcXHJcXG5cXHJcXG4gICAgLy8gaWYoZGVsdGEueSA+IDAuNSAqIHNjcmVlblNpemUueSlcXHJcXG4gICAgLy8gICAgIGRlbHRhLnkgPSBzY3JlZW5TaXplLnkgLSBkZWx0YS55O1xcclxcblxcclxcbiAgICByZXR1cm4gZGVsdGEueCArIGRlbHRhLnk7XFxyXFxufVxcclxcblxcclxcblxcclxcbmZsb2F0IGRfMih2ZWMyIG8sIHZlYzIgZSkge1xcclxcbiAgICB2ZWMyIGRlbHRhID0gYWJzKGUgLSBvKTtcXHJcXG4gICAgLy8gaWYoZGVsdGEueCA+IDAuNSAqIHNjcmVlblNpemUueClcXHJcXG4gICAgLy8gICAgIGRlbHRhLnggPSBzY3JlZW5TaXplLnggLSBkZWx0YS54O1xcclxcblxcclxcbiAgICAvLyBpZihkZWx0YS55ID4gMC41ICogc2NyZWVuU2l6ZS55KVxcclxcbiAgICAvLyAgICAgZGVsdGEueSA9IHNjcmVlblNpemUueSAtIGRlbHRhLnk7XFxyXFxuXFxyXFxuICAgIGRlbHRhID0gZGVsdGEgKiBkZWx0YTtcXHJcXG4gICAgcmV0dXJuIHNxcnQoZGVsdGEueCArIGRlbHRhLnkpO1xcclxcbn1cXHJcXG5cXHJcXG5mbG9hdCBkX2luZih2ZWMyIG8sIHZlYzIgZSkge1xcclxcbiAgICB2ZWMyIGRlbHRhID0gYWJzKGUgLSBvKTtcXHJcXG4gICAgLy8gaWYoZGVsdGEueCA+IDAuNSAqIHNjcmVlblNpemUueClcXHJcXG4gICAgLy8gICAgIGRlbHRhLnggPSBzY3JlZW5TaXplLnggLSBkZWx0YS54O1xcclxcblxcclxcbiAgICAvLyBpZihkZWx0YS55ID4gMC41ICogc2NyZWVuU2l6ZS55KVxcclxcbiAgICAvLyAgICAgZGVsdGEueSA9IHNjcmVlblNpemUueSAtIGRlbHRhLnk7XFxyXFxuXFxyXFxuICAgIHJldHVybiBtYXgoZGVsdGEueCwgZGVsdGEueSk7XFxyXFxufVxcclxcblxcclxcbmZsb2F0IGRpc3QodmVjMiBhLCB2ZWMyIGIpIHtcXHJcXG4gICAgaWYodV9tb2RlID09IDApXFxyXFxuICAgICAgICByZXR1cm4gZF9pbmYoYSxiKTtcXHJcXG5cXHJcXG4gICAgaWYodV9tb2RlID09IDEpXFxyXFxuICAgICAgICByZXR1cm4gZF8xKGEsYik7XFxyXFxuXFxyXFxuICAgIHJldHVybiBkXzIoYSxiKTtcXHJcXG59XFxyXFxuXFxyXFxuZmxvYXQgbGRpc3RfMSh2ZWMyIHYsIHZlYzIgdywgdmVjMiBwKSB7XFxyXFxuICAgIC8vIHdlIHdhbm5hIHNvbHZlIGZvciB0IFxcclxcbiAgICAvLyB2ICsgdCoody12KSA9ICh4LF8pXFxyXFxuICAgIC8vIG9yXFxyXFxuICAgIC8vIHYgKyB0Kih3LXYpID0gKF8seSlcXHJcXG4gICAgLy8gQ296IHNob3J0ZXN0IHBhdGggaW4gbWFuaGF0dGFuIGlzIGEgc3RyYWlnaHQgdmVydGljYWwgb3IgaG9yaXpvbnRhbCBsaW5lXFxyXFxuXFxyXFxuICAgIHZlYzIgdHh5ID0gKHAgLSB2KSAvICh3IC0gdik7XFxyXFxuXFxyXFxuICAgIHR4eSA9IGNsYW1wKHR4eSwgdmVjMigwLjAsIDAuMCksIHZlYzIoMS4wLCAxLjApKTtcXHJcXG4gICAgdmVjMiBwcm9qZWN0aW9uX3ggPSB2ICsgdHh5LnggKiAodyAtIHYpOyAgLy8gUHJvamVjdGlvbiBmYWxscyBvbiB0aGUgc2VnbWVudFxcclxcbiAgICB2ZWMyIHByb2plY3Rpb25feSA9IHYgKyB0eHkueSAqICh3IC0gdik7ICAvLyBQcm9qZWN0aW9uIGZhbGxzIG9uIHRoZSBzZWdtZW50XFxyXFxuICAgIHJldHVybiBtaW4oZGlzdChwLCBwcm9qZWN0aW9uX3gpLCBkaXN0KHAsIHByb2plY3Rpb25feSkpO1xcclxcbn1cXHJcXG5cXHJcXG5mbG9hdCBsZGlzdF9pbmYodmVjMiB2LCB2ZWMyIHcsIHZlYzIgcCkge1xcclxcbiAgICAvLyB3ZSB3YW5uYSBzb2x2ZSBmb3IgdCBcXHJcXG4gICAgLy8gdiArIHQqKHctdikgPSBwICsgXyAqICgxLCAtMSlcXHJcXG4gICAgLy8gb3JcXHJcXG4gICAgLy8gdiArIHQqKHctdikgPSBwICsgXyAqICgxLCAtMSlcXHJcXG4gICAgLy8gQ296IHNob3J0ZXN0IHBhdGggaW4gaW5mX25vcm0gaXMgYSBzdHJhaWdodCBkaWFnb25hbCBsaW5lXFxyXFxuXFxyXFxuICAgIGZsb2F0IHRfcHAgPSAocC54IC0gdi54ICsgdi55IC0gcC55KSAvICh3LnggLSB2LnggLSB3LnkgKyB2LnkpO1xcclxcbiAgICBmbG9hdCB0X3BtID0gKHAueCAtIHYueCAtIHYueSArIHAueSkgLyAody54IC0gdi54ICsgdy55IC0gdi55KTtcXHJcXG5cXHJcXG4gICAgdF9wcCA9IGNsYW1wKHRfcHAsIDAuMCwgMS4wKTtcXHJcXG4gICAgdF9wbSA9IGNsYW1wKHRfcG0sIDAuMCwgMS4wKTtcXHJcXG4gICAgdmVjMiBwcm9qZWN0aW9uX3BwID0gdiArIHRfcHAgKiAodyAtIHYpOyAgLy8gUHJvamVjdGlvbiBmYWxscyBvbiB0aGUgc2VnbWVudFxcclxcbiAgICB2ZWMyIHByb2plY3Rpb25fcG0gPSB2ICsgdF9wbSAqICh3IC0gdik7ICAvLyBQcm9qZWN0aW9uIGZhbGxzIG9uIHRoZSBzZWdtZW50XFxyXFxuICAgIHJldHVybiBtaW4oZGlzdChwLCBwcm9qZWN0aW9uX3BwKSwgZGlzdChwLCBwcm9qZWN0aW9uX3BtKSk7XFxyXFxufVxcclxcblxcclxcbmZsb2F0IGxkaXN0XzIodmVjMiB2LCB2ZWMyIHcsIHZlYzIgcCkge1xcclxcbiAgICAvLyBDb25zaWRlciB0aGUgbGluZSBleHRlbmRpbmcgdGhlIHNlZ21lbnQsIHBhcmFtZXRlcml6ZWQgYXMgdiArIHQgKHcgLSB2KS5cXHJcXG4gICAgLy8gV2UgZmluZCBwcm9qZWN0aW9uIG9mIHBvaW50IHAgb250byB0aGUgbGluZS4gXFxyXFxuICAgIC8vIEl0IGZhbGxzIHdoZXJlIHQgPSBbKHAtdikgLiAody12KV0gLyB8dy12fF4yXFxyXFxuICAgIC8vIFdlIGNsYW1wIHQgZnJvbSBbMCwxXSB0byBoYW5kbGUgcG9pbnRzIG91dHNpZGUgdGhlIHNlZ21lbnQgdncuXFxyXFxuICAgIGZsb2F0IHQgPSBjbGFtcChkb3QocCAtIHYsIHcgLSB2KSAvIGRvdCh2IC0gdywgdiAtIHcpLCAwLjAsIDEuMCk7XFxyXFxuICAgIHZlYzIgcHJvamVjdGlvbiA9IHYgKyB0ICogKHcgLSB2KTsgIC8vIFByb2plY3Rpb24gZmFsbHMgb24gdGhlIHNlZ21lbnRcXHJcXG4gICAgcmV0dXJuIGRpc3QocCwgcHJvamVjdGlvbik7XFxyXFxufVxcclxcblxcclxcbmZsb2F0IGxpbmVfZGlzdCh2ZWMyIHYsIHZlYzIgdywgdmVjMiBwKSB7XFxyXFxuICAgIC8vIFJldHVybiBtaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gbGluZSBzZWdtZW50IHZ3IGFuZCBwb2ludCBwXFxyXFxuICAgIGZsb2F0IGwyID0gZG90KHYgLSB3LCB2IC0gdyk7ICAvLyBpLmUuIHx3LXZ8XjIgLSAgYXZvaWQgYSBzcXJ0XFxyXFxuICAgIGlmIChsMiA8IDEuMCkgcmV0dXJuIGRpc3QocCwgdik7ICAgLy8gdiA9PSB3IGNhc2VcXHJcXG4gICAgXFxyXFxuICAgIGlmKHVfbW9kZSA9PSAwKVxcclxcbiAgICAgICAgcmV0dXJuIGxkaXN0X2luZih2LHcscCk7XFxyXFxuXFxyXFxuICAgIGlmKHVfbW9kZSA9PSAxKVxcclxcbiAgICAgICAgcmV0dXJuIGxkaXN0XzEodix3LHApO1xcclxcblxcclxcbiAgICByZXR1cm4gbGRpc3RfMih2LHcscCk7XFxyXFxufVxcclxcblxcclxcbnZvaWQgbWFpbigpe1xcclxcblxcclxcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZSwgZ2xfRnJhZ0Nvb3JkLnh5IC8gc2NyZWVuU2l6ZSk7XFxyXFxuXFxyXFxuICAgIGlmKGxpbmVfZGlzdCh1X29yZywgdV9lbmQsIGdsX0ZyYWdDb29yZC54eSkgPD0gdV9yYWQgKyAwLjU1KVxcclxcbiAgICB7XFxyXFxuICAgICAgICBnbF9GcmFnQ29sb3I9dV9jb2w7XFxyXFxuICAgICAgICByZXR1cm47XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgZmxvYXQgZHggPSAwLjA7XFxyXFxuICAgIGZsb2F0IGR5ID0gMC4wO1xcclxcbiAgICB2ZWMyIHRlbXBPcmcgPSB1X29yZztcXHJcXG4gICAgdmVjMiB0ZW1wRW5kID0gdV9lbmQ7XFxyXFxuXFxyXFxuICAgIHJldHVybjtcXHJcXG4gICAgLy8gd3JhcCBmb3IgdGhpY2sgYnJ1c2hlc1xcclxcbiAgICBcXHJcXG4gICAgaWYoZ2xfRnJhZ0Nvb3JkLnggPD0gdV9yYWQpXFxyXFxuICAgICAgICBkeCA9IHNjcmVlblNpemUueDtcXHJcXG4gICAgZWxzZSBpZihnbF9GcmFnQ29vcmQueCA+PSBzY3JlZW5TaXplLnggLSB1X3JhZClcXHJcXG4gICAgICAgIGR4ID0gLXNjcmVlblNpemUueDtcXHJcXG5cXHJcXG4gICAgaWYoZHghPTAuMCAmJiBsaW5lX2Rpc3QodV9vcmcsIHVfZW5kLCBnbF9GcmFnQ29vcmQueHkgKyB2ZWMyKGR4LDApKSA8PSB1X3JhZCArIDAuNTUpXFxyXFxuICAgIHtcXHJcXG4gICAgICAgIGdsX0ZyYWdDb2xvcj11X2NvbDtcXHJcXG4gICAgICAgIHJldHVybjtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBpZihnbF9GcmFnQ29vcmQueSA8PSB1X3JhZClcXHJcXG4gICAgICAgIGR5ID0gc2NyZWVuU2l6ZS55O1xcclxcbiAgICBlbHNlIGlmKGdsX0ZyYWdDb29yZC55ID49IHNjcmVlblNpemUueSAtIHVfcmFkKVxcclxcbiAgICAgICAgZHkgPSAtc2NyZWVuU2l6ZS55O1xcclxcblxcclxcbiAgICBpZihkeSE9MC4wICYmIGxpbmVfZGlzdCh1X29yZywgdV9lbmQsIGdsX0ZyYWdDb29yZC54eSArIHZlYzIoMCxkeSkpIDw9IHVfcmFkICsgMC41NSlcXHJcXG4gICAge1xcclxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yPXVfY29sO1xcclxcbiAgICAgICAgcmV0dXJuO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGlmKGR5IT0wLjAgJiYgZHghPTAuMCAmJiBsaW5lX2Rpc3QodV9vcmcsIHVfZW5kLCBnbF9GcmFnQ29vcmQueHkgKyB2ZWMyKGR4LGR5KSkgPD0gdV9yYWQgKyAwLjU1KVxcclxcbiAgICB7XFxyXFxuICAgICAgICBnbF9GcmFnQ29sb3I9dV9jb2w7XFxyXFxuICAgICAgICByZXR1cm47XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXCI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/glsl/draw.frag\n");

/***/ }),

/***/ "./src/canvasController.js":
/*!*********************************!*\
  !*** ./src/canvasController.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CanvasController\": () => (/* binding */ CanvasController)\n/* harmony export */ });\n/* harmony import */ var _igloo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./igloo.js */ \"./src/igloo.js\");\n/* harmony import */ var _glsl_draw_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glsl/draw.frag */ \"./src/glsl/draw.frag\");\n/* harmony import */ var _glsl_copy_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./glsl/copy.frag */ \"./src/glsl/copy.frag\");\n/* harmony import */ var _glsl_copy_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./glsl/copy.vert */ \"./src/glsl/copy.vert\");\n\r\n\r\n\r\n\r\n\r\n\r\nclass CanvasController {\r\n    constructor(canvas, drawHook) {\r\n        this.canvas = canvas;\r\n        this.drawHook = drawHook;\r\n        this.viewsize = new Float32Array([canvas.width, canvas.height]);\r\n\r\n        var gl = canvas.getContext(\"webgl\");\r\n        if (!gl) {\r\n            throw new Error('no webgl')\r\n        }\r\n\r\n        this.gl = gl\r\n        gl.getExtension('OES_texture_float');\r\n        gl.getExtension('WEBGL_color_buffer_float');\r\n        \r\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\r\n\r\n        this.igloo = new _igloo_js__WEBPACK_IMPORTED_MODULE_0__.Igloo(gl)\r\n        this.quad = this.igloo.array(_igloo_js__WEBPACK_IMPORTED_MODULE_0__.Igloo.QUAD2);\r\n\r\n        this.program_copy = this.igloo.program(_glsl_copy_vert__WEBPACK_IMPORTED_MODULE_3__[\"default\"], _glsl_copy_frag__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\r\n        this.program_draw = this.igloo.program(_glsl_copy_vert__WEBPACK_IMPORTED_MODULE_3__[\"default\"], _glsl_draw_frag__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\r\n\r\n        this.frameBuffer = this.igloo.framebuffer();\r\n        this.tex_main = this.igloo.texture(null, gl.RGBA, gl.REPEAT, gl.NEAREST, gl.FLOAT)\r\n            .blank(this.viewsize[0], this.viewsize[1]);\r\n        this.tex_temp = this.igloo.texture(null, gl.RGBA, gl.REPEAT, gl.NEAREST, gl.FLOAT)\r\n            .blank(this.viewsize[0], this.viewsize[1]);\r\n\r\n\r\n        this.show();\r\n        this._addEvents();\r\n    }\r\n\r\n    _swapTextures() {\r\n        var tmp = this.tex_main;\r\n        this.tex_main = this.tex_temp\r\n        this.tex_temp = tmp;\r\n    };\r\n\r\n    _getMousePos(event) {\r\n        var rect = this.canvas.getBoundingClientRect();\r\n        return [\r\n            (event.pageX - rect.left),\r\n            (this.canvas.height - (event.pageY - rect.top)),\r\n        ];\r\n    };\r\n\r\n    _addEvents() {\r\n        this.start_pos = null\r\n        this.canvas.addEventListener('mousedown', e => {\r\n            e.stopPropagation();\r\n            this.start_pos = this._getMousePos(e)\r\n        })\r\n        this.canvas.addEventListener('mousemove', e => {\r\n            e.stopPropagation();\r\n            if (!this.start_pos) return;\r\n            const end_pos = this._getMousePos(e);\r\n            this.draw(this.start_pos, end_pos);\r\n            this.start_pos = end_pos;\r\n        })\r\n        this.canvas.addEventListener('mouseup', e => {\r\n            e.stopPropagation();\r\n            \r\n            if (this.drawHook && this.start_pos) this.drawHook(this);\r\n            this.start_pos = null;\r\n        })\r\n\r\n        this.canvas.addEventListener('mouseleave', e => {\r\n            e.stopPropagation();\r\n           \r\n            if (this.drawHook && this.start_pos) this.drawHook(this);\r\n            this.start_pos = null;\r\n        })\r\n    }\r\n\r\n    sync() {\r\n        this.gl.finish();\r\n    }\r\n\r\n    getArray() {\r\n        const gl = this.gl;\r\n        const texture = this.tex_main;\r\n        const [width, height] = this.viewsize;\r\n\r\n        var framebuffer = gl.createFramebuffer();\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture.texture, 0);\r\n    \r\n        // Read the contents of the framebuffer\r\n        var data = new Float32Array(width * height * 4);\r\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.FLOAT, data);\r\n\r\n        return data;\r\n    }\r\n\r\n    draw(from, to, col=null, rad=5, mode=2) {\r\n        from = new Float32Array(from);\r\n        to = new Float32Array(to);\r\n        col = col ? new Float32Array(col) : new Float32Array([1,1,1,1]);\r\n\r\n\r\n        const gl = this.gl\r\n\r\n        this.frameBuffer.attach(this.tex_temp);\r\n        gl.viewport(0, 0, this.viewsize[0], this.viewsize[1]);\r\n        this.tex_main.bind(0);\r\n        this.program_draw.use()\r\n            .attrib('a_position', this.quad, 2)\r\n            .uniformi('texture', 0)\r\n            .uniform('screenSize', this.viewsize)\r\n            .uniform('u_org', from)\r\n            .uniform('u_end', to)\r\n            .uniform('u_col', col)\r\n            .uniform('u_rad', rad-1)\r\n            .uniformi('u_mode', mode)\r\n            .draw(gl.TRIANGLE_STRIP, 4);\r\n        \r\n        this._swapTextures();\r\n        this.show();\r\n    }\r\n\r\n    shift(dx, dy) {\r\n        const gl = this.gl\r\n        this.frameBuffer.attach(this.tex_temp);\r\n        gl.viewport(0, 0, this.viewsize[0], this.viewsize[1]);\r\n        this.tex_main.bind(0);\r\n        this.program_copy.use()\r\n            .attrib('a_position', this.quad, 2)\r\n            .uniform('u_offset', new Float32Array([dx, dy]))\r\n            .uniform('screenSize', this.viewsize)\r\n            .uniformi('texture', 0)\r\n            .draw(gl.TRIANGLE_STRIP, 4);\r\n\r\n        this._swapTextures();\r\n        this.show();\r\n    }\r\n\r\n    show() {\r\n        const gl = this.gl\r\n        this.igloo.defaultFramebuffer.bind();\r\n        gl.viewport(0, 0, this.viewsize[0], this.viewsize[1]);\r\n        this.tex_main.bind(0);\r\n        this.program_copy.use()\r\n            .attrib('a_position', this.quad, 2)\r\n            .uniform('u_offset', new Float32Array([0, 0]))\r\n            .uniform('screenSize', this.viewsize)\r\n            .uniformi('texture', 0)\r\n            .draw(gl.TRIANGLE_STRIP, 4);\r\n    }\r\n\r\n\r\n    setImage(img, w, h) {\r\n        this.tex_main.set(img, w, h);\r\n        this.show();\r\n    }\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY2FudmFzQ29udHJvbGxlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFrQztBQUNsQztBQUN1QztBQUNBO0FBQ0E7QUFDdkM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUFLO0FBQzlCLHFDQUFxQyxrREFBVztBQUNoRDtBQUNBLCtDQUErQyx1REFBUSxFQUFFLHVEQUFRO0FBQ2pFLCtDQUErQyx1REFBUSxFQUFFLHVEQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NhbnZhc0NvbnRyb2xsZXIuanM/NDYwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJZ2xvbyB9IGZyb20gJy4vaWdsb28uanMnXHJcblxyXG5pbXBvcnQgZHJhd0ZyYWcgZnJvbSAnLi9nbHNsL2RyYXcuZnJhZydcclxuaW1wb3J0IGNvcHlGcmFnIGZyb20gJy4vZ2xzbC9jb3B5LmZyYWcnXHJcbmltcG9ydCBjb3B5VmVydCBmcm9tICcuL2dsc2wvY29weS52ZXJ0J1xyXG5cclxuZXhwb3J0IGNsYXNzIENhbnZhc0NvbnRyb2xsZXIge1xyXG4gICAgY29uc3RydWN0b3IoY2FudmFzLCBkcmF3SG9vaykge1xyXG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xyXG4gICAgICAgIHRoaXMuZHJhd0hvb2sgPSBkcmF3SG9vaztcclxuICAgICAgICB0aGlzLnZpZXdzaXplID0gbmV3IEZsb2F0MzJBcnJheShbY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0XSk7XHJcblxyXG4gICAgICAgIHZhciBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIik7XHJcbiAgICAgICAgaWYgKCFnbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHdlYmdsJylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZ2wgPSBnbFxyXG4gICAgICAgIGdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKTtcclxuICAgICAgICBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xyXG5cclxuICAgICAgICB0aGlzLmlnbG9vID0gbmV3IElnbG9vKGdsKVxyXG4gICAgICAgIHRoaXMucXVhZCA9IHRoaXMuaWdsb28uYXJyYXkoSWdsb28uUVVBRDIpO1xyXG5cclxuICAgICAgICB0aGlzLnByb2dyYW1fY29weSA9IHRoaXMuaWdsb28ucHJvZ3JhbShjb3B5VmVydCwgY29weUZyYWcpO1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbV9kcmF3ID0gdGhpcy5pZ2xvby5wcm9ncmFtKGNvcHlWZXJ0LCBkcmF3RnJhZyk7XHJcblxyXG4gICAgICAgIHRoaXMuZnJhbWVCdWZmZXIgPSB0aGlzLmlnbG9vLmZyYW1lYnVmZmVyKCk7XHJcbiAgICAgICAgdGhpcy50ZXhfbWFpbiA9IHRoaXMuaWdsb28udGV4dHVyZShudWxsLCBnbC5SR0JBLCBnbC5SRVBFQVQsIGdsLk5FQVJFU1QsIGdsLkZMT0FUKVxyXG4gICAgICAgICAgICAuYmxhbmsodGhpcy52aWV3c2l6ZVswXSwgdGhpcy52aWV3c2l6ZVsxXSk7XHJcbiAgICAgICAgdGhpcy50ZXhfdGVtcCA9IHRoaXMuaWdsb28udGV4dHVyZShudWxsLCBnbC5SR0JBLCBnbC5SRVBFQVQsIGdsLk5FQVJFU1QsIGdsLkZMT0FUKVxyXG4gICAgICAgICAgICAuYmxhbmsodGhpcy52aWV3c2l6ZVswXSwgdGhpcy52aWV3c2l6ZVsxXSk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLnNob3coKTtcclxuICAgICAgICB0aGlzLl9hZGRFdmVudHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBfc3dhcFRleHR1cmVzKCkge1xyXG4gICAgICAgIHZhciB0bXAgPSB0aGlzLnRleF9tYWluO1xyXG4gICAgICAgIHRoaXMudGV4X21haW4gPSB0aGlzLnRleF90ZW1wXHJcbiAgICAgICAgdGhpcy50ZXhfdGVtcCA9IHRtcDtcclxuICAgIH07XHJcblxyXG4gICAgX2dldE1vdXNlUG9zKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAoZXZlbnQucGFnZVggLSByZWN0LmxlZnQpLFxyXG4gICAgICAgICAgICAodGhpcy5jYW52YXMuaGVpZ2h0IC0gKGV2ZW50LnBhZ2VZIC0gcmVjdC50b3ApKSxcclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuXHJcbiAgICBfYWRkRXZlbnRzKCkge1xyXG4gICAgICAgIHRoaXMuc3RhcnRfcG9zID0gbnVsbFxyXG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGUgPT4ge1xyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0X3BvcyA9IHRoaXMuX2dldE1vdXNlUG9zKGUpXHJcbiAgICAgICAgfSlcclxuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBlID0+IHtcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXJ0X3BvcykgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBlbmRfcG9zID0gdGhpcy5fZ2V0TW91c2VQb3MoZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhdyh0aGlzLnN0YXJ0X3BvcywgZW5kX3Bvcyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRfcG9zID0gZW5kX3BvcztcclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBlID0+IHtcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRyYXdIb29rICYmIHRoaXMuc3RhcnRfcG9zKSB0aGlzLmRyYXdIb29rKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0X3BvcyA9IG51bGw7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGUgPT4ge1xyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAodGhpcy5kcmF3SG9vayAmJiB0aGlzLnN0YXJ0X3BvcykgdGhpcy5kcmF3SG9vayh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydF9wb3MgPSBudWxsO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgc3luYygpIHtcclxuICAgICAgICB0aGlzLmdsLmZpbmlzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEFycmF5KCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcclxuICAgICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXhfbWFpbjtcclxuICAgICAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnZpZXdzaXplO1xyXG5cclxuICAgICAgICB2YXIgZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xyXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS50ZXh0dXJlLCAwKTtcclxuICAgIFxyXG4gICAgICAgIC8vIFJlYWQgdGhlIGNvbnRlbnRzIG9mIHRoZSBmcmFtZWJ1ZmZlclxyXG4gICAgICAgIHZhciBkYXRhID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xyXG4gICAgICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIGRhdGEpO1xyXG5cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3KGZyb20sIHRvLCBjb2w9bnVsbCwgcmFkPTUsIG1vZGU9Mikge1xyXG4gICAgICAgIGZyb20gPSBuZXcgRmxvYXQzMkFycmF5KGZyb20pO1xyXG4gICAgICAgIHRvID0gbmV3IEZsb2F0MzJBcnJheSh0byk7XHJcbiAgICAgICAgY29sID0gY29sID8gbmV3IEZsb2F0MzJBcnJheShjb2wpIDogbmV3IEZsb2F0MzJBcnJheShbMSwxLDEsMV0pO1xyXG5cclxuXHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsXHJcblxyXG4gICAgICAgIHRoaXMuZnJhbWVCdWZmZXIuYXR0YWNoKHRoaXMudGV4X3RlbXApO1xyXG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMudmlld3NpemVbMF0sIHRoaXMudmlld3NpemVbMV0pO1xyXG4gICAgICAgIHRoaXMudGV4X21haW4uYmluZCgwKTtcclxuICAgICAgICB0aGlzLnByb2dyYW1fZHJhdy51c2UoKVxyXG4gICAgICAgICAgICAuYXR0cmliKCdhX3Bvc2l0aW9uJywgdGhpcy5xdWFkLCAyKVxyXG4gICAgICAgICAgICAudW5pZm9ybWkoJ3RleHR1cmUnLCAwKVxyXG4gICAgICAgICAgICAudW5pZm9ybSgnc2NyZWVuU2l6ZScsIHRoaXMudmlld3NpemUpXHJcbiAgICAgICAgICAgIC51bmlmb3JtKCd1X29yZycsIGZyb20pXHJcbiAgICAgICAgICAgIC51bmlmb3JtKCd1X2VuZCcsIHRvKVxyXG4gICAgICAgICAgICAudW5pZm9ybSgndV9jb2wnLCBjb2wpXHJcbiAgICAgICAgICAgIC51bmlmb3JtKCd1X3JhZCcsIHJhZC0xKVxyXG4gICAgICAgICAgICAudW5pZm9ybWkoJ3VfbW9kZScsIG1vZGUpXHJcbiAgICAgICAgICAgIC5kcmF3KGdsLlRSSUFOR0xFX1NUUklQLCA0KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9zd2FwVGV4dHVyZXMoKTtcclxuICAgICAgICB0aGlzLnNob3coKTtcclxuICAgIH1cclxuXHJcbiAgICBzaGlmdChkeCwgZHkpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2xcclxuICAgICAgICB0aGlzLmZyYW1lQnVmZmVyLmF0dGFjaCh0aGlzLnRleF90ZW1wKTtcclxuICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLnZpZXdzaXplWzBdLCB0aGlzLnZpZXdzaXplWzFdKTtcclxuICAgICAgICB0aGlzLnRleF9tYWluLmJpbmQoMCk7XHJcbiAgICAgICAgdGhpcy5wcm9ncmFtX2NvcHkudXNlKClcclxuICAgICAgICAgICAgLmF0dHJpYignYV9wb3NpdGlvbicsIHRoaXMucXVhZCwgMilcclxuICAgICAgICAgICAgLnVuaWZvcm0oJ3Vfb2Zmc2V0JywgbmV3IEZsb2F0MzJBcnJheShbZHgsIGR5XSkpXHJcbiAgICAgICAgICAgIC51bmlmb3JtKCdzY3JlZW5TaXplJywgdGhpcy52aWV3c2l6ZSlcclxuICAgICAgICAgICAgLnVuaWZvcm1pKCd0ZXh0dXJlJywgMClcclxuICAgICAgICAgICAgLmRyYXcoZ2wuVFJJQU5HTEVfU1RSSVAsIDQpO1xyXG5cclxuICAgICAgICB0aGlzLl9zd2FwVGV4dHVyZXMoKTtcclxuICAgICAgICB0aGlzLnNob3coKTtcclxuICAgIH1cclxuXHJcbiAgICBzaG93KCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbFxyXG4gICAgICAgIHRoaXMuaWdsb28uZGVmYXVsdEZyYW1lYnVmZmVyLmJpbmQoKTtcclxuICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLnZpZXdzaXplWzBdLCB0aGlzLnZpZXdzaXplWzFdKTtcclxuICAgICAgICB0aGlzLnRleF9tYWluLmJpbmQoMCk7XHJcbiAgICAgICAgdGhpcy5wcm9ncmFtX2NvcHkudXNlKClcclxuICAgICAgICAgICAgLmF0dHJpYignYV9wb3NpdGlvbicsIHRoaXMucXVhZCwgMilcclxuICAgICAgICAgICAgLnVuaWZvcm0oJ3Vfb2Zmc2V0JywgbmV3IEZsb2F0MzJBcnJheShbMCwgMF0pKVxyXG4gICAgICAgICAgICAudW5pZm9ybSgnc2NyZWVuU2l6ZScsIHRoaXMudmlld3NpemUpXHJcbiAgICAgICAgICAgIC51bmlmb3JtaSgndGV4dHVyZScsIDApXHJcbiAgICAgICAgICAgIC5kcmF3KGdsLlRSSUFOR0xFX1NUUklQLCA0KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgc2V0SW1hZ2UoaW1nLCB3LCBoKSB7XHJcbiAgICAgICAgdGhpcy50ZXhfbWFpbi5zZXQoaW1nLCB3LCBoKTtcclxuICAgICAgICB0aGlzLnNob3coKTtcclxuICAgIH1cclxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/canvasController.js\n");

/***/ }),

/***/ "./src/fft.js":
/*!********************!*\
  !*** ./src/fft.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CAdd\": () => (/* binding */ CAdd),\n/* harmony export */   \"CExp\": () => (/* binding */ CExp),\n/* harmony export */   \"CMagn\": () => (/* binding */ CMagn),\n/* harmony export */   \"CMul\": () => (/* binding */ CMul),\n/* harmony export */   \"CPhase\": () => (/* binding */ CPhase),\n/* harmony export */   \"CSub\": () => (/* binding */ CSub),\n/* harmony export */   \"dft\": () => (/* binding */ dft),\n/* harmony export */   \"fft\": () => (/* binding */ fft),\n/* harmony export */   \"fftPixelData\": () => (/* binding */ fftPixelData)\n/* harmony export */ });\n\r\nfunction CAdd(a, b) {\r\n    return [a[0] + b[0], a[1] + b[1]];\r\n}\r\n\r\nfunction CSub(a, b) {\r\n    return [a[0] - b[0], a[1] - b[1]];\r\n}\r\n\r\nfunction CMul(a, b) {\r\n    return [(a[0] * b[0] - a[1] * b[1]),\r\n    (a[0] * b[1] + a[1] * b[0])];\r\n}\r\n\r\nfunction CMagn(c) {\r\n    return Math.sqrt(c[0] * c[0] + c[1] * c[1]);\r\n}\r\n\r\nfunction CPhase(c) {\r\n    return Math.atan2(c[1], c[0]);\r\n}\r\n\r\nfunction CExp(c) {\r\n    const coef = Math.exp(c[0]);\r\n    return [coef * Math.cos(c[1]), coef * Math.sin(c[1])]\r\n}\r\n\r\n\r\n\r\nfunction dft(arr, dir=-1) {\r\n    const length = arr.length;\r\n    const res = [];\r\n\r\n    for (let i = 0; i < length; i++) {\r\n        res[i] = [0, 0];\r\n        for (let k = 0; k < length; k++) {\r\n            const pow = dir * Math.PI * 2 / length * k * i;\r\n            const term = arr[k]?.length ? arr[k] : [arr[k], 0];\r\n\r\n            const temp = CMul(term, CExp([0, pow]))\r\n            res[i] = CAdd(res[i], temp);\r\n        }\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\nfunction fft(arr, dir=-1, norm=false) {\r\n    function even(__, ix) {\r\n        return ix % 2 == 0;\r\n    }\r\n\r\n    function odd(__, ix) {\r\n        return ix % 2 == 1;\r\n    }\r\n\r\n    const length = arr.length;\r\n    const mult = norm ? [1/length, 0] : [1,0];\r\n    const res = [];\r\n\r\n    if (length == 1) {\r\n        return arr[0]?.length ? [arr[0]] : [[arr[0], 0]];\r\n    }\r\n\r\n    // recursion\r\n    const res_evens = fft(arr.filter(even));\r\n    const res_odds = fft(arr.filter(odd));\r\n\r\n    // Now, perform N/2 operations!\r\n    for (var k = 0; k < length / 2; k++) {\r\n        const pow = dir * Math.PI * 2 / length * k;\r\n\r\n        // t is a complex number!\r\n        const t = res_evens[k];\r\n        const e = CMul(CExp([0,pow]), res_odds[k]);\r\n\r\n        res[k] = CMul(CAdd(t, e), mult);\r\n        res[k + (length / 2)] = CMul(CSub(t, e), mult);\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\nfunction fftPixelData(data,w,h, dir=-1, norm=false) {\r\n    const chan = 4;\r\n    function getElem(i,j,c) {\r\n        return data[i*w*chan + j*chan + c]\r\n    }\r\n\r\n    function setElem(arr, i,j,c, val) {\r\n        arr[i*w*chan + j*chan + c] = val;\r\n    }\r\n\r\n    function getChanRow(i, c) {\r\n        const res = []\r\n        for (let j = 0; j < w; j++) {\r\n            res[j] = getElem(i,j,c)\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    function logMap(x, max=1) {\r\n        return Math.log(1+x)/Math.log(1+max)\r\n    }\r\n    \r\n    const magnitude = new Float32Array(data);\r\n    const phase = new Float32Array(data);\r\n    const res = [];\r\n\r\n    let maxMagn = [0,0,0];\r\n    for(let c = 0; c < 3; c++)\r\n    {\r\n        const temp = [];\r\n        for (let i = 0; i < h; i++) {\r\n            const line = getChanRow(i,c);\r\n            const f_line = fft(line, dir, norm);\r\n            temp.push(f_line);\r\n        }\r\n\r\n        const getCol = j => {\r\n            const res = [];\r\n            for (let i = 0; i < h; i++) {\r\n                res[i] = temp[i][j]\r\n            }\r\n\r\n            return res;\r\n        }\r\n\r\n        const temp2 = []\r\n        for (let j = 0; j < w; j++) {\r\n            const col = getCol(j);\r\n            const f_col = fft(col, dir, norm);\r\n            temp2.push(f_col);\r\n\r\n            const colMagnMax = Math.max(...col.map(CMagn));\r\n            if (colMagnMax > maxMagn[c]) maxMagn[c] = colMagnMax;\r\n        }\r\n        res.push(temp2)\r\n    }\r\n\r\n    for(let c = 0; c < 3; c++)\r\n        for (let j = 0; j < w; j++)\r\n            for (let i = 0; i < h; i++) {\r\n                const item = res[c][j][i];\r\n                const phaseVal = CPhase(item);\r\n                const magnVal = CMagn(item)\r\n                // correct phase so it can be an image\r\n                const phaseCorrected = (phaseVal + Math.PI) / Math.PI / 2;\r\n                setElem(magnitude, i,j,c, logMap(magnVal, maxMagn[c]))\r\n                setElem(phase, i,j,c, phaseCorrected)\r\n            }\r\n\r\n\r\n    return {magnitude, phase};\r\n}\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZmZ0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQix3QkFBd0IsT0FBTztBQUMvQiw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZmZ0LmpzP2I0NjgiXSwic291cmNlc0NvbnRlbnQiOlsiXHJcbmV4cG9ydCBmdW5jdGlvbiBDQWRkKGEsIGIpIHtcclxuICAgIHJldHVybiBbYVswXSArIGJbMF0sIGFbMV0gKyBiWzFdXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENTdWIoYSwgYikge1xyXG4gICAgcmV0dXJuIFthWzBdIC0gYlswXSwgYVsxXSAtIGJbMV1dO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ011bChhLCBiKSB7XHJcbiAgICByZXR1cm4gWyhhWzBdICogYlswXSAtIGFbMV0gKiBiWzFdKSxcclxuICAgIChhWzBdICogYlsxXSArIGFbMV0gKiBiWzBdKV07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDTWFnbihjKSB7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGNbMF0gKiBjWzBdICsgY1sxXSAqIGNbMV0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ1BoYXNlKGMpIHtcclxuICAgIHJldHVybiBNYXRoLmF0YW4yKGNbMV0sIGNbMF0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ0V4cChjKSB7XHJcbiAgICBjb25zdCBjb2VmID0gTWF0aC5leHAoY1swXSk7XHJcbiAgICByZXR1cm4gW2NvZWYgKiBNYXRoLmNvcyhjWzFdKSwgY29lZiAqIE1hdGguc2luKGNbMV0pXVxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZnQoYXJyLCBkaXI9LTEpIHtcclxuICAgIGNvbnN0IGxlbmd0aCA9IGFyci5sZW5ndGg7XHJcbiAgICBjb25zdCByZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcmVzW2ldID0gWzAsIDBdO1xyXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcG93ID0gZGlyICogTWF0aC5QSSAqIDIgLyBsZW5ndGggKiBrICogaTtcclxuICAgICAgICAgICAgY29uc3QgdGVybSA9IGFycltrXT8ubGVuZ3RoID8gYXJyW2tdIDogW2FycltrXSwgMF07XHJcblxyXG4gICAgICAgICAgICBjb25zdCB0ZW1wID0gQ011bCh0ZXJtLCBDRXhwKFswLCBwb3ddKSlcclxuICAgICAgICAgICAgcmVzW2ldID0gQ0FkZChyZXNbaV0sIHRlbXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmZ0KGFyciwgZGlyPS0xLCBub3JtPWZhbHNlKSB7XHJcbiAgICBmdW5jdGlvbiBldmVuKF9fLCBpeCkge1xyXG4gICAgICAgIHJldHVybiBpeCAlIDIgPT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvZGQoX18sIGl4KSB7XHJcbiAgICAgICAgcmV0dXJuIGl4ICUgMiA9PSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGxlbmd0aCA9IGFyci5sZW5ndGg7XHJcbiAgICBjb25zdCBtdWx0ID0gbm9ybSA/IFsxL2xlbmd0aCwgMF0gOiBbMSwwXTtcclxuICAgIGNvbnN0IHJlcyA9IFtdO1xyXG5cclxuICAgIGlmIChsZW5ndGggPT0gMSkge1xyXG4gICAgICAgIHJldHVybiBhcnJbMF0/Lmxlbmd0aCA/IFthcnJbMF1dIDogW1thcnJbMF0sIDBdXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZWN1cnNpb25cclxuICAgIGNvbnN0IHJlc19ldmVucyA9IGZmdChhcnIuZmlsdGVyKGV2ZW4pKTtcclxuICAgIGNvbnN0IHJlc19vZGRzID0gZmZ0KGFyci5maWx0ZXIob2RkKSk7XHJcblxyXG4gICAgLy8gTm93LCBwZXJmb3JtIE4vMiBvcGVyYXRpb25zIVxyXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBsZW5ndGggLyAyOyBrKyspIHtcclxuICAgICAgICBjb25zdCBwb3cgPSBkaXIgKiBNYXRoLlBJICogMiAvIGxlbmd0aCAqIGs7XHJcblxyXG4gICAgICAgIC8vIHQgaXMgYSBjb21wbGV4IG51bWJlciFcclxuICAgICAgICBjb25zdCB0ID0gcmVzX2V2ZW5zW2tdO1xyXG4gICAgICAgIGNvbnN0IGUgPSBDTXVsKENFeHAoWzAscG93XSksIHJlc19vZGRzW2tdKTtcclxuXHJcbiAgICAgICAgcmVzW2tdID0gQ011bChDQWRkKHQsIGUpLCBtdWx0KTtcclxuICAgICAgICByZXNbayArIChsZW5ndGggLyAyKV0gPSBDTXVsKENTdWIodCwgZSksIG11bHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmZnRQaXhlbERhdGEoZGF0YSx3LGgsIGRpcj0tMSwgbm9ybT1mYWxzZSkge1xyXG4gICAgY29uc3QgY2hhbiA9IDQ7XHJcbiAgICBmdW5jdGlvbiBnZXRFbGVtKGksaixjKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGFbaSp3KmNoYW4gKyBqKmNoYW4gKyBjXVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldEVsZW0oYXJyLCBpLGosYywgdmFsKSB7XHJcbiAgICAgICAgYXJyW2kqdypjaGFuICsgaipjaGFuICsgY10gPSB2YWw7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q2hhblJvdyhpLCBjKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gW11cclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHc7IGorKykge1xyXG4gICAgICAgICAgICByZXNbal0gPSBnZXRFbGVtKGksaixjKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2dNYXAoeCwgbWF4PTEpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5sb2coMSt4KS9NYXRoLmxvZygxK21heClcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgbWFnbml0dWRlID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcclxuICAgIGNvbnN0IHBoYXNlID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcclxuICAgIGNvbnN0IHJlcyA9IFtdO1xyXG5cclxuICAgIGxldCBtYXhNYWduID0gWzAsMCwwXTtcclxuICAgIGZvcihsZXQgYyA9IDA7IGMgPCAzOyBjKyspXHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgdGVtcCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBnZXRDaGFuUm93KGksYyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZfbGluZSA9IGZmdChsaW5lLCBkaXIsIG5vcm0pO1xyXG4gICAgICAgICAgICB0ZW1wLnB1c2goZl9saW5lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGdldENvbCA9IGogPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJlc1tpXSA9IHRlbXBbaV1bal1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRlbXAyID0gW11cclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHc7IGorKykge1xyXG4gICAgICAgICAgICBjb25zdCBjb2wgPSBnZXRDb2woaik7XHJcbiAgICAgICAgICAgIGNvbnN0IGZfY29sID0gZmZ0KGNvbCwgZGlyLCBub3JtKTtcclxuICAgICAgICAgICAgdGVtcDIucHVzaChmX2NvbCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjb2xNYWduTWF4ID0gTWF0aC5tYXgoLi4uY29sLm1hcChDTWFnbikpO1xyXG4gICAgICAgICAgICBpZiAoY29sTWFnbk1heCA+IG1heE1hZ25bY10pIG1heE1hZ25bY10gPSBjb2xNYWduTWF4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXMucHVzaCh0ZW1wMilcclxuICAgIH1cclxuXHJcbiAgICBmb3IobGV0IGMgPSAwOyBjIDwgMzsgYysrKVxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdzsgaisrKVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHJlc1tjXVtqXVtpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBoYXNlVmFsID0gQ1BoYXNlKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWFnblZhbCA9IENNYWduKGl0ZW0pXHJcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IHBoYXNlIHNvIGl0IGNhbiBiZSBhbiBpbWFnZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGhhc2VDb3JyZWN0ZWQgPSAocGhhc2VWYWwgKyBNYXRoLlBJKSAvIE1hdGguUEkgLyAyO1xyXG4gICAgICAgICAgICAgICAgc2V0RWxlbShtYWduaXR1ZGUsIGksaixjLCBsb2dNYXAobWFnblZhbCwgbWF4TWFnbltjXSkpXHJcbiAgICAgICAgICAgICAgICBzZXRFbGVtKHBoYXNlLCBpLGosYywgcGhhc2VDb3JyZWN0ZWQpXHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgcmV0dXJuIHttYWduaXR1ZGUsIHBoYXNlfTtcclxufVxyXG5cclxuXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/fft.js\n");

/***/ }),

/***/ "./src/igloo.js":
/*!**********************!*\
  !*** ./src/igloo.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Igloo\": () => (/* binding */ Igloo)\n/* harmony export */ });\n/**\r\n * Wrap WebGLRenderingContext objects with useful behavior.\r\n * @param {WebGLRenderingContext|HTMLCanvasElement} gl\r\n * @param {Object} [options] to pass to getContext()\r\n * @returns {Igloo}\r\n * @namespace\r\n */\r\nfunction Igloo(gl, options) {\r\n    var canvas;\r\n    if (gl instanceof HTMLCanvasElement) {\r\n        canvas = gl;\r\n        gl = Igloo.getContext(gl, options);\r\n    } else {\r\n        canvas = gl.canvas;\r\n    }\r\n    this.gl = gl;\r\n    this.canvas = canvas;\r\n    this.defaultFramebuffer = new Igloo.Framebuffer(gl, null);\r\n}\r\n\r\n/**\r\n * To be used in a vec2 GL_TRIANGLE_STRIP draw.\r\n * @type {Float32Array}\r\n * @constant\r\n */\r\nIgloo.QUAD2 = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);\r\n\r\n/**\r\n * Asynchronously or synchronously fetch data from the server.\r\n * @param {string} url\r\n * @param {Function} [callback] if provided, call is asynchronous\r\n * @returns {string}\r\n */\r\nIgloo.fetch = function(url, callback) {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open('GET', url, Boolean(callback));\r\n    if (callback != null) {\r\n        xhr.onload = function() {\r\n            callback(xhr.responseText);\r\n        };\r\n    }\r\n    xhr.send();\r\n    return xhr.responseText;\r\n};\r\n\r\n/**\r\n * @param {HTMLCanvasElement} canvas\r\n * @param {Object} [options] to pass to getContext()\r\n * @param {boolean} [noerror] If true, return null instead of throwing\r\n * @returns {?WebGLRenderingContext} a WebGL rendering context.\r\n */\r\nIgloo.getContext = function(canvas, options, noerror) {\r\n    var gl;\r\n    try {\r\n        gl = canvas.getContext('webgl', options || {}) ||\r\n            canvas.getContext('experimental-webgl', options || {});\r\n    } catch (e) {\r\n        gl = null;\r\n    }\r\n    if (gl == null && !noerror) {\r\n        throw new Error('Could not create WebGL context.');\r\n    } else {\r\n        return gl;\r\n    }\r\n};\r\n\r\n/**\r\n * @param {string} string\r\n * @returns {boolean} True if the string looks like a URL\r\n */\r\nIgloo.looksLikeURL = function(string) {\r\n    return /\\s/.exec(string) == null;\r\n};\r\n\r\n/**\r\n * @param {*} object\r\n * @returns {boolean} true if object is an array or typed array\r\n */\r\nIgloo.isArray = function(object) {\r\n    var name = Object.prototype.toString.apply(object, []),\r\n        re = / (Float(32|64)|Int(16|32|8)|Uint(16|32|8(Clamped)?))?Array]$/;\r\n    return re.exec(name) != null;\r\n};\r\n\r\n/**\r\n * Creates a program from a program configuration.\r\n *\r\n * @param {string} vertex URL or source of the vertex shader\r\n * @param {string} fragment URL or source of the fragment shader\r\n * @param {Function} [transform] Transforms the shaders before compilation\r\n * @returns {Igloo.Program}\r\n */\r\nIgloo.prototype.program = function(vertex, fragment, transform) {\r\n    if (Igloo.looksLikeURL(vertex)) vertex = Igloo.fetch(vertex);\r\n    if (Igloo.looksLikeURL(fragment)) fragment = Igloo.fetch(fragment);\r\n    if (transform != null) {\r\n        vertex = transform(vertex);\r\n        fragment = transform(fragment);\r\n    }\r\n    return new Igloo.Program(this.gl, vertex, fragment);\r\n};\r\n\r\n/**\r\n * Create a new GL_ARRAY_BUFFER with optional data.\r\n * @param {ArrayBuffer|ArrayBufferView} [data]\r\n * @param {GLenum} [usage]\r\n * @returns {Igloo.Buffer}\r\n */\r\nIgloo.prototype.array = function(data, usage) {\r\n    var gl = this.gl,\r\n        buffer = new Igloo.Buffer(gl, gl.ARRAY_BUFFER);\r\n    if (data != null) {\r\n        buffer.update(data, usage == null ? gl.STATIC_DRAW : usage);\r\n    }\r\n    return buffer;\r\n};\r\n\r\n/**\r\n * Create a new GL_ELEMENT_ARRAY_BUFFER with optional data.\r\n * @param {ArrayBuffer|ArrayBufferView} [data]\r\n * @param {GLenum} [usage]\r\n * @returns {Igloo.Buffer}\r\n */\r\nIgloo.prototype.elements = function(data, usage) {\r\n    var gl = this.gl,\r\n        buffer = new Igloo.Buffer(gl, gl.ELEMENT_ARRAY_BUFFER);\r\n    if (data != null) {\r\n        buffer.update(data, usage == null ? gl.STATIC_DRAW : usage);\r\n    }\r\n    return buffer;\r\n};\r\n\r\n/**\r\n * @param {TexImageSource} [source]\r\n * @param {GLenum} [format=GL_RGBA]\r\n * @param {GLenum} [wrap=GL_CLAMP_TO_EDGE]\r\n * @param {GLenum} [filter=GL_LINEAR]\r\n * @param {GLenum} [type=UNSIGNED_BYTE]\r\n * @param {Object} [options = {type: 'ArrayBufferView', width, height} || {}]\r\n * @returns {Igloo.Texture}\r\n */\r\nIgloo.prototype.texture = function(source, format, wrap, filter, type, options) {\r\n    var texture = new Igloo.Texture(this.gl, format, wrap, filter, type);\r\n    if (source != null) {\r\n        if (options && options.type === 'ArrayBufferView') {\r\n          texture.set(source, options.width, options.height);\r\n        }\r\n        else {\r\n          texture.set(source);\r\n        }\r\n    }\r\n    return texture;\r\n};\r\n\r\n/**\r\n * @param {Igloo.Texture} [texture]\r\n * @returns {Igloo.Framebuffer}\r\n */\r\nIgloo.prototype.framebuffer = function(texture) {\r\n    var framebuffer = new Igloo.Framebuffer(this.gl);\r\n    if (texture != null) framebuffer.attach(texture);\r\n    return framebuffer;\r\n};\r\n\r\n/**\r\n * Fluent WebGLProgram wrapper for managing variables and data. The\r\n * constructor compiles and links a program from a pair of shaders.\r\n * Throws an exception if compiling or linking fails.\r\n * @param {WebGLRenderingContext} gl\r\n * @param {string} vertex Shader source\r\n * @param {string} fragment Shader source\r\n * @constructor\r\n */\r\nIgloo.Program = function(gl, vertex, fragment) {\r\n    this.gl = gl;\r\n    var p = this.program = gl.createProgram();\r\n    gl.attachShader(p, this.makeShader(gl.VERTEX_SHADER, vertex));\r\n    gl.attachShader(p, this.makeShader(gl.FRAGMENT_SHADER, fragment));\r\n    gl.linkProgram(p);\r\n    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {\r\n        throw new Error(gl.getProgramInfoLog(p));\r\n    }\r\n    this.vars = {};\r\n};\r\n\r\n/**\r\n * Compile a shader from source.\r\n * @param {number} type\r\n * @param {string} source\r\n * @returns {WebGLShader}\r\n */\r\nIgloo.Program.prototype.makeShader = function(type, source) {\r\n    var gl = this.gl;\r\n    var shader = gl.createShader(type);\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n        return shader;\r\n    } else {\r\n        throw new Error(gl.getShaderInfoLog(shader));\r\n    }\r\n};\r\n\r\n/**\r\n * Tell WebGL to use this program right now.\r\n * @returns {Igloo.Program} this\r\n */\r\nIgloo.Program.prototype.use = function() {\r\n    this.gl.useProgram(this.program);\r\n    return this;\r\n};\r\n\r\n/**\r\n * Declare/set a uniform or set a uniform's data.\r\n * @param {string} name uniform variable name\r\n * @param {number|Array|ArrayBufferView} [value]\r\n * @param {boolean} [i] if true use the integer version\r\n * @returns {Igloo.Program} this\r\n */\r\nIgloo.Program.prototype.uniform = function(name, value, i, dim) {\r\n    if (value == null) {\r\n        this.vars[name] = this.gl.getUniformLocation(this.program, name);\r\n    } else {\r\n        if (this.vars[name] == null) this.uniform(name);\r\n        var v = this.vars[name];\r\n        if (Igloo.isArray(value)) {\r\n            var l = dim ? dim : value.length;\r\n            var method = 'uniform' + l + (i ? 'i' : 'f') + 'v';\r\n            this.gl[method](v, value);\r\n        } else if (typeof value === 'number' || typeof value === 'boolean') {\r\n            if (i) {\r\n                this.gl.uniform1i(v, value);\r\n            } else {\r\n                this.gl.uniform1f(v, value);\r\n            }\r\n        } else {\r\n            throw new Error('Invalid uniform value: ' + value);\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Set a uniform's data to a specific matrix.\r\n * @param {string} name uniform variable name\r\n * @param {Array|ArrayBufferView} matrix\r\n * @param {boolean} [transpose=false]\r\n * @returns {Igloo.Program} this\r\n */\r\nIgloo.Program.prototype.matrix = function(name, matrix, transpose) {\r\n    if (this.vars[name] == null) this.uniform(name);\r\n    var method = 'uniformMatrix' + Math.sqrt(matrix.length) + 'fv';\r\n    this.gl[method](this.vars[name], Boolean(transpose), matrix);\r\n    return this;\r\n};\r\n\r\n/**\r\n * Like the uniform() method, but using integers.\r\n * @returns {Igloo.Program} this\r\n */\r\nIgloo.Program.prototype.uniformi = function(name, value) {\r\n    return this.uniform(name, value, true);\r\n};\r\n\r\n/**\r\n * Declare an attrib or set an attrib's buffer.\r\n * @param {string} name attrib variable name\r\n * @param {WebGLBuffer} [value]\r\n * @param {number} [size] element size (required if value is provided)\r\n * @param {number} [stride=0]\r\n * @returns {Igloo.Program} this\r\n */\r\nIgloo.Program.prototype.attrib = function(name, value, size, stride) {\r\n    var gl = this.gl;\r\n    if (value == null) {\r\n        this.vars[name] = gl.getAttribLocation(this.program, name);\r\n    } else {\r\n        if (this.vars[name] == null) this.attrib(name); // get location\r\n        value.bind();\r\n        gl.enableVertexAttribArray(this.vars[name]);\r\n        gl.vertexAttribPointer(this.vars[name], size, gl.FLOAT,\r\n                               false, stride == null ? 0 : stride, 0);\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Call glDrawArrays or glDrawElements with this program.\r\n * @param {number} mode\r\n * @param {number} count the number of vertex attribs to render\r\n * @param {GLenum} [type] use glDrawElements of this type\r\n * @returns {Igloo.Program} this\r\n */\r\nIgloo.Program.prototype.draw = function(mode, count, type) {\r\n    var gl = this.gl;\r\n    if (type == null) {\r\n        gl.drawArrays(mode, 0, count);\r\n    } else {\r\n        gl.drawElements(mode, count, type, 0);\r\n    }\r\n    if (gl.getError() !== gl.NO_ERROR) {\r\n        throw new Error('WebGL rendering error');\r\n    }\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Disables all attribs from this program.\r\n * @returns {Igloo.Program} this\r\n */\r\nIgloo.Program.prototype.disable = function() {\r\n    for (var attrib in this.vars) {\r\n        var location = this.vars[attrib];\r\n        if (this.vars.hasOwnProperty(attrib)) {\r\n            if (typeof location === 'number') {\r\n                this.gl.disableVertexAttribArray(location);\r\n            }\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Fluent WebGLBuffer wrapper.\r\n * @param {WebGLRenderingContext} gl\r\n * @param {GLenum} [target] either GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER\r\n * @returns {WebGLProgram}\r\n * @constructor\r\n */\r\nIgloo.Buffer = function(gl, target) {\r\n    this.gl = gl;\r\n    this.buffer = gl.createBuffer();\r\n    this.target = (target == null ? gl.ARRAY_BUFFER : target);\r\n    this.size = -1;\r\n};\r\n\r\n/**\r\n * Binds this buffer to ARRAY_BUFFER.\r\n * @returns {Igloo.Buffer} this\r\n */\r\nIgloo.Buffer.prototype.bind = function() {\r\n    this.gl.bindBuffer(this.target, this.buffer);\r\n    return this;\r\n};\r\n\r\n/**\r\n * @param\r\n * @param {ArrayBuffer|ArrayBufferView} data\r\n * @param {GLenum} [usage]\r\n * @returns {Igloo.Buffer} this\r\n */\r\nIgloo.Buffer.prototype.update = function(data, usage) {\r\n    var gl = this.gl;\r\n    if (data instanceof Array) {\r\n        data = new Float32Array(data);\r\n    }\r\n    usage = usage == null ? gl.DYNAMIC_DRAW : usage;\r\n    this.bind();\r\n    if (this.size !== data.byteLength) {\r\n        gl.bufferData(this.target, data, usage);\r\n        this.size = data.byteLength;\r\n    } else {\r\n        gl.bufferSubData(this.target, 0, data);\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Create a new texture, optionally filled blank.\r\n * @param {WebGLRenderingContext} gl\r\n * @param {GLenum} [format=GL_RGBA]\r\n * @param {GLenum} [wrap=GL_CLAMP_TO_EDGE]\r\n * @param {GLenum} [filter=GL_LINEAR]\r\n * @param {GLenum} [type=UNSIGNED_BYTE]\r\n * @returns {Igloo.Texture}\r\n */\r\nIgloo.Texture = function(gl, format, wrap, filter, type) {\r\n    this.gl = gl;\r\n    var texture = this.texture = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    wrap = wrap == null ? gl.CLAMP_TO_EDGE : wrap;\r\n    filter = filter == null ? gl.LINEAR : filter;\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\r\n    this.format = format == null ? gl.RGBA : format;\r\n    this.type = type == null ? gl.UNSIGNED_BYTE : type;\r\n};\r\n\r\n/**\r\n * @param {number} [unit] active texture unit to bind\r\n * @returns {Igloo.Texture}\r\n */\r\nIgloo.Texture.prototype.bind = function(unit) {\r\n    var gl = this.gl;\r\n    if (unit != null) {\r\n        gl.activeTexture(gl.TEXTURE0 + unit);\r\n    }\r\n    gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n    return this;\r\n};\r\n\r\n/**\r\n * Set texture to particular size, filled with vec4(0, 0, 0, 1).\r\n * @param {number} width\r\n * @param {number} height\r\n * @returns {Igloo.Texture}\r\n */\r\nIgloo.Texture.prototype.blank = function(width, height) {\r\n    var gl = this.gl;\r\n    this.bind();\r\n    gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height,\r\n                  0, this.format, this.type, null);\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Set the texture to a particular image.\r\n * @param {Array|ArrayBufferView|TexImageSource} source\r\n * @param {number} [width]\r\n * @param {number} [height]\r\n * @returns {Igloo.Texture}\r\n */\r\nIgloo.Texture.prototype.set = function(source, width, height) {\r\n    var gl = this.gl;\r\n    this.bind();\r\n    if (source instanceof Array) {\r\n        if (this.type == gl.FLOAT) {\r\n            source = new Float32Array(source);\r\n        } else {\r\n            source = new Uint8Array(source);\r\n        }\r\n    }\r\n    if (width != null || height != null) {\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, this.format,\r\n                      width, height, 0, this.format,\r\n                      this.type, source);\r\n    } else {\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, this.format,\r\n                      this.format, this.type, source);\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Set part of the texture to a particular image.\r\n * @param {Array|ArrayBufferView|TexImageSource} source\r\n * @param {number} xoff\r\n * @param {number} yoff\r\n * @param {number} [width]\r\n * @param {number} [height]\r\n * @returns {Igloo.Texture}\r\n */\r\nIgloo.Texture.prototype.subset = function(source, xoff, yoff, width, height) {\r\n    var gl = this.gl;\r\n    this.bind();\r\n    if (source instanceof Array) {\r\n        if (this.type == gl.FLOAT) {\r\n            source = new Float32Array(source);\r\n        } else {\r\n            source = new Uint8Array(source);\r\n        }\r\n    }\r\n    if (width != null || height != null) {\r\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, xoff, yoff,\r\n                         width, height,\r\n                         this.format, this.type, source);\r\n    } else {\r\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, xoff, yoff,\r\n                         this.format, this.type, source);\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Copy part/all of the current framebuffer to this image.\r\n * @param {Array|ArrayBufferView|TexImageSource} source\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {number} width\r\n * @param {number} height\r\n * @returns {Igloo.Texture}\r\n */\r\nIgloo.Texture.prototype.copy = function(x, y, width, height) {\r\n    var gl = this.gl;\r\n    gl.copyTexImage2D(gl.TEXTURE_2D, 0, this.format, x, y, width, height, 0);\r\n    return this;\r\n};\r\n\r\n/**\r\n * @param {WebGLRenderingContext} gl\r\n * @param {WebGLFramebuffer} [framebuffer] to be wrapped (null for default)\r\n * @returns {Igloo.Framebuffer}\r\n */\r\nIgloo.Framebuffer = function(gl, framebuffer) {\r\n    this.gl = gl;\r\n    this.framebuffer =\r\n        arguments.length == 2 ? framebuffer : gl.createFramebuffer();\r\n    this.renderbuffer = null;\r\n};\r\n\r\n/**\r\n * @returns {Igloo.Framebuffer}\r\n */\r\nIgloo.Framebuffer.prototype.bind = function() {\r\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);\r\n    return this;\r\n};\r\n\r\n/**\r\n * @returns {Igloo.Framebuffer}\r\n */\r\nIgloo.Framebuffer.prototype.unbind = function() {\r\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\r\n    return this;\r\n};\r\n\r\n/**\r\n * @param {Igloo.Texture} texture\r\n * @returns {Igloo.Framebuffer}\r\n */\r\nIgloo.Framebuffer.prototype.attach = function(texture) {\r\n    var gl = this.gl;\r\n    this.bind();\r\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,\r\n                            gl.TEXTURE_2D, texture.texture, 0);\r\n    return this;\r\n};\r\n\r\n/**\r\n * @param {Igloo.Texture} array of textures\r\n * @returns {Igloo.Framebuffer}\r\n */\r\nIgloo.Framebuffer.prototype.attachArr = function(textures) {\r\n    var gl = this.gl;\r\n    var ext = gl.getExtension('WEBGL_draw_buffers');\r\n    var attachIdx = 0;\r\n    var arr = [];\r\n\r\n    this.bind();\r\n    textures.forEach(function(texture) {\r\n      var attachIdxStr = 'COLOR_ATTACHMENT' + attachIdx +'_WEBGL';\r\n      attachIdx += 1;\r\n      arr.push(ext[attachIdxStr]);\r\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, ext[attachIdxStr],\r\n                              gl.TEXTURE_2D, texture.texture, 0);\r\n    });\r\n\r\n    console.log('attachArr');\r\n    console.log(arr);\r\n    ext.drawBuffersWEBGL(arr);\r\n\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Attach a renderbuffer as a depth buffer for depth-tested rendering.\r\n * @param {number} width\r\n * @param {number} height\r\n * @returns {Igloo.Framebuffer}\r\n */\r\nIgloo.Framebuffer.prototype.attachDepth = function(width, height) {\r\n    var gl = this.gl;\r\n    this.bind();\r\n    if (this.renderbuffer == null) {\r\n        this.renderbuffer = gl.createRenderbuffer();\r\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16,\r\n                               width, height);\r\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,\r\n                                   gl.RENDERBUFFER, this.renderbuffer);\r\n    }\r\n    return this;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxrQkFBa0I7QUFDN0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2lnbG9vLmpzPzhmY2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFdyYXAgV2ViR0xSZW5kZXJpbmdDb250ZXh0IG9iamVjdHMgd2l0aCB1c2VmdWwgYmVoYXZpb3IuXHJcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fEhUTUxDYW52YXNFbGVtZW50fSBnbFxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHRvIHBhc3MgdG8gZ2V0Q29udGV4dCgpXHJcbiAqIEByZXR1cm5zIHtJZ2xvb31cclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIElnbG9vKGdsLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgY2FudmFzO1xyXG4gICAgaWYgKGdsIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgICBjYW52YXMgPSBnbDtcclxuICAgICAgICBnbCA9IElnbG9vLmdldENvbnRleHQoZ2wsIG9wdGlvbnMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjYW52YXMgPSBnbC5jYW52YXM7XHJcbiAgICB9XHJcbiAgICB0aGlzLmdsID0gZ2w7XHJcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcclxuICAgIHRoaXMuZGVmYXVsdEZyYW1lYnVmZmVyID0gbmV3IElnbG9vLkZyYW1lYnVmZmVyKGdsLCBudWxsKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRvIGJlIHVzZWQgaW4gYSB2ZWMyIEdMX1RSSUFOR0xFX1NUUklQIGRyYXcuXHJcbiAqIEB0eXBlIHtGbG9hdDMyQXJyYXl9XHJcbiAqIEBjb25zdGFudFxyXG4gKi9cclxuSWdsb28uUVVBRDIgPSBuZXcgRmxvYXQzMkFycmF5KFstMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSwgMV0pO1xyXG5cclxuLyoqXHJcbiAqIEFzeW5jaHJvbm91c2x5IG9yIHN5bmNocm9ub3VzbHkgZmV0Y2ggZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBpZiBwcm92aWRlZCwgY2FsbCBpcyBhc3luY2hyb25vdXNcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbklnbG9vLmZldGNoID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgQm9vbGVhbihjYWxsYmFjaykpO1xyXG4gICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcclxuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHhoci5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB4aHIuc2VuZCgpO1xyXG4gICAgcmV0dXJuIHhoci5yZXNwb25zZVRleHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdG8gcGFzcyB0byBnZXRDb250ZXh0KClcclxuICogQHBhcmFtIHtib29sZWFufSBbbm9lcnJvcl0gSWYgdHJ1ZSwgcmV0dXJuIG51bGwgaW5zdGVhZCBvZiB0aHJvd2luZ1xyXG4gKiBAcmV0dXJucyB7P1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gYSBXZWJHTCByZW5kZXJpbmcgY29udGV4dC5cclxuICovXHJcbklnbG9vLmdldENvbnRleHQgPSBmdW5jdGlvbihjYW52YXMsIG9wdGlvbnMsIG5vZXJyb3IpIHtcclxuICAgIHZhciBnbDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBvcHRpb25zIHx8IHt9KSB8fFxyXG4gICAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgb3B0aW9ucyB8fCB7fSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgZ2wgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKGdsID09IG51bGwgJiYgIW5vZXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjcmVhdGUgV2ViR0wgY29udGV4dC4nKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGdsO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcclxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmluZyBsb29rcyBsaWtlIGEgVVJMXHJcbiAqL1xyXG5JZ2xvby5sb29rc0xpa2VVUkwgPSBmdW5jdGlvbihzdHJpbmcpIHtcclxuICAgIHJldHVybiAvXFxzLy5leGVjKHN0cmluZykgPT0gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0geyp9IG9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgYW4gYXJyYXkgb3IgdHlwZWQgYXJyYXlcclxuICovXHJcbklnbG9vLmlzQXJyYXkgPSBmdW5jdGlvbihvYmplY3QpIHtcclxuICAgIHZhciBuYW1lID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShvYmplY3QsIFtdKSxcclxuICAgICAgICByZSA9IC8gKEZsb2F0KDMyfDY0KXxJbnQoMTZ8MzJ8OCl8VWludCgxNnwzMnw4KENsYW1wZWQpPykpP0FycmF5XSQvO1xyXG4gICAgcmV0dXJuIHJlLmV4ZWMobmFtZSkgIT0gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgcHJvZ3JhbSBmcm9tIGEgcHJvZ3JhbSBjb25maWd1cmF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVydGV4IFVSTCBvciBzb3VyY2Ugb2YgdGhlIHZlcnRleCBzaGFkZXJcclxuICogQHBhcmFtIHtzdHJpbmd9IGZyYWdtZW50IFVSTCBvciBzb3VyY2Ugb2YgdGhlIGZyYWdtZW50IHNoYWRlclxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdHJhbnNmb3JtXSBUcmFuc2Zvcm1zIHRoZSBzaGFkZXJzIGJlZm9yZSBjb21waWxhdGlvblxyXG4gKiBAcmV0dXJucyB7SWdsb28uUHJvZ3JhbX1cclxuICovXHJcbklnbG9vLnByb3RvdHlwZS5wcm9ncmFtID0gZnVuY3Rpb24odmVydGV4LCBmcmFnbWVudCwgdHJhbnNmb3JtKSB7XHJcbiAgICBpZiAoSWdsb28ubG9va3NMaWtlVVJMKHZlcnRleCkpIHZlcnRleCA9IElnbG9vLmZldGNoKHZlcnRleCk7XHJcbiAgICBpZiAoSWdsb28ubG9va3NMaWtlVVJMKGZyYWdtZW50KSkgZnJhZ21lbnQgPSBJZ2xvby5mZXRjaChmcmFnbWVudCk7XHJcbiAgICBpZiAodHJhbnNmb3JtICE9IG51bGwpIHtcclxuICAgICAgICB2ZXJ0ZXggPSB0cmFuc2Zvcm0odmVydGV4KTtcclxuICAgICAgICBmcmFnbWVudCA9IHRyYW5zZm9ybShmcmFnbWVudCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IElnbG9vLlByb2dyYW0odGhpcy5nbCwgdmVydGV4LCBmcmFnbWVudCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgbmV3IEdMX0FSUkFZX0JVRkZFUiB3aXRoIG9wdGlvbmFsIGRhdGEuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBbZGF0YV1cclxuICogQHBhcmFtIHtHTGVudW19IFt1c2FnZV1cclxuICogQHJldHVybnMge0lnbG9vLkJ1ZmZlcn1cclxuICovXHJcbklnbG9vLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uKGRhdGEsIHVzYWdlKSB7XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsLFxyXG4gICAgICAgIGJ1ZmZlciA9IG5ldyBJZ2xvby5CdWZmZXIoZ2wsIGdsLkFSUkFZX0JVRkZFUik7XHJcbiAgICBpZiAoZGF0YSAhPSBudWxsKSB7XHJcbiAgICAgICAgYnVmZmVyLnVwZGF0ZShkYXRhLCB1c2FnZSA9PSBudWxsID8gZ2wuU1RBVElDX0RSQVcgOiB1c2FnZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnVmZmVyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBHTF9FTEVNRU5UX0FSUkFZX0JVRkZFUiB3aXRoIG9wdGlvbmFsIGRhdGEuXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fSBbZGF0YV1cclxuICogQHBhcmFtIHtHTGVudW19IFt1c2FnZV1cclxuICogQHJldHVybnMge0lnbG9vLkJ1ZmZlcn1cclxuICovXHJcbklnbG9vLnByb3RvdHlwZS5lbGVtZW50cyA9IGZ1bmN0aW9uKGRhdGEsIHVzYWdlKSB7XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsLFxyXG4gICAgICAgIGJ1ZmZlciA9IG5ldyBJZ2xvby5CdWZmZXIoZ2wsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSKTtcclxuICAgIGlmIChkYXRhICE9IG51bGwpIHtcclxuICAgICAgICBidWZmZXIudXBkYXRlKGRhdGEsIHVzYWdlID09IG51bGwgPyBnbC5TVEFUSUNfRFJBVyA6IHVzYWdlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBidWZmZXI7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtUZXhJbWFnZVNvdXJjZX0gW3NvdXJjZV1cclxuICogQHBhcmFtIHtHTGVudW19IFtmb3JtYXQ9R0xfUkdCQV1cclxuICogQHBhcmFtIHtHTGVudW19IFt3cmFwPUdMX0NMQU1QX1RPX0VER0VdXHJcbiAqIEBwYXJhbSB7R0xlbnVtfSBbZmlsdGVyPUdMX0xJTkVBUl1cclxuICogQHBhcmFtIHtHTGVudW19IFt0eXBlPVVOU0lHTkVEX0JZVEVdXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucyA9IHt0eXBlOiAnQXJyYXlCdWZmZXJWaWV3Jywgd2lkdGgsIGhlaWdodH0gfHwge31dXHJcbiAqIEByZXR1cm5zIHtJZ2xvby5UZXh0dXJlfVxyXG4gKi9cclxuSWdsb28ucHJvdG90eXBlLnRleHR1cmUgPSBmdW5jdGlvbihzb3VyY2UsIGZvcm1hdCwgd3JhcCwgZmlsdGVyLCB0eXBlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgdGV4dHVyZSA9IG5ldyBJZ2xvby5UZXh0dXJlKHRoaXMuZ2wsIGZvcm1hdCwgd3JhcCwgZmlsdGVyLCB0eXBlKTtcclxuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHlwZSA9PT0gJ0FycmF5QnVmZmVyVmlldycpIHtcclxuICAgICAgICAgIHRleHR1cmUuc2V0KHNvdXJjZSwgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHRleHR1cmUuc2V0KHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRleHR1cmU7XHJcbn07XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtJZ2xvby5UZXh0dXJlfSBbdGV4dHVyZV1cclxuICogQHJldHVybnMge0lnbG9vLkZyYW1lYnVmZmVyfVxyXG4gKi9cclxuSWdsb28ucHJvdG90eXBlLmZyYW1lYnVmZmVyID0gZnVuY3Rpb24odGV4dHVyZSkge1xyXG4gICAgdmFyIGZyYW1lYnVmZmVyID0gbmV3IElnbG9vLkZyYW1lYnVmZmVyKHRoaXMuZ2wpO1xyXG4gICAgaWYgKHRleHR1cmUgIT0gbnVsbCkgZnJhbWVidWZmZXIuYXR0YWNoKHRleHR1cmUpO1xyXG4gICAgcmV0dXJuIGZyYW1lYnVmZmVyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZsdWVudCBXZWJHTFByb2dyYW0gd3JhcHBlciBmb3IgbWFuYWdpbmcgdmFyaWFibGVzIGFuZCBkYXRhLiBUaGVcclxuICogY29uc3RydWN0b3IgY29tcGlsZXMgYW5kIGxpbmtzIGEgcHJvZ3JhbSBmcm9tIGEgcGFpciBvZiBzaGFkZXJzLlxyXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGNvbXBpbGluZyBvciBsaW5raW5nIGZhaWxzLlxyXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcclxuICogQHBhcmFtIHtzdHJpbmd9IHZlcnRleCBTaGFkZXIgc291cmNlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBmcmFnbWVudCBTaGFkZXIgc291cmNlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuSWdsb28uUHJvZ3JhbSA9IGZ1bmN0aW9uKGdsLCB2ZXJ0ZXgsIGZyYWdtZW50KSB7XHJcbiAgICB0aGlzLmdsID0gZ2w7XHJcbiAgICB2YXIgcCA9IHRoaXMucHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgIGdsLmF0dGFjaFNoYWRlcihwLCB0aGlzLm1ha2VTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4KSk7XHJcbiAgICBnbC5hdHRhY2hTaGFkZXIocCwgdGhpcy5tYWtlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnQpKTtcclxuICAgIGdsLmxpbmtQcm9ncmFtKHApO1xyXG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHAsIGdsLkxJTktfU1RBVFVTKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnbC5nZXRQcm9ncmFtSW5mb0xvZyhwKSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnZhcnMgPSB7fTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21waWxlIGEgc2hhZGVyIGZyb20gc291cmNlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlXHJcbiAqIEByZXR1cm5zIHtXZWJHTFNoYWRlcn1cclxuICovXHJcbklnbG9vLlByb2dyYW0ucHJvdG90eXBlLm1ha2VTaGFkZXIgPSBmdW5jdGlvbih0eXBlLCBzb3VyY2UpIHtcclxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xyXG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcclxuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuICAgIGlmIChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZWxsIFdlYkdMIHRvIHVzZSB0aGlzIHByb2dyYW0gcmlnaHQgbm93LlxyXG4gKiBAcmV0dXJucyB7SWdsb28uUHJvZ3JhbX0gdGhpc1xyXG4gKi9cclxuSWdsb28uUHJvZ3JhbS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlY2xhcmUvc2V0IGEgdW5pZm9ybSBvciBzZXQgYSB1bmlmb3JtJ3MgZGF0YS5cclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdW5pZm9ybSB2YXJpYWJsZSBuYW1lXHJcbiAqIEBwYXJhbSB7bnVtYmVyfEFycmF5fEFycmF5QnVmZmVyVmlld30gW3ZhbHVlXVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpXSBpZiB0cnVlIHVzZSB0aGUgaW50ZWdlciB2ZXJzaW9uXHJcbiAqIEByZXR1cm5zIHtJZ2xvby5Qcm9ncmFtfSB0aGlzXHJcbiAqL1xyXG5JZ2xvby5Qcm9ncmFtLnByb3RvdHlwZS51bmlmb3JtID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIGksIGRpbSkge1xyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICB0aGlzLnZhcnNbbmFtZV0gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodGhpcy52YXJzW25hbWVdID09IG51bGwpIHRoaXMudW5pZm9ybShuYW1lKTtcclxuICAgICAgICB2YXIgdiA9IHRoaXMudmFyc1tuYW1lXTtcclxuICAgICAgICBpZiAoSWdsb28uaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdmFyIGwgPSBkaW0gPyBkaW0gOiB2YWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSAndW5pZm9ybScgKyBsICsgKGkgPyAnaScgOiAnZicpICsgJ3YnO1xyXG4gICAgICAgICAgICB0aGlzLmdsW21ldGhvZF0odiwgdmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICBpZiAoaSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtMWkodiwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtMWYodiwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVuaWZvcm0gdmFsdWU6ICcgKyB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IGEgdW5pZm9ybSdzIGRhdGEgdG8gYSBzcGVjaWZpYyBtYXRyaXguXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHVuaWZvcm0gdmFyaWFibGUgbmFtZVxyXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyVmlld30gbWF0cml4XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RyYW5zcG9zZT1mYWxzZV1cclxuICogQHJldHVybnMge0lnbG9vLlByb2dyYW19IHRoaXNcclxuICovXHJcbklnbG9vLlByb2dyYW0ucHJvdG90eXBlLm1hdHJpeCA9IGZ1bmN0aW9uKG5hbWUsIG1hdHJpeCwgdHJhbnNwb3NlKSB7XHJcbiAgICBpZiAodGhpcy52YXJzW25hbWVdID09IG51bGwpIHRoaXMudW5pZm9ybShuYW1lKTtcclxuICAgIHZhciBtZXRob2QgPSAndW5pZm9ybU1hdHJpeCcgKyBNYXRoLnNxcnQobWF0cml4Lmxlbmd0aCkgKyAnZnYnO1xyXG4gICAgdGhpcy5nbFttZXRob2RdKHRoaXMudmFyc1tuYW1lXSwgQm9vbGVhbih0cmFuc3Bvc2UpLCBtYXRyaXgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogTGlrZSB0aGUgdW5pZm9ybSgpIG1ldGhvZCwgYnV0IHVzaW5nIGludGVnZXJzLlxyXG4gKiBAcmV0dXJucyB7SWdsb28uUHJvZ3JhbX0gdGhpc1xyXG4gKi9cclxuSWdsb28uUHJvZ3JhbS5wcm90b3R5cGUudW5pZm9ybWkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVjbGFyZSBhbiBhdHRyaWIgb3Igc2V0IGFuIGF0dHJpYidzIGJ1ZmZlci5cclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgYXR0cmliIHZhcmlhYmxlIG5hbWVcclxuICogQHBhcmFtIHtXZWJHTEJ1ZmZlcn0gW3ZhbHVlXVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemVdIGVsZW1lbnQgc2l6ZSAocmVxdWlyZWQgaWYgdmFsdWUgaXMgcHJvdmlkZWQpXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RyaWRlPTBdXHJcbiAqIEByZXR1cm5zIHtJZ2xvby5Qcm9ncmFtfSB0aGlzXHJcbiAqL1xyXG5JZ2xvby5Qcm9ncmFtLnByb3RvdHlwZS5hdHRyaWIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgc2l6ZSwgc3RyaWRlKSB7XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICB0aGlzLnZhcnNbbmFtZV0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodGhpcy52YXJzW25hbWVdID09IG51bGwpIHRoaXMuYXR0cmliKG5hbWUpOyAvLyBnZXQgbG9jYXRpb25cclxuICAgICAgICB2YWx1ZS5iaW5kKCk7XHJcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy52YXJzW25hbWVdKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMudmFyc1tuYW1lXSwgc2l6ZSwgZ2wuRkxPQVQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSwgc3RyaWRlID09IG51bGwgPyAwIDogc3RyaWRlLCAwKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGwgZ2xEcmF3QXJyYXlzIG9yIGdsRHJhd0VsZW1lbnRzIHdpdGggdGhpcyBwcm9ncmFtLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbW9kZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnQgdGhlIG51bWJlciBvZiB2ZXJ0ZXggYXR0cmlicyB0byByZW5kZXJcclxuICogQHBhcmFtIHtHTGVudW19IFt0eXBlXSB1c2UgZ2xEcmF3RWxlbWVudHMgb2YgdGhpcyB0eXBlXHJcbiAqIEByZXR1cm5zIHtJZ2xvby5Qcm9ncmFtfSB0aGlzXHJcbiAqL1xyXG5JZ2xvby5Qcm9ncmFtLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24obW9kZSwgY291bnQsIHR5cGUpIHtcclxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICBpZiAodHlwZSA9PSBudWxsKSB7XHJcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhtb2RlLCAwLCBjb3VudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhtb2RlLCBjb3VudCwgdHlwZSwgMCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZ2wuZ2V0RXJyb3IoKSAhPT0gZ2wuTk9fRVJST1IpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMIHJlbmRlcmluZyBlcnJvcicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIERpc2FibGVzIGFsbCBhdHRyaWJzIGZyb20gdGhpcyBwcm9ncmFtLlxyXG4gKiBAcmV0dXJucyB7SWdsb28uUHJvZ3JhbX0gdGhpc1xyXG4gKi9cclxuSWdsb28uUHJvZ3JhbS5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZm9yICh2YXIgYXR0cmliIGluIHRoaXMudmFycykge1xyXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHRoaXMudmFyc1thdHRyaWJdO1xyXG4gICAgICAgIGlmICh0aGlzLnZhcnMuaGFzT3duUHJvcGVydHkoYXR0cmliKSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRmx1ZW50IFdlYkdMQnVmZmVyIHdyYXBwZXIuXHJcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxyXG4gKiBAcGFyYW0ge0dMZW51bX0gW3RhcmdldF0gZWl0aGVyIEdMX0FSUkFZX0JVRkZFUiBvciBHTF9FTEVNRU5UX0FSUkFZX0JVRkZFUlxyXG4gKiBAcmV0dXJucyB7V2ViR0xQcm9ncmFtfVxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbklnbG9vLkJ1ZmZlciA9IGZ1bmN0aW9uKGdsLCB0YXJnZXQpIHtcclxuICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgIHRoaXMuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICB0aGlzLnRhcmdldCA9ICh0YXJnZXQgPT0gbnVsbCA/IGdsLkFSUkFZX0JVRkZFUiA6IHRhcmdldCk7XHJcbiAgICB0aGlzLnNpemUgPSAtMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBCaW5kcyB0aGlzIGJ1ZmZlciB0byBBUlJBWV9CVUZGRVIuXHJcbiAqIEByZXR1cm5zIHtJZ2xvby5CdWZmZXJ9IHRoaXNcclxuICovXHJcbklnbG9vLkJ1ZmZlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMudGFyZ2V0LCB0aGlzLmJ1ZmZlcik7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW1cclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9IGRhdGFcclxuICogQHBhcmFtIHtHTGVudW19IFt1c2FnZV1cclxuICogQHJldHVybnMge0lnbG9vLkJ1ZmZlcn0gdGhpc1xyXG4gKi9cclxuSWdsb28uQnVmZmVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihkYXRhLCB1c2FnZSkge1xyXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcclxuICAgIH1cclxuICAgIHVzYWdlID0gdXNhZ2UgPT0gbnVsbCA/IGdsLkRZTkFNSUNfRFJBVyA6IHVzYWdlO1xyXG4gICAgdGhpcy5iaW5kKCk7XHJcbiAgICBpZiAodGhpcy5zaXplICE9PSBkYXRhLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKHRoaXMudGFyZ2V0LCBkYXRhLCB1c2FnZSk7XHJcbiAgICAgICAgdGhpcy5zaXplID0gZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKHRoaXMudGFyZ2V0LCAwLCBkYXRhKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyB0ZXh0dXJlLCBvcHRpb25hbGx5IGZpbGxlZCBibGFuay5cclxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXHJcbiAqIEBwYXJhbSB7R0xlbnVtfSBbZm9ybWF0PUdMX1JHQkFdXHJcbiAqIEBwYXJhbSB7R0xlbnVtfSBbd3JhcD1HTF9DTEFNUF9UT19FREdFXVxyXG4gKiBAcGFyYW0ge0dMZW51bX0gW2ZpbHRlcj1HTF9MSU5FQVJdXHJcbiAqIEBwYXJhbSB7R0xlbnVtfSBbdHlwZT1VTlNJR05FRF9CWVRFXVxyXG4gKiBAcmV0dXJucyB7SWdsb28uVGV4dHVyZX1cclxuICovXHJcbklnbG9vLlRleHR1cmUgPSBmdW5jdGlvbihnbCwgZm9ybWF0LCB3cmFwLCBmaWx0ZXIsIHR5cGUpIHtcclxuICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgIHZhciB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcbiAgICB3cmFwID0gd3JhcCA9PSBudWxsID8gZ2wuQ0xBTVBfVE9fRURHRSA6IHdyYXA7XHJcbiAgICBmaWx0ZXIgPSBmaWx0ZXIgPT0gbnVsbCA/IGdsLkxJTkVBUiA6IGZpbHRlcjtcclxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHdyYXApO1xyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgd3JhcCk7XHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyKTtcclxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXIpO1xyXG4gICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQgPT0gbnVsbCA/IGdsLlJHQkEgOiBmb3JtYXQ7XHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlID09IG51bGwgPyBnbC5VTlNJR05FRF9CWVRFIDogdHlwZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3VuaXRdIGFjdGl2ZSB0ZXh0dXJlIHVuaXQgdG8gYmluZFxyXG4gKiBAcmV0dXJucyB7SWdsb28uVGV4dHVyZX1cclxuICovXHJcbklnbG9vLlRleHR1cmUucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbih1bml0KSB7XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgaWYgKHVuaXQgIT0gbnVsbCkge1xyXG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB1bml0KTtcclxuICAgIH1cclxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGV4dHVyZSB0byBwYXJ0aWN1bGFyIHNpemUsIGZpbGxlZCB3aXRoIHZlYzQoMCwgMCwgMCwgMSkuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XHJcbiAqIEByZXR1cm5zIHtJZ2xvby5UZXh0dXJlfVxyXG4gKi9cclxuSWdsb28uVGV4dHVyZS5wcm90b3R5cGUuYmxhbmsgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgdGhpcy5iaW5kKCk7XHJcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAwLCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBudWxsKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHRleHR1cmUgdG8gYSBwYXJ0aWN1bGFyIGltYWdlLlxyXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyVmlld3xUZXhJbWFnZVNvdXJjZX0gc291cmNlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XVxyXG4gKiBAcmV0dXJucyB7SWdsb28uVGV4dHVyZX1cclxuICovXHJcbklnbG9vLlRleHR1cmUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHNvdXJjZSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgIHRoaXMuYmluZCgpO1xyXG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBnbC5GTE9BVCkge1xyXG4gICAgICAgICAgICBzb3VyY2UgPSBuZXcgRmxvYXQzMkFycmF5KHNvdXJjZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAod2lkdGggIT0gbnVsbCB8fCBoZWlnaHQgIT0gbnVsbCkge1xyXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5mb3JtYXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICB3aWR0aCwgaGVpZ2h0LCAwLCB0aGlzLmZvcm1hdCxcclxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSwgc291cmNlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aGlzLmZvcm1hdCxcclxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIHNvdXJjZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgcGFydCBvZiB0aGUgdGV4dHVyZSB0byBhIHBhcnRpY3VsYXIgaW1hZ2UuXHJcbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJWaWV3fFRleEltYWdlU291cmNlfSBzb3VyY2VcclxuICogQHBhcmFtIHtudW1iZXJ9IHhvZmZcclxuICogQHBhcmFtIHtudW1iZXJ9IHlvZmZcclxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF1cclxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdXHJcbiAqIEByZXR1cm5zIHtJZ2xvby5UZXh0dXJlfVxyXG4gKi9cclxuSWdsb28uVGV4dHVyZS5wcm90b3R5cGUuc3Vic2V0ID0gZnVuY3Rpb24oc291cmNlLCB4b2ZmLCB5b2ZmLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgdGhpcy5iaW5kKCk7XHJcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICBpZiAodGhpcy50eXBlID09IGdsLkZMT0FUKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZSA9IG5ldyBGbG9hdDMyQXJyYXkoc291cmNlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh3aWR0aCAhPSBudWxsIHx8IGhlaWdodCAhPSBudWxsKSB7XHJcbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB4b2ZmLCB5b2ZmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsIGhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIHNvdXJjZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgeG9mZiwgeW9mZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIHNvdXJjZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb3B5IHBhcnQvYWxsIG9mIHRoZSBjdXJyZW50IGZyYW1lYnVmZmVyIHRvIHRoaXMgaW1hZ2UuXHJcbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJWaWV3fFRleEltYWdlU291cmNlfSBzb3VyY2VcclxuICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcclxuICogQHJldHVybnMge0lnbG9vLlRleHR1cmV9XHJcbiAqL1xyXG5JZ2xvby5UZXh0dXJlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgIGdsLmNvcHlUZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZm9ybWF0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxyXG4gKiBAcGFyYW0ge1dlYkdMRnJhbWVidWZmZXJ9IFtmcmFtZWJ1ZmZlcl0gdG8gYmUgd3JhcHBlZCAobnVsbCBmb3IgZGVmYXVsdClcclxuICogQHJldHVybnMge0lnbG9vLkZyYW1lYnVmZmVyfVxyXG4gKi9cclxuSWdsb28uRnJhbWVidWZmZXIgPSBmdW5jdGlvbihnbCwgZnJhbWVidWZmZXIpIHtcclxuICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgIHRoaXMuZnJhbWVidWZmZXIgPVxyXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT0gMiA/IGZyYW1lYnVmZmVyIDogZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuICAgIHRoaXMucmVuZGVyYnVmZmVyID0gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7SWdsb28uRnJhbWVidWZmZXJ9XHJcbiAqL1xyXG5JZ2xvby5GcmFtZWJ1ZmZlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7SWdsb28uRnJhbWVidWZmZXJ9XHJcbiAqL1xyXG5JZ2xvby5GcmFtZWJ1ZmZlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7SWdsb28uVGV4dHVyZX0gdGV4dHVyZVxyXG4gKiBAcmV0dXJucyB7SWdsb28uRnJhbWVidWZmZXJ9XHJcbiAqL1xyXG5JZ2xvby5GcmFtZWJ1ZmZlci5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24odGV4dHVyZSkge1xyXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgIHRoaXMuYmluZCgpO1xyXG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS50ZXh0dXJlLCAwKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7SWdsb28uVGV4dHVyZX0gYXJyYXkgb2YgdGV4dHVyZXNcclxuICogQHJldHVybnMge0lnbG9vLkZyYW1lYnVmZmVyfVxyXG4gKi9cclxuSWdsb28uRnJhbWVidWZmZXIucHJvdG90eXBlLmF0dGFjaEFyciA9IGZ1bmN0aW9uKHRleHR1cmVzKSB7XHJcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfZHJhd19idWZmZXJzJyk7XHJcbiAgICB2YXIgYXR0YWNoSWR4ID0gMDtcclxuICAgIHZhciBhcnIgPSBbXTtcclxuXHJcbiAgICB0aGlzLmJpbmQoKTtcclxuICAgIHRleHR1cmVzLmZvckVhY2goZnVuY3Rpb24odGV4dHVyZSkge1xyXG4gICAgICB2YXIgYXR0YWNoSWR4U3RyID0gJ0NPTE9SX0FUVEFDSE1FTlQnICsgYXR0YWNoSWR4ICsnX1dFQkdMJztcclxuICAgICAgYXR0YWNoSWR4ICs9IDE7XHJcbiAgICAgIGFyci5wdXNoKGV4dFthdHRhY2hJZHhTdHJdKTtcclxuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGV4dFthdHRhY2hJZHhTdHJdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLnRleHR1cmUsIDApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc29sZS5sb2coJ2F0dGFjaEFycicpO1xyXG4gICAgY29uc29sZS5sb2coYXJyKTtcclxuICAgIGV4dC5kcmF3QnVmZmVyc1dFQkdMKGFycik7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEF0dGFjaCBhIHJlbmRlcmJ1ZmZlciBhcyBhIGRlcHRoIGJ1ZmZlciBmb3IgZGVwdGgtdGVzdGVkIHJlbmRlcmluZy5cclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcclxuICogQHJldHVybnMge0lnbG9vLkZyYW1lYnVmZmVyfVxyXG4gKi9cclxuSWdsb28uRnJhbWVidWZmZXIucHJvdG90eXBlLmF0dGFjaERlcHRoID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgIHRoaXMuYmluZCgpO1xyXG4gICAgaWYgKHRoaXMucmVuZGVyYnVmZmVyID09IG51bGwpIHtcclxuICAgICAgICB0aGlzLnJlbmRlcmJ1ZmZlciA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG4gICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9DT01QT05FTlQxNixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJidWZmZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/igloo.js\n");

/***/ }),

/***/ "./src/imageUtils.js":
/*!***************************!*\
  !*** ./src/imageUtils.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"loadImageByFile\": () => (/* binding */ loadImageByFile),\n/* harmony export */   \"loadImageByUrl\": () => (/* binding */ loadImageByUrl),\n/* harmony export */   \"loadImageFromCanvas\": () => (/* binding */ loadImageFromCanvas),\n/* harmony export */   \"resizeImage\": () => (/* binding */ resizeImage)\n/* harmony export */ });\n/* harmony import */ var pica__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pica */ \"./node_modules/pica/dist/pica.js\");\n/* harmony import */ var pica__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pica__WEBPACK_IMPORTED_MODULE_0__);\n\r\n \r\n\r\nfunction loadImageByUrl(url) {\r\n    return new Promise(resolve => {\r\n        let i = new Image();\r\n        i.onload = (() => resolve(i));\r\n        i.src = url;\r\n    });\r\n}\r\n\r\nfunction loadImageByFile(file) {\r\n    return new Promise(resolve => {\r\n        let reader = new FileReader();\r\n\r\n        reader.readAsDataURL(file);\r\n\r\n        reader.onload = async () => {\r\n            const res = await loadImageByUrl(reader.result)\r\n            resolve(res)\r\n        };\r\n    })\r\n}\r\n\r\nasync function loadImageFromCanvas(canvas) {\r\n    const url = canvas.toDataURL();\r\n    return await loadImageByUrl(url);\r\n}\r\n\r\nasync function resizeImage(img, w, h) {\r\n    var canvas = document.createElement('canvas');\r\n    canvas.width = w;\r\n    canvas.height = h;\r\n\r\n    const p = new (pica__WEBPACK_IMPORTED_MODULE_0___default())();\r\n    await p.resize(img, canvas);\r\n\r\n    return await loadImageFromCanvas(canvas)\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW1hZ2VVdGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUN1QjtBQUN2QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2Q0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbWFnZVV0aWxzLmpzPzA0MzQiXSwic291cmNlc0NvbnRlbnQiOlsiXHJcbmltcG9ydCBQaWNhIGZyb20gJ3BpY2EnIFxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRJbWFnZUJ5VXJsKHVybCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgIGxldCBpID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgaS5vbmxvYWQgPSAoKCkgPT4gcmVzb2x2ZShpKSk7XHJcbiAgICAgICAgaS5zcmMgPSB1cmw7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRJbWFnZUJ5RmlsZShmaWxlKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcblxyXG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xyXG5cclxuICAgICAgICByZWFkZXIub25sb2FkID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBsb2FkSW1hZ2VCeVVybChyZWFkZXIucmVzdWx0KVxyXG4gICAgICAgICAgICByZXNvbHZlKHJlcylcclxuICAgICAgICB9O1xyXG4gICAgfSlcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRJbWFnZUZyb21DYW52YXMoY2FudmFzKSB7XHJcbiAgICBjb25zdCB1cmwgPSBjYW52YXMudG9EYXRhVVJMKCk7XHJcbiAgICByZXR1cm4gYXdhaXQgbG9hZEltYWdlQnlVcmwodXJsKTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc2l6ZUltYWdlKGltZywgdywgaCkge1xyXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgY2FudmFzLndpZHRoID0gdztcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBoO1xyXG5cclxuICAgIGNvbnN0IHAgPSBuZXcgUGljYSgpO1xyXG4gICAgYXdhaXQgcC5yZXNpemUoaW1nLCBjYW52YXMpO1xyXG5cclxuICAgIHJldHVybiBhd2FpdCBsb2FkSW1hZ2VGcm9tQ2FudmFzKGNhbnZhcylcclxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/imageUtils.js\n");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _imageUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imageUtils.js */ \"./src/imageUtils.js\");\n/* harmony import */ var _canvasController_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canvasController.js */ \"./src/canvasController.js\");\n/* harmony import */ var _fft_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fft.js */ \"./src/fft.js\");\n\r\n\r\n\r\n\r\nif (document.readyState === \"complete\" ||\r\n    (document.readyState !== \"loading\" && !document.documentElement.doScroll)) {\r\n    main();\r\n} else {\r\n    document.addEventListener(\"DOMContentLoaded\", main);\r\n}\r\n\r\nfunction getElementsWithId() {\r\n\r\n    const res = {}\r\n    const elems = document.querySelectorAll('[id]')\r\n\r\n    for (const el of elems)\r\n        res[el.id] = el\r\n\r\n\r\n    return res;\r\n}\r\n\r\nasync function setImage(input, ctrl) {\r\n\r\n    const file = input.files[0];\r\n    let img = await (0,_imageUtils_js__WEBPACK_IMPORTED_MODULE_0__.loadImageByFile)(file);\r\n    img = await (0,_imageUtils_js__WEBPACK_IMPORTED_MODULE_0__.resizeImage)(img, 512, 512);\r\n\r\n    ctrl.setImage(img);\r\n}\r\n\r\nfunction main() {\r\n    const elems = getElementsWithId();\r\n\r\n    const spaceCtrl = new _canvasController_js__WEBPACK_IMPORTED_MODULE_1__.CanvasController(elems.space);\r\n    const magnitudeCtrl = new _canvasController_js__WEBPACK_IMPORTED_MODULE_1__.CanvasController(elems.magnitude);\r\n    const phaseCtrl = new _canvasController_js__WEBPACK_IMPORTED_MODULE_1__.CanvasController(elems.phase);\r\n\r\n    const forwardFourier = () => {\r\n        const arr = spaceCtrl.getArray();\r\n        const res = (0,_fft_js__WEBPACK_IMPORTED_MODULE_2__.fftPixelData)(arr, 512, 512);\r\n\r\n        magnitudeCtrl.setImage(res.magnitude, 512, 512);\r\n        magnitudeCtrl.shift(256, 256);\r\n\r\n        phaseCtrl.setImage(res.phase, 512, 512);\r\n        phaseCtrl.shift(256, 256);\r\n\r\n    }\r\n\r\n    spaceCtrl.drawHook = () => {\r\n        forwardFourier();\r\n    }\r\n\r\n    elems.space_input.onchange = async () => {\r\n        await setImage(elems.space_input, spaceCtrl);\r\n        spaceCtrl.sync();\r\n        forwardFourier();\r\n    }\r\n\r\n    elems.magnitude_input.onchange = async () => {\r\n        await setImage(elems.magnitude_input, magnitudeCtrl);\r\n    }\r\n\r\n    elems.phase_input.onchange = async () => {\r\n        await setImage(elems.phase_input, phaseCtrl);\r\n    }\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQThEO0FBQ047QUFDakI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtEQUFlO0FBQ25DLGdCQUFnQiwyREFBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrRUFBZ0I7QUFDMUMsOEJBQThCLGtFQUFnQjtBQUM5QywwQkFBMEIsa0VBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz81NmQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxvYWRJbWFnZUJ5RmlsZSwgcmVzaXplSW1hZ2UgfSBmcm9tICcuL2ltYWdlVXRpbHMuanMnXHJcbmltcG9ydCB7IENhbnZhc0NvbnRyb2xsZXIgfSBmcm9tICcuL2NhbnZhc0NvbnRyb2xsZXIuanMnXHJcbmltcG9ydCB7IGZmdFBpeGVsRGF0YSB9IGZyb20gJy4vZmZ0LmpzJ1xyXG5cclxuaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxyXG4gICAgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwpKSB7XHJcbiAgICBtYWluKCk7XHJcbn0gZWxzZSB7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBtYWluKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RWxlbWVudHNXaXRoSWQoKSB7XHJcblxyXG4gICAgY29uc3QgcmVzID0ge31cclxuICAgIGNvbnN0IGVsZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2lkXScpXHJcblxyXG4gICAgZm9yIChjb25zdCBlbCBvZiBlbGVtcylcclxuICAgICAgICByZXNbZWwuaWRdID0gZWxcclxuXHJcblxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gc2V0SW1hZ2UoaW5wdXQsIGN0cmwpIHtcclxuXHJcbiAgICBjb25zdCBmaWxlID0gaW5wdXQuZmlsZXNbMF07XHJcbiAgICBsZXQgaW1nID0gYXdhaXQgbG9hZEltYWdlQnlGaWxlKGZpbGUpO1xyXG4gICAgaW1nID0gYXdhaXQgcmVzaXplSW1hZ2UoaW1nLCA1MTIsIDUxMik7XHJcblxyXG4gICAgY3RybC5zZXRJbWFnZShpbWcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYWluKCkge1xyXG4gICAgY29uc3QgZWxlbXMgPSBnZXRFbGVtZW50c1dpdGhJZCgpO1xyXG5cclxuICAgIGNvbnN0IHNwYWNlQ3RybCA9IG5ldyBDYW52YXNDb250cm9sbGVyKGVsZW1zLnNwYWNlKTtcclxuICAgIGNvbnN0IG1hZ25pdHVkZUN0cmwgPSBuZXcgQ2FudmFzQ29udHJvbGxlcihlbGVtcy5tYWduaXR1ZGUpO1xyXG4gICAgY29uc3QgcGhhc2VDdHJsID0gbmV3IENhbnZhc0NvbnRyb2xsZXIoZWxlbXMucGhhc2UpO1xyXG5cclxuICAgIGNvbnN0IGZvcndhcmRGb3VyaWVyID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFyciA9IHNwYWNlQ3RybC5nZXRBcnJheSgpO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGZmdFBpeGVsRGF0YShhcnIsIDUxMiwgNTEyKTtcclxuXHJcbiAgICAgICAgbWFnbml0dWRlQ3RybC5zZXRJbWFnZShyZXMubWFnbml0dWRlLCA1MTIsIDUxMik7XHJcbiAgICAgICAgbWFnbml0dWRlQ3RybC5zaGlmdCgyNTYsIDI1Nik7XHJcblxyXG4gICAgICAgIHBoYXNlQ3RybC5zZXRJbWFnZShyZXMucGhhc2UsIDUxMiwgNTEyKTtcclxuICAgICAgICBwaGFzZUN0cmwuc2hpZnQoMjU2LCAyNTYpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzcGFjZUN0cmwuZHJhd0hvb2sgPSAoKSA9PiB7XHJcbiAgICAgICAgZm9yd2FyZEZvdXJpZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBlbGVtcy5zcGFjZV9pbnB1dC5vbmNoYW5nZSA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBzZXRJbWFnZShlbGVtcy5zcGFjZV9pbnB1dCwgc3BhY2VDdHJsKTtcclxuICAgICAgICBzcGFjZUN0cmwuc3luYygpO1xyXG4gICAgICAgIGZvcndhcmRGb3VyaWVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZWxlbXMubWFnbml0dWRlX2lucHV0Lm9uY2hhbmdlID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IHNldEltYWdlKGVsZW1zLm1hZ25pdHVkZV9pbnB1dCwgbWFnbml0dWRlQ3RybCk7XHJcbiAgICB9XHJcblxyXG4gICAgZWxlbXMucGhhc2VfaW5wdXQub25jaGFuZ2UgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgc2V0SW1hZ2UoZWxlbXMucGhhc2VfaW5wdXQsIHBoYXNlQ3RybCk7XHJcbiAgICB9XHJcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;